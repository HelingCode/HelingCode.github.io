<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>977.有序数组的平方</title>
    <url>/posts/35851.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">题目</a>描述：</p>
<span id="more"></span>
<blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
</blockquote>
<p>简单的思路就是暴力破解了，没什么说的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; ++i)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlogn)。</p>
<p>接下来使用双指针法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]*nums[l] &gt; nums[r]*nums[r])&#123;</span><br><span class="line">                res[k--] = nums[l]*nums[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[k--] = nums[r]*nums[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>26.删除数组中的重复项</title>
    <url>/posts/5982.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">题目</a>描述：</p>
<span id="more"></span>
<blockquote>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。  </p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
</blockquote>
<p>使用双指针法，定义快慢指针，首先定义慢指针为0；快指针为1；然后循环快指针，如果快指针指向的元素不等于慢指针指向的元素，那么令快指针指向的元素等于慢指针指向的元素的后一个元素。最终返回慢指针+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">1</span>;fastIndex &lt; nums.length; ++fastIndex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[lowIndex] != nums[fastIndex])&#123;</span><br><span class="line">                nums[lowIndex + <span class="number">1</span>] = nums[fastIndex];</span><br><span class="line">                ++lowIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>209.长度最小的子数组</title>
    <url>/posts/44730.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">题目</a>描述：</p>
<span id="more"></span>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
</blockquote>
<p>首先想到的肯定是暴力解法，使用两个for循环，然后不断地寻找满足条件的子序列，时间复杂度是O(n^2)。</p>
<p>下面介绍使用滑动窗口的解法。</p>
<p>滑动窗口其实就是双指针，通过两个指针不断改变子序列的起始位置和结束位置，直到找到长度最小的子序列。解题的关键就是需要注意如何移动起始位置和结束位置的指针。如果当前的窗口里面的值的和大于给定的值了，那么就可以向前移动初始位置的指针，而结束位置的指针只是用来遍历数组的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length; ++right)&#123; <span class="comment">//结束指针遍历数组</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                result = Math.min(result,right-left+<span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++]; <span class="comment">//移动初始指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7启动Tomcat后浏览器无法访问的解决方法</title>
    <url>/posts/2483.html</url>
    <content><![CDATA[<p>自己的Linux系统是CentOS7,今天在学习Tomcat的使用的时候，在Linux里面启动成功之后，在Windows浏览器访问<code>http://ip地址:8080</code>失败，原来需要有防火墙的相关操作，要编辑/etc/sysconfig目录下面的iptables文件，但是CentOS7中没有这个文件，所以如果要对防火墙操作，需要更新或者重新安装防火墙服务。</p>
<span id="more"></span>
<p>解决步骤如下：</p>
<ol>
<li><p>安装或者更新iptables-services</p>
<p><code>yum install iptables-services</code></p>
</li>
<li><p>启动iptables</p>
<p><code>systemctl enable iptables</code></p>
<p>这个时候，/etc/sysconfig目录下面就有了iptables文件了。</p>
</li>
<li><p>打开iptables</p>
<p><code>systemctl start iptables</code></p>
</li>
<li><p>编辑防火墙配置</p>
<p><code>$ vi /etc/sysconfig/iptables</code></p>
</li>
<li><p>添加8080端口的防火墙,允许访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入i开始编辑,ESC键结束编辑,wq保存并退出.</p>
</li>
<li><p>重启防火墙</p>
<p><code>$ service iptables restart</code></p>
</li>
</ol>
<p>之后就可以在本机通过浏览器访问<code>http://ip地址:8080</code>,就可以正常看到tomcat的默认欢迎页面了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程面试题</title>
    <url>/posts/java-juc.html</url>
    <content><![CDATA[<h3 id="1-Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？"><a href="#1-Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？" class="headerlink" title="1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？"></a><a href="">1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</a></h3><p>有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<h3 id="2-sleep-和-wait-有什么区别"><a href="#2-sleep-和-wait-有什么区别" class="headerlink" title="2.sleep() 和 wait() 有什么区别?"></a><a href="">2.sleep() 和 wait() 有什么区别?</a></h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放）,该线程才能回到可运行状态等待获取锁。</p>
<h3 id="3-同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#3-同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="3.同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a><a href="">3.同步和异步有何异同，在什么情况下分别使用他们？举例说明。</a></h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="4-多线程有几种实现方法-同步有几种实现方法"><a href="#4-多线程有几种实现方法-同步有几种实现方法" class="headerlink" title="4.多线程有几种实现方法?同步有几种实现方法?"></a><a href="">4.多线程有几种实现方法?同步有几种实现方法?</a></h3><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。</p>
<p>同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</p>
<p>notityAll():唤醒所有处于等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h3 id="5-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#5-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="5.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a><a href="">5.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></h3><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h3 id="6-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#6-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="6.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a><a href="">6.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</a></h3><p>分几种情况：</p>
<p>1）其他方法前是否加了synchronized关键字，如果没加，则能。</p>
<p>2）如果这个方法内部调用了wait，则可以进入其他synchronized方法。</p>
<p>3）如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</p>
<p>4）如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</p>
<h3 id="7-线程的基本概念、线程的基本状态以及状态之间的关系。"><a href="#7-线程的基本概念、线程的基本状态以及状态之间的关系。" class="headerlink" title="7.线程的基本概念、线程的基本状态以及状态之间的关系。"></a><a href="">7.线程的基本概念、线程的基本状态以及状态之间的关系。</a></h3><p>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，从宏观上来看，cpu一会执行a线程，一会执行b线程，切换时间很快，给人的感觉是a,b在同时执行。</p>
<p>状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。</p>
<p>调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。</p>
<h3 id="8-简述synchronized和java-util-concurrent-locks-Lock的异同-？"><a href="#8-简述synchronized和java-util-concurrent-locks-Lock的异同-？" class="headerlink" title="8.简述synchronized和java.util.concurrent.locks.Lock的异同 ？"></a><a href="">8.简述synchronized和java.util.concurrent.locks.Lock的异同 ？</a></h3><p>主要相同点：Lock能完成synchronized所实现的所有功能。</p>
<p>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手动释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去获得锁。</p>
<h3 id="9-Java多线程编程时有哪几种线程间通信方式？（跟谁学）"><a href="#9-Java多线程编程时有哪几种线程间通信方式？（跟谁学）" class="headerlink" title="9.Java多线程编程时有哪几种线程间通信方式？（跟谁学）"></a><a href="">9.Java多线程编程时有哪几种线程间通信方式？（跟谁学）</a></h3><ol>
<li><p><strong>共享内存法</strong></p>
<p>volatile，synchronized</p>
</li>
<li><p><strong>wait/notify机制</strong></p>
<p>来自Object类的方法。当满足某种情况时A线程调用wait()方法放弃CPU时间片，并进入阻塞状态。当满足某种条件时，B线程调用notify()方法通知A线程。唤醒A线程，并让它进入可运行状态。</p>
</li>
<li><p><strong>Lock/Condition机制</strong></p>
<p>Condition是Java提供来实现<strong>等待/通知</strong>的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p>
</li>
</ol>
<h3 id="10-volatile如何实现内存可见性？（美团）（字节跳动）"><a href="#10-volatile如何实现内存可见性？（美团）（字节跳动）" class="headerlink" title="10.volatile如何实现内存可见性？（美团）（字节跳动）"></a><a href="">10.volatile如何实现内存可见性？（美团）（字节跳动）</a></h3><p><strong>volatile为什么会出现：</strong>（字节跳动）</p>
<p>首先先分析一下没有volatile的情况下线程在自己的私有内存中对共享变量做出了改变之后无法及时告知其他线程，这就是volatile的作用，解决内存可见性问题。这种问题用synchronized关键字可以解决。但是一个问题是synchronized是重量级锁，同一时间内只允许一个线程去操作共享变量。操作完成之后再将改变后的变量值刷新回共享内存空间中。这样一来的话并发性就没有了。而且<strong>synchronized关键词的使用基于操作系统实现</strong>，会使得线程从用户态陷入内核态。这一步是很耗时间的。于使volatile应运而生。它是一个轻量级的synchronized。只是用来解决内存可见性问题的。</p>
<p><strong>1、volatile可见性实现原理：</strong>（字节跳动）</p>
<p>变量被volatile关键字修饰后，底层<strong>汇编指令</strong>中会出现一个<strong>lock前缀指令</strong>。会导致以下两种事情的发生：</p>
<ol>
<li>修改volatile变量时会<strong>强制</strong>将修改后的值刷新到主内存中。</li>
<li>修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新读取主内存中的值。</li>
</ol>
<p><strong>2、volatile有序性实现原理：</strong>（字节跳动）</p>
<p><strong>指令重排序：</strong>编译器在不改变单线程程序语义的前提下，会重新安排语句的执行顺序，指令重排序在单线程下不会有问题，但是在多线程下，可能会出现问题。</p>
<p>volatile有序性的保证就是通过<strong>禁止指令重排序</strong>来实现的。指令重排序包括编译器和处理器重排序，JMM会分别限制这两种指令重排序。禁止指令重排序又是通过加<strong>内存屏障</strong>实现的。</p>
<blockquote>
<p>内存屏障（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。</p>
</blockquote>
<p>添加了volatile关键字可以避免半初始化的指令重排。</p>
<h3 id="11-volatile为什么不保证原子性？"><a href="#11-volatile为什么不保证原子性？" class="headerlink" title="11.volatile为什么不保证原子性？"></a><a href="">11.volatile为什么不保证原子性？</a></h3><p>Java中只有对变量的赋值和读取是原子性的，其他的操作都不是原子性的。所以即使volatile即使能保证被修饰的变量具有可见性，但是不能保证原子性。</p>
<h3 id="12-了解CountDownLatch吗？"><a href="#12-了解CountDownLatch吗？" class="headerlink" title="12.了解CountDownLatch吗？"></a><a href="">12.了解CountDownLatch吗？</a></h3><p><strong>闭锁</strong>可以用来确保某些活动直到其他活动全部结束之后才进行；</p>
<p>主要包含两个方法，一个是<code>countDown()</code>，一个是<code>await()</code>;以及一个计数器变量<code>cnt</code>。<code>countDown()</code> 方法用来给计数器<code>cnt</code>减一； <code>await()</code> 方法是用来阻塞当前线程，直到计数器为0的时候再唤醒线程继续执行；</p>
<h3 id="13-了解Semaphore吗"><a href="#13-了解Semaphore吗" class="headerlink" title="13.了解Semaphore吗?"></a><a href="">13.了解Semaphore吗?</a></h3><p>信号量，用于多个共享资源的互斥使用，也可以<strong>用来控制线程的并发量</strong>，类似于线程池的作用。</p>
<p>可以用于限制线程的并发数。</p>
<h3 id="14-Thread-Local-作用、原理、内存泄漏问题？（字节跳动）（滴滴）"><a href="#14-Thread-Local-作用、原理、内存泄漏问题？（字节跳动）（滴滴）" class="headerlink" title="14.Thread Local 作用、原理、内存泄漏问题？（字节跳动）（滴滴）"></a><a href="">14.Thread Local 作用、原理、内存泄漏问题？（字节跳动）（滴滴）</a></h3><p><strong>作用：</strong></p>
<p><code>ThreadLocal</code>为解决多线程下的线程安全问题提供了一个新思路，它通过为每一个线程提供一个独立的变量副本解决了线程并发访问共享变量出现的安全问题。在很多情况下<code>ThreadLocal</code>比直接使用synchronized同步机制解决线程安全问题更加方便、简洁。且拥有更加高的并发性。</p>
<p><strong>原理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在每个线程Thread内部有一个<code>ThreadLocal.ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，这个<code>threadLocals</code>就是用来<strong>存储实际的变量副本</strong>的，键值为当前<code>ThreadLocal</code>的引用，value为变量副本（即T类型的变量）。</li>
<li>初始时，在Thread里面，<code>threadLocals</code>为空，当通过<code>ThreadLocal</code>变量调用get()方法或者set()方法，就会对Thread类中的<code>threadLocals</code>进行初始化，并且以当前<code>ThreadLocal</code>对象引用为键值，以<code>ThreadLocal</code>要保存的副本变量为value，存到<code>threadLocals</code>。</li>
<li>然后在当前线程里面，如果要使用副本变量，就可以通过get()方法在<code>threadLocals</code>里面查找。</li>
</ol>
<p><strong><code>ThreadLocal</code>内存泄漏</strong></p>
<p>由于<code>ThreadLocalMap</code>的key是弱引用，而<code>Value</code>是强引用。这就导致了一个问题，<code>ThreadLocal</code>在没有外部对象强引用时，发生GC时（无论是否OOM）弱引用Key会被回收。这个时候就会出现Entry中Key已经被回收，出现一个<code>null Key</code>的情况，外部读取<code>ThreadLocalMap</code>中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的<code>ThreadLocalMap</code>对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：<code>Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value</code>，这条强引用链会导致<code>Entry</code>不会回收， <code>Value</code>也不会回收，但Entry中的Key却已经被回收的情况，造成<strong>内存泄漏</strong>。</p>
<p><strong>解决办法：</strong>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</p>
<p><strong><code>ThreadLocal</code>应用场景</strong></p>
<p>最常见的<code>ThreadLocal</code>使用场景为 用来解决 数据库连接、Session管理等。</p>
<h3 id="15-AQS内部如何控制并发？（字节跳动）"><a href="#15-AQS内部如何控制并发？（字节跳动）" class="headerlink" title="15.AQS内部如何控制并发？（字节跳动）"></a><a href="">15.AQS内部如何控制并发？（字节跳动）</a></h3><p><code>AQS（AbstractQueuedSynchronizer）</code>是<code>J.U.C</code>包下<strong>lock</strong>实现的核心。主要是其提供的一个FIFO的队列来维护获取锁失败而进入阻塞的线程，以及一个volatile关键字修饰的state变量表示当前同步状态。当一个线程获取到同步状态（修改state=1），那么其他线程便无法获取，转而被构造成节点并加入同步队列中。<strong>加入队列的过程基于CAS算法。即比较当前线程认为的尾节点与当前节点，比较成功后才能正式加入队列尾部。</strong>队列头节点表示的为当前正在运行的线程，该线程执行结束后会激活它下面的一个线程进入执行状态。</p>
<p>FIFO同步队列控制并发。</p>
<h3 id="16-DCL单例为什么需要加volatile-（半初始化的指令重排）？（滴滴）（字节跳动）"><a href="#16-DCL单例为什么需要加volatile-（半初始化的指令重排）？（滴滴）（字节跳动）" class="headerlink" title="16.DCL单例为什么需要加volatile （半初始化的指令重排）？（滴滴）（字节跳动）"></a><a href="">16.DCL单例为什么需要加volatile （半初始化的指令重排）？（滴滴）（字节跳动）</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。 使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<p>volatile两个作用：保持线程可见性；<strong>禁止指令重排序</strong>。</p>
<p><strong>DCL单例需要加volatile，来禁止指令重排。</strong></p>
<p>由于java编译器允许处理器乱序执行（以获得最优的性能），new对象的操作不是原子性的。这句代码最终会被编译成多条汇编指令。所以需要volatile关键字来禁止指令重排。</p>
<p><strong>创建一个对象的过程中一旦出现了指令重排，可能就会获得半初始化的对象，</strong>即还没来得及赋值就先建立了引用关系。要避免这种情况的发生就要使用volatile关键字修饰实列变量。</p>
<p><strong>第一次判断singleton是否为null</strong><br>  第一次判断是在Synchronized同步代码块外进行判断，由于单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以，第一次判断，是为了在singleton对象已经创建的情况下，避免进入同步代码块，提升效率。</p>
<p><strong>第二次判断singleton是否为null</strong><br>  第二次判断是为了避免以下情况的发生。<br>  (1)假设：线程A已经经过第一次判断，判断singleton=null，准备进入同步代码块.<br>  (2)此时线程B获得时间片，由于线程A并没有创建实例，所以，判断singleton仍然=null，所以线程B创建了实例singleton。<br>  (3)此时，线程A再次获得时间片，由于刚刚经过第一次判断singleton=null(不会重复判断)，进入同步代码块，这个时候，我们如果不加入第二次判断的话，那么线程A又会创造一个实例singleton，就不满足我们的单例模式的要求，所以第二次判断是很有必要的。</p>
<h3 id="17-Java的线程模型"><a href="#17-Java的线程模型" class="headerlink" title="17.Java的线程模型"></a><a href="">17.Java的线程模型</a></h3><p>1.用户线程与内核级线程</p>
<p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。</p>
<p>2.并发与并行</p>
<p><strong>并发：</strong>一个时间段内有很多的线程或进程在执行，但任何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。<br><strong>并行：</strong>一个时间段和时间点上都有多个线程或进程在执行。</p>
<p>3.多线程模型</p>
<p>多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。</p>
<h3 id="18-线程与进程区别？"><a href="#18-线程与进程区别？" class="headerlink" title="18.线程与进程区别？"></a><a href="">18.<strong>线程与进程区别？</strong></a></h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<h3 id="19-谈一下AQS，为什么底层使用CAS和volatile？-字节跳动"><a href="#19-谈一下AQS，为什么底层使用CAS和volatile？-字节跳动" class="headerlink" title="19.谈一下AQS，为什么底层使用CAS和volatile？(字节跳动)"></a><a href="">19.谈一下AQS，为什么底层使用CAS和volatile？(字节跳动)</a></h3><ol>
<li>AQS源码中<code>state</code>状态值使用<code>volatile</code>修饰保证内存的可见性。因为涉及到多线程对state的修改，必须保证其对所有线程的可见性。</li>
<li>CAS操作主要用于对state值的修改。</li>
</ol>
<h3 id="20-Synchronized与ReentrantLock的区别？（太多了）（美团）"><a href="#20-Synchronized与ReentrantLock的区别？（太多了）（美团）" class="headerlink" title="20.Synchronized与ReentrantLock的区别？（太多了）（美团）"></a><a href="">20.Synchronized与ReentrantLock的区别？（太多了）（美团）</a></h3><p><strong>实现原理上:</strong></p>
<p><code>synchronized</code>是依靠<code>jvm</code>以及配合操作系统来实现，是一个<strong>关键字</strong>。<code>reentrantLock</code>是<code>jdk1.5</code>之后提供的<strong>API层面</strong>的互斥锁。</p>
<p><strong>使用便利性上：</strong></p>
<p><code>synchronized</code>只需要添加上相关关键字即可，加锁与释放过程由操作系统完成。<code>reentrantLock</code>则需要手动加锁与释放锁。</p>
<p><strong>锁粒度与灵活度：</strong></p>
<p>reentrantLock<code>要强于</code>synchronized</p>
<p><code>reentrantLock</code>提供了<strong>三个高级功能</strong>:</p>
<ol>
<li><strong>等待可中断</strong>，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相对于Synchronized来说可以避免出现死锁的情况。通过<code>lock.lockInterruptibly()</code>来实现这个机制。</li>
<li>多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁是非公平锁，<code>ReentrantLock</code>默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
<li>一个<code>ReentrantLock</code>对象可以同时绑定多个对象。<code>ReenTrantLock</code>提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
</ol>
<p><strong>性能区别：</strong></p>
<p><code>synchronized</code>优化之后性能与<code>reentrantLock</code>已经不相上下了，官方甚至更建议使用<code>synchronized</code>关键字。</p>
<h3 id="21-Synchronized实现原理？（美团）（字节）（滴滴）-待完善"><a href="#21-Synchronized实现原理？（美团）（字节）（滴滴）-待完善" class="headerlink" title="21.Synchronized实现原理？（美团）（字节）（滴滴）(待完善)"></a><a href="">21.Synchronized实现原理？（美团）（字节）（滴滴）<code>(待完善)</code></a></h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>每个对象（在对象头中）有一个<strong>监视器锁</strong><code>（monitor）</code>，当monitor被占用时就处于锁定状态。线程执行<code>monitorenter</code>（汇编指令）尝试获取monitor的所有权。</p>
<ol>
<li>如果monitor计数器当前值为0，那么该线程进入monitor并将计数器加1，</li>
<li>如果当前monitor计数器值不为0，那么该线程阻塞并进入（OS维护的）队列等待，等到OS的调度。</li>
</ol>
<p>底层字节码被编译成<code>monitorenter</code>和<code>monitorexit</code>两个指令。线程执行<code>monitorexit</code>指令，monitor计数器减1，如果减到0了，表示当前线程不再拥有该监视器锁。等待队列中的线程有机会获得锁资源。</p>
<p>在synchronized大（优化）升级之前，是重量级锁，锁操作都要经过OS。向OS内核去申请。（<code>jdk1.5之后</code>）到现在的synchronized是有一个复杂的锁升级过程。</p>
<p><strong>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁） -&gt; （重量级锁）悲观锁。</strong></p>
<p>以上的升级状态都记录在对象头中。</p>
<p><strong>偏向锁：</strong>hotspot虚拟机认为大多数时间是不存在锁竞争的，所以每次都会把锁分配给上一次获得锁的线程，直到出现了锁竞争。</p>
<p><strong>自旋锁：</strong>线程之间以CAS的方式进行锁资源的争抢。当一个线程自旋超过了10次或者当前自旋等待的线程超过了CPU核数的1/2（升级后优化为自适应自旋），会进行锁升级。</p>
<p><strong>synchronized：</strong> 向OS申请资源，从用户态切换到内核态。线程挂起进入<strong>等待队列</strong>，等待OS的调度。然后再映射回用户空间。</p>
<h3 id="22-追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）"><a href="#22-追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）" class="headerlink" title="22.追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）"></a><a href="">22.追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）</a></h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor 实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h3 id="23-追问，什么是可重入性，为什么说-Synchronized-是可重入锁？（字节）"><a href="#23-追问，什么是可重入性，为什么说-Synchronized-是可重入锁？（字节）" class="headerlink" title="23.追问，什么是可重入性，为什么说 Synchronized 是可重入锁？（字节）"></a><a href="">23.追问，什么是可重入性，为什么说 Synchronized 是可重入锁？（字节）</a></h3><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220309201446490.png" alt="image-20220309201446490"></p>
<h3 id="24-synchronized可重入锁的实现？"><a href="#24-synchronized可重入锁的实现？" class="headerlink" title="24.synchronized可重入锁的实现？"></a><a href="">24.synchronized可重入锁的实现？</a></h3><p>重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p>
<h3 id="25-追问，为什么说-Synchronized-是非公平锁"><a href="#25-追问，为什么说-Synchronized-是非公平锁" class="headerlink" title="25.追问，为什么说 Synchronized 是非公平锁?"></a><a href="">25.追问，为什么说 Synchronized 是非公平锁?</a></h3><p>Synchronized底层是调用mutex锁的，内核提供的这个锁并不保证公平。而Java所提供的公平锁Lock实际上是由Java的API支持的（即对AQS的实现）</p>
<p>非公平是指在获取锁的行为上，并不是按照线程申请顺序进行分配的，当锁被释放后，所有线程都有机会获取到锁，这样提高了性能，但是可能会出现某些线程饥饿的情况。</p>
<h3 id="26-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#26-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="26.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a><a href="">26.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</a></h3><p>当 Synchronized升级为重量级锁时，他是一个悲观锁。<strong>获取不到锁资源的线程由OS统一管理</strong>，涉及到用户态到内核态的切换。</p>
<p>乐观锁就是，当一个线程想要对变量进行操作时，先读取变量值，然后真正更改时会再次对比当前值与自己之前读取的值是否相同，相同才会进行更改，不相同的话就会再次读取，然后在进行对比更改。主要是基于CAS实现。</p>
<p>CAS(compare and swap) ：它涉及到3个操作数:1.内存值,预期值, 新值,只有当内存值和预期值相等的时候(证明没有其他线程在使用),才会将内存值设置为新值。</p>
<p>CAS具有原子性,他的原子性由CPU保证,由JNI调用c++硬件代码实现,<code>jdk</code>中提供了unsafe来进行这些操作。</p>
<h3 id="27-什么是锁消除和锁粗化？"><a href="#27-什么是锁消除和锁粗化？" class="headerlink" title="27.什么是锁消除和锁粗化？"></a><a href="">27.什么是锁消除和锁粗化？</a></h3><p>锁消除即删除不必要的加锁操作。JVM在运行时，对一些“在代码上要求同步，但是<strong>被检测到不可能存在共享数据竞争情况”的锁进行消除</strong>。根据代码逃逸技术，如果判断到一段代码中，<strong>堆上的数据不会逃逸出当前线程</strong>，那么就可以认为这段代码是线程安全的，无需加锁。</p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockClearTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearTest</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            test.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer的append代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码看出来，StringBuffer的append是个同步方法，但是LockClearTest中的 StringBuffer 属于一个局部变量，不可能从该方法中逃逸出去（即stringBuffer的引用没有传递到该方法外，不会被其他线程引用），因此其实这过程是线程安全的，可以将锁消除。</p>
<p>假设一系列的连续操作都会<strong>对同一个对象反复加锁及解锁</strong>，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会<strong>扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</strong></p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码每次调用 stringBuffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h3 id="28-乐观锁一定就是好的吗？"><a href="#28-乐观锁一定就是好的吗？" class="headerlink" title="28.乐观锁一定就是好的吗？"></a><a href="">28.乐观锁一定就是好的吗？</a></h3><p>不一定</p>
<ol>
<li>乐观锁的情况下，如果线程并发度确实很高，那么大多数的线程都会处于自旋等待以获取锁对象的状态。这样会导致CPU占用过高。</li>
<li>CAS另一个缺点就是ABA问题。一个值从A改为B又改为A,则CAS认为没有发生变化,解决的方式是使用<strong>版本号</strong>来记录操作次数。</li>
</ol>
<h3 id="29-ReentrantLock实现原理？"><a href="#29-ReentrantLock实现原理？" class="headerlink" title="29.ReentrantLock实现原理？"></a><a href="">29.ReentrantLock实现原理？</a></h3><h3 id="30-AQS原理？"><a href="#30-AQS原理？" class="headerlink" title="30.AQS原理？"></a><a href="">30.AQS原理？</a></h3><p>AQS框架是用来构建锁的同步器框架,包括了常用的<code>ReentrantLock</code>,<code>ReadWriteLock</code>,<code>CountDownLatch</code>等都是基于AQS框架来实现的。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS 使用一个 int 成员变量state来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态state进行原子操作实现对其值的修改。</p>
<h3 id="31-程序计数器为什么线程是私有的"><a href="#31-程序计数器为什么线程是私有的" class="headerlink" title="31.程序计数器为什么线程是私有的?"></a><a href="">31.程序计数器为什么线程是私有的?</a></h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="32-虚拟机栈和本地方法栈为什么线程是私有的"><a href="#32-虚拟机栈和本地方法栈为什么线程是私有的" class="headerlink" title="32.虚拟机栈和本地方法栈为什么线程是私有的?"></a><a href="">32.虚拟机栈和本地方法栈为什么线程是私有的?</a></h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="33-什么是上下文切换"><a href="#33-什么是上下文切换" class="headerlink" title="33.什么是上下文切换?"></a><a href="">33.什么是上下文切换?</a></h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="34-产生死锁必须具备以下四个条件：（美团）"><a href="#34-产生死锁必须具备以下四个条件：（美团）" class="headerlink" title="34.产生死锁必须具备以下四个条件：（美团）"></a><a href="">34.产生死锁必须具备以下四个条件：（美团）</a></h3><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="35-如何预防和避免线程死锁"><a href="#35-如何预防和避免线程死锁" class="headerlink" title="35.如何预防和避免线程死锁?"></a><a href="">35.如何预防和避免线程死锁?</a></h3><p><a href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<p>​    1.<strong>破坏互斥条件</strong>:使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p> <strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。</p>
<h3 id="36-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#36-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="36.说说 synchronized 关键字和 volatile 关键字的区别"></a><a href="">36.说说 synchronized 关键字和 volatile 关键字的区别</a></h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h3 id="37-线程池以及使用线程池的好处"><a href="#37-线程池以及使用线程池的好处" class="headerlink" title="37.线程池以及使用线程池的好处"></a><a href="">37.线程池以及使用线程池的好处</a></h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p>
<h3 id="38-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#38-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="38.执行 execute()方法和 submit()方法的区别是什么呢？"></a><a href="">38.执行 execute()方法和 submit()方法的区别是什么呢？</a></h3><p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="39-ThreadPoolExecutor构造函数重要参数分析"><a href="#39-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="39.ThreadPoolExecutor构造函数重要参数分析"></a><a href="">39.<code>ThreadPoolExecutor</code>构造函数重要参数分析</a></h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :线程工厂。</li>
<li><strong><code>handler</code></strong> :拒绝策略。</li>
</ol>
<p>​         <strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求，将工作队列中等待在最前面的任务丢弃，然后将新来的任务放进等待队列中。</li>
</ul>
<h3 id="40-线程池的参数怎么设置？"><a href="#40-线程池的参数怎么设置？" class="headerlink" title="40.线程池的参数怎么设置？"></a><a href="">40.线程池的参数怎么设置？</a></h3><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="41-悲观锁和乐观锁的区别"><a href="#41-悲观锁和乐观锁的区别" class="headerlink" title="41.悲观锁和乐观锁的区别"></a><a href="">41.悲观锁和乐观锁的区别</a></h3><p><a href="https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82">https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82</a></p>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>
<ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>
</ul>
<h3 id="42-MySQL如何实现乐观锁？"><a href="#42-MySQL如何实现乐观锁？" class="headerlink" title="42.MySQL如何实现乐观锁？"></a><a href="">42.MySQL如何实现乐观锁？</a></h3><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p>
<p>乐观锁的实现原理：</p>
<ol>
<li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。</li>
<li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。</li>
<li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li>
</ol>
<p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h3 id="43-多线程操作-static-变量会有影响吗？"><a href="#43-多线程操作-static-变量会有影响吗？" class="headerlink" title="43.多线程操作 static 变量会有影响吗？"></a><a href="">43.多线程操作 static 变量会有影响吗？</a></h3><p>当多个线程执行同一个方法的时候，并且方法中使用了静态变量的时候，就会出现安全问题， 因为静态成员（static member）作为公共变量，是放在共享内存区域的。 多个线程共享一块内存区域，在不加任何保护情况下对其操作就会出现异常结果。</p>
<p><strong>解决方法：</strong></p>
<p>不使用共享内存，每个线程内存空间相互独立；<br>多线程共享一块内存区域，但是对这块共享区域加锁访问。对调用static变量的方法使用lock或synchronized</p>
<h3 id="44-为什么要使用多线程"><a href="#44-为什么要使用多线程" class="headerlink" title="44.为什么要使用多线程?"></a><a href="">44.为什么要使用多线程?</a></h3><p>从系统应用上来思考：</p>
<ul>
<li>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间切换和调度的成本远远小于进程。另外，多核 CPU 时代，意味着多个线程可以同时运行，这减少了线程上下文切换的开销；</li>
<li>如今的系统，动不动就要求百万级甚至亿万级的并发量，而多线程并发编程，正是开发高并发系统的基础，利用好多线程机制，可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>从计算机背后来探讨：</p>
<p><strong>单核时代：</strong> 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程工作的时候，会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。可以简单地理解成，这两者的利用率最高都是 50%左右。但是当有两个线程的时候就不一样了，一个线程执行 CPU 计算时，另外一个线程就可以进行 IO 操作，这样 CPU 和 IO 设备两个的利用率就可以在理想情况下达到 100%；</p>
<p><strong>多核时代：</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只有一个 CPU 核心被利用到，而创建多个线程，就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p>
<p><strong>多线程相比单线程的优势，存在什么问题？</strong></p>
<p>多线程适用场景</p>
<p>   1）存在需要等待IO、网络或其他外部资源的任务。当前等待其他资源却依旧占用CPU的线程可让出CPU，让其他线程执行，大大提高了程序效率，充分利用了CPU资源。</p>
<p>   2）存在长时间占用CPU的任务。CPU以时间片为单位分配给各个线程，一个周期内各个线程都可以得到执行，而非卡在一个线程。而且多线程意味着分配到的CPU时间片也更多。</p>
<p>多线程弊端</p>
<p>   1）访问共享资源时要小心，需要更多的锁资源，同步更加复杂。</p>
<p>   2）<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>占用更多，资源开销更大。</p>
<p>   3）需要额外的线程调度和管理。如需要CPU时间来跟踪线程。</p>
<h3 id="45-synchronized修饰的对象"><a href="#45-synchronized修饰的对象" class="headerlink" title="45.synchronized修饰的对象"></a><a href="">45.synchronized修饰的对象</a></h3><ul>
<li>修饰一个类：其作用的范围是synchronized后面括号括起来的部分，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个方法：被修饰的方法称为同步方法，其作用的范围是整个方法，<strong>作用的对象是调用这个方法的对象</strong>；</li>
<li>修饰一个静态的方法：其作用的范围是整个方法，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个代码块：被修饰的代码块称为同步语句块，其作用范围是大括号{}括起来的代码块，<strong>作用的对象是调用这个代码块的对象</strong>；</li>
</ul>
<h3 id="46-BIO-NIO-AIO"><a href="#46-BIO-NIO-AIO" class="headerlink" title="46.BIO/NIO/AIO"></a><a href="">46.BIO/NIO/AIO</a></h3><h4 id="Java中的IO原理"><a href="#Java中的IO原理" class="headerlink" title="Java中的IO原理"></a>Java中的IO原理</h4><p>首先Java中的IO都是依赖操作系统内核进行的，我们程序中的IO读写其实调用的是操作系统内核中的read&amp;write两大系统调用。</p>
<p>那内核是如何进行IO交互的呢？</p>
<ol>
<li>网卡收到经过网线传来的网络数据，并将网络数据写到内存中。</li>
<li>当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</li>
<li>将内存中的网络数据写入到对应socket的接收缓冲区中。</li>
<li>当接收缓冲区的数据写好之后，应用程序开始进行数据处理。</li>
</ol>
<p>对应抽象到java的socket代码简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//获取数据进行处理</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// socket、server，流关闭操作，省略不表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个过程和底层内核的网络IO很类似，主要体现在accept()等待从网络中的请求到来然后bytes[]数组作为缓冲区等待数据填满后进行处理。而BIO、NIO、AIO之间的区别就在于这些操作是同步还是异步，阻塞还是非阻塞。</p>
<p>所以我们引出同步异步，阻塞与非阻塞的概念。</p>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们的执行流程中：依次是方法一和方法二。</p>
<p>同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。</p>
<p>异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。</p>
<p>同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。</p>
<p>同步与异步是从多个线程之间的协调来实现效率差异。</p>
<blockquote>
<p>为什么需要异步呢？笔者认为异步的本质就是为了解决主线程的阻塞，所以网上很多讨论把同步异步、阻塞非阻塞进行了四种组合，其中一种就有异步阻塞这一情形，如果异步也是阻塞的？那为什么要特地进行异步操作呢？</p>
</blockquote>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p>
<p>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</p>
<p>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。</p>
<p>阻塞与非阻塞关注的是线程是否在原地等待。</p>
<blockquote>
<p>笔者认为阻塞和非阻塞仅能与同步进行组合。而异步天然就是非阻塞的，而这个非阻塞是对主线程而言。（可能有人认为异步方法里面放入阻塞操作的话就是异步阻塞，但是思考一下，正是因为是阻塞操作所以才会将它放入异步方法中，不要阻塞主线程）</p>
</blockquote>
<h4 id="例子讲解"><a href="#例子讲解" class="headerlink" title="例子讲解"></a>例子讲解</h4><blockquote>
<p>海底捞很好吃，但是经常要排队。我们就以生活中的这个例子进行讲解。</p>
</blockquote>
<ul>
<li>A顾客去吃海底捞，就这样干坐着等了一小时，然后才开始吃火锅。(BIO)</li>
<li>B顾客去吃海底捞，他一看要等挺久，于是去逛商场，每次逛一会就跑回来看有没有排到他。于是他最后既购了物，又吃上海底捞了。（NIO）</li>
<li>C顾客去吃海底捞，由于他是高级会员，所以店长说，你去商场随便玩吧，等下有位置，我立马打电话给你。于是C顾客不用干坐着等，也不用每过一会儿就跑回来看有没有等到，最后也吃上了海底捞（AIO）</li>
</ul>
<blockquote>
<p>哪种方式更有效率呢？是不是一目了然呢？</p>
</blockquote>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。线程发起io请求后，立即返回（非阻塞io）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。</p>
<p>NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。服务端不断轮询channel来获取客户端的信息。channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO是真正意义上的异步非阻塞IO模型。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。</p>
<p>AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。</p>
<h3 id="47-死锁的产生、防止、避免、检测和解除"><a href="#47-死锁的产生、防止、避免、检测和解除" class="headerlink" title="47.死锁的产生、防止、避免、检测和解除"></a><a href="">47.死锁的产生、防止、避免、检测和解除</a></h3><p><a href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<h3 id="48-线程安全有哪些实现思路"><a href="#48-线程安全有哪些实现思路" class="headerlink" title=" 48.  线程安全有哪些实现思路?"></a><a href=""> 48.  线程安全有哪些实现思路?</a></h3><ol>
<li><strong>互斥同步</strong></li>
</ol>
<p>synchronized 和 ReentrantLock。</p>
<ol>
<li><strong>非阻塞同步</strong></li>
</ol>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<ul>
<li><code>CAS</code></li>
</ul>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，<code>CAS</code>)。<code>CAS</code> 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<ul>
<li><code>AtomicInteger</code></li>
</ul>
<p><code>J.U.C</code> 包里面的整数原子类 <code>AtomicInteger</code>，其中的 <code>compareAndSet()</code> 和 <code>getAndIncrement()</code> 等方法都使用了 Unsafe 类的 <code>CAS</code> 操作。</p>
<ol>
<li><strong>无同步方案</strong></li>
</ol>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<ul>
<li>栈封闭</li>
</ul>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<ul>
<li>线程本地存储(Thread Local Storage)</li>
</ul>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK动态代理和Cglib动态代理</title>
    <url>/posts/spring_aop.html</url>
    <content><![CDATA[<p><strong>代理模式</strong>是一种设计模式，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了。只需要在代理类上增加就可以了。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/2244490621-6140109245c01_fix732.png" alt="2244490621-6140109245c01_fix732"></p>
<p>在Java中，代理又分静态代理和动态代理2种，其中动态代理根据不同实现又区分基于接口的的动态代理和基于子类的动态代理。</p>
<p>代理类完成的功能：</p>
<ul>
<li>调用目标方法，执行目标方法的功能。</li>
<li>功能增强，在目标方法调用时，增加功能。</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>所谓静态代理，就是通过<strong>声明一个明确的代理类</strong>来访问源对象。</p>
<p>我们有2个接口，Person和Animal。每个接口各有2个实现类，UML如下图：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/43042188-6140109a1cbc8.png" alt="43042188-6140109a1cbc8"></p>
<p>每个实现类中代码都差不多一致，用Student来举例（其他类和这个几乎一模一样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span> + name + <span class="string">&quot;早晨醒来啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span> + name + <span class="string">&quot;晚上睡觉啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们现在要做一件事，就是在所有的实现类调用<code>wakeup()</code>前增加一行输出<code>早安~</code>，调用<code>sleep()</code>前增加一行输出<code>晚安~</code>。那我们只需要编写2个代理类<code>PersonProxy</code>和<code>AnimalProxy</code>：</p>
<p><strong>PersonProxy:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早安~&quot;</span>);</span><br><span class="line">        person.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚安~&quot;</span>);</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AnimalProxy:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalProxy</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnimalProxy</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早安~&quot;</span>);</span><br><span class="line">        animal.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚安~&quot;</span>);</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终执行代码为：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="type">PersonProxy</span> <span class="variable">studentProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(student);</span><br><span class="line">    studentProxy.wakeup();</span><br><span class="line">    studentProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">doctor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>);</span><br><span class="line">    <span class="type">PersonProxy</span> <span class="variable">doctorProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(doctor);</span><br><span class="line">    doctorProxy.wakeup();</span><br><span class="line">    doctorProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">    <span class="type">AnimalProxy</span> <span class="variable">dogProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalProxy</span>(dog);</span><br><span class="line">    dogProxy.wakeup();</span><br><span class="line">    dogProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>);</span><br><span class="line">    <span class="type">AnimalProxy</span> <span class="variable">catProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalProxy</span>(cat);</span><br><span class="line">    catProxy.wakeup();</span><br><span class="line">    catProxy.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">早安~</span><br><span class="line">学生[张三]早晨醒来啦</span><br><span class="line">晚安~</span><br><span class="line">学生[张三]晚上睡觉啦</span><br><span class="line">早安~</span><br><span class="line">医生[王教授]早晨醒来啦</span><br><span class="line">晚安~</span><br><span class="line">医生[王教授]晚上睡觉啦</span><br><span class="line">早安~~</span><br><span class="line">小狗[旺旺]早晨醒来啦</span><br><span class="line">晚安~~</span><br><span class="line">小狗[旺旺]晚上睡觉啦</span><br><span class="line">早安~~</span><br><span class="line">小猫[咪咪]早晨醒来啦</span><br><span class="line">晚安~~</span><br><span class="line">小猫[咪咪]晚上睡觉啦</span><br></pre></td></tr></table></figure>
<p>这里用了2个代理类，分别代理了<code>Person</code>和<code>Animal</code>接口。</p>
<p>这种模式虽然好理解，但是缺点也很明显：</p>
<ul>
<li>会存在大量的冗余的代理类，这里演示了2个接口，如果有10个接口，就必须定义10个代理类。</li>
<li>不易维护，一旦接口更改，代理类和目标类都需要更改。</li>
<li>若类方法数量越来越多的时候，代理类的代码量十分庞大的。</li>
</ul>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>在程序的执行过程中，使用JDK的反射机制，创建代理类对象，并动态地指定要代理的目标类。</p>
<p>JDK动态代理的实现主要依靠三个类：InvocationHandler，Method，Proxy。</p>
<ul>
<li><strong>InvocationHandler（调用处理器）接口</strong>：里面只有一个Invoke() 方法，该方法表示代理对象要执行的功能代码。代理类要完成的功能就写在invoke() 方法中。方法原型如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Object proxy</code> 表示JDK创建的代理对象，无需赋值。<code>Method method</code> 表示目标类中的方法，JDK提供method对象。<code>Object[] args</code> 表示目标类中方法的参数，JDK提供的。</p>
<p>InvocationHandler接口：表示你的代理要干什么。</p>
<p><strong>用法：</strong>1.创建类实现<code>InvocationHandler</code>接口 2.重写i<code>nvoke()</code> 方法，把原来静态代理类要完成的功能，写在这里。</p>
<ul>
<li><strong>Method类</strong>： 表示方法，确切的说是目标类中的方法。</li>
</ul>
<p>作用：通过Method可以执行某个目标类的方法，<code>Method.invoke();</code> </p>
<p><code>method.invoke(目标对象，方法的参数);</code></p>
<ul>
<li><strong>Proxy类</strong>：核心的对象，用来创建代理对象。之前的静态代理中都是new类的构造方法，现在我们是使用Proxy类的方法，代替new的使 用。</li>
</ul>
<p>方法：静态方法<code>newProxyInstance()</code>;</p>
<p>作用：创建代理对象，等同于静态代理中的用new创建代理对象。</p>
<p>方法原型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>ClassLoader loader</code> 表示类加载器，负责向内存中加载对象，可以使用反射获取对象的ClassLoader。例如类a, <code>a.getClass().getClassLoader()</code>, 这里表示目标对象的类加载器。</p>
<p><code>Class&lt;?&gt;[] interfaces</code> : 接口，目标对象实现的接口，也是反射获取的。</p>
<p><code>InvocationHandler h</code> ： 我们自己写的，代理类要完成的功能。</p>
<p>返回值<code>Object</code> ： 就是生成的代理对象。</p>
<p>还是前面那个例子，用JDK动态代理类去实现的代码如下：</p>
<p><strong>创建一个JdkProxy类，用于统一代理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(bean, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JdkProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="comment">// student是代理对象，是com.sun.proxy.$Proxy类型的</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">    <span class="comment">// 通过代理对象执行方法调用，执行handler，student.wakeup(),此时执行的是proxy对象中的invoke()方法</span></span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">doctor</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;, proxy);</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;, proxy);</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，相对于静态代理类来说，无论有多少接口，这里只需要一个代理类。核心代码也很简单。唯一需要注意的点有以下2点：</p>
<ul>
<li>JDK动态代理是需要声明接口的，创建一个动态代理类必须得给这个”虚拟“的类一个接口。可以看到，这时候经动态代理类创造之后的每个bean已经不是原来那个对象了。</li>
</ul>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/2796530636-614010da5d63f_fix732.png" alt="2796530636-614010da5d63f_fix732"></p>
<ul>
<li>为什么这里<code>JdkProxy</code>还需要构造传入原有的bean呢？因为处理完附加的功能外，需要执行原有bean的方法，以完成<code>代理</code>的职责。</li>
</ul>
<p>这里<code>JdkProxy</code>最核心的方法就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>
<p>其中proxy为代理过之后的对象(并不是目标对象)，method为被代理的方法，args为方法的参数。</p>
<p>如果你不传原有的bean，直接用<code>method.invoke(proxy, args)</code>的话，那么就会陷入一个死循环。</p>
<h3 id="可以代理什么？"><a href="#可以代理什么？" class="headerlink" title="可以代理什么？"></a>可以代理什么？</h3><p>JDK的动态代理是也平时大家使用的最多的一种代理方式。也叫做接口代理。</p>
<p>JDK动态代理说白了只是根据接口”凭空“来生成类，至于具体的执行，都被代理到了<code>InvocationHandler</code> 的实现类里。上述例子我是需要继续执行原有bean的逻辑，才将原有的bean构造进来。只要你需要，你可以构造进任何对象到这个代理实现类。也就是说，你可以传入多个对象，或者说你什么类都不代理。只是为某一个接口”凭空“的生成多个代理实例，这多个代理实例最终都会进入<code>InvocationHandler</code>的实现类来执行某一个段共同的代码。</p>
<p>所以，在以往的项目中的一个实际场景就是，我有多个以y aml定义的规则文件，通过对yaml文件的扫描，来为每个yaml规则文件生成一个动态代理类。而实现这个，我只需要事先定义一个接口，和定义<code>InvocationHandler</code>的实现类就可以了，同时把yaml解析过的对象传入。最终这些动态代理类都会进入<code>invoke</code>方法来执行某个共同的逻辑。</p>
<h3 id="代理对象由谁产生？"><a href="#代理对象由谁产生？" class="headerlink" title="代理对象由谁产生？"></a>代理对象由谁产生？</h3><p>JVM，不像静态代理，我们得自己new个代理对象。</p>
<h3 id="代理对象实现了什么接口？"><a href="#代理对象实现了什么接口？" class="headerlink" title="代理对象实现了什么接口？"></a>代理对象实现了什么接口？</h3><p>实现的接口是目标对象实现的接口。 同静态代理中代理对象实现的接口。那个继承关系图还是相同的。 代理对象和目标对象都实现一个共同的接口。就是这个接口。 所以Proxy.newProxyInstance()方法返回的类型就是这个接口类型。</p>
<h3 id="代理对象的方法体是什么？"><a href="#代理对象的方法体是什么？" class="headerlink" title="代理对象的方法体是什么？"></a>代理对象的方法体是什么？</h3><p>代理对象的方法体中的内容就是拦截器中invoke方法中的内容。</p>
<p>所有代理对象的处理逻辑，控制是否执行目标对象的目标方法。都是在这个方法里面处理的。</p>
<h3 id="拦截器中的invoke方法中的method参数是在什么时候赋值的"><a href="#拦截器中的invoke方法中的method参数是在什么时候赋值的" class="headerlink" title="拦截器中的invoke方法中的method参数是在什么时候赋值的?"></a>拦截器中的invoke方法中的method参数是在什么时候赋值的?</h3><p>在客户端，代理对象调用目标方法的时候，此实例中为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.wakeup();</span><br></pre></td></tr></table></figure>
<p>实际上进入的是拦截器中的invoke方法，这时拦截器中的invoke方法中的method参数会被赋值。</p>
<h3 id="为什么叫JDK动态代理？"><a href="#为什么叫JDK动态代理？" class="headerlink" title="为什么叫JDK动态代理？"></a>为什么叫JDK动态代理？</h3><h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><p>CGLIB(Code Generation Library) 是一个开源项目。是一个强大的、高性能、高质量的Code生成类库，它可以在运行期拓展Java类与实现Java接口。它广泛地被许多AOP框架使用，例如Spring AOP。</p>
<p>使用JDK的Proxy实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。</p>
<p>但对于无接口的类，要为期创建动态代理，就要使用CGLIB来实现。CGLIB代理的生成原理是生成目标类的子类，通过子类对目标类的增强。这个子类就是代理对象。所以，使用CGLIB生成动态代理，要求目标类必须能被继承，即不能是final修饰的类。</p>
<p>CGLIB经常被应用在框架中，例如Spring,Hibernate等。Cglib的代理效率高于JDK。对于Cglib一般的开发中并不使用。</p>
<p>Spring在5.X之前默认的动态代理实现一直是jdk动态代理。但是从5.X开始，spring就开始默认使用Cglib来作为动态代理实现。并且springboot从2.X开始也转向了Cglib动态代理实现。</p>
<p>是什么导致了spring体系整体转投Cglib呢，jdk动态代理又有什么缺点呢？</p>
<p>那么我们现在就要来说下Cglib的动态代理。</p>
<p>Cglib是一个开源项目，它的底层是字节码处理框架ASM，Cglib提供了比jdk更为强大的动态代理。主要相比jdk动态代理的优势有：</p>
<ul>
<li>jdk动态代理只能基于接口，代理生成的对象只能赋值给接口变量，而Cglib就不存在这个问题，Cglib是通过生成子类来实现的，代理对象既可以赋值给实现类，又可以赋值给接口。</li>
<li>Cglib速度比jdk动态代理更快，性能更好。</li>
</ul>
<p>那何谓通过子类来实现呢？</p>
<p>还是前面那个例子，我们要实现相同的效果。代码如下</p>
<p><strong>创建CglibProxy类，用于统一代理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置需要创建子类的类</span></span><br><span class="line">        enhancer.setSuperclass(bean.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现MethodInterceptor接口方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用原bean的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(bean,args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) proxy.getProxy();</span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Doctor</span> <span class="variable">doctor</span> <span class="operator">=</span> (Doctor) proxy.getProxy();</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) proxy.getProxy();</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) proxy.getProxy();</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里用Cglib作为代理，其思路和jdk动态代理差不多。也需要把原始bean构造传入。</p>
<p>关键的代码在这里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置需要创建子类的类</span></span><br><span class="line">enhancer.setSuperclass(bean.getClass());</span><br><span class="line">enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line"><span class="keyword">return</span> enhancer.create();</span><br></pre></td></tr></table></figure>
<p>可以看到，Cglib”凭空”的创造了一个原bean的子类，并把Callback指向了this，也就是当前对象，也就是这个proxy对象。从而会调用<code>intercept</code>方法。而在<code>intercept</code>方法里，进行了附加功能的执行，最后还是调用了原始bean的相应方法。</p>
<p>在debug这个生成的代理对象时，我们也能看到，Cglib是凭空生成了原始bean的子类：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1853665691-614010e6b05ac_fix732.png" alt="1853665691-614010e6b05ac_fix732"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC中的数据结构</title>
    <url>/posts/ds_btc.html</url>
    <content><![CDATA[<h3 id="Hash-Pointer"><a href="#Hash-Pointer" class="headerlink" title="Hash Pointer"></a>Hash Pointer</h3><p>在程序运行过程中，需要用到数据。最简单的是直接获取数据，但当数据本身较大，需要占用较大空间时，明显会造成一定麻烦。因此，可以引入指针这一概念。当需要获取数据时，只需要按照指针所给的地址，去对应的位置读取数据即可，这样大大节省了内存空间。在实际中，为了便于程序移植性等原因，指针实际上存储的是逻辑地址而非物理地址。<br>区块链结构本身为一条链表，节点为区块。而传统链表实现，便是通过指针将各个节点串联起来而称为最终的链。如下便是我们最常见的一个链表：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20200214173054674.png" alt="在这里插入图片描述"></p>
<p>但在区块链系统中，并未采用指针，而是使用了<strong>哈希指针</strong>。<br>如下图对于该节点，我们可以看到有两个指针指向这个节点（实际上为一个），其中P为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20200214173157391.png" alt="在这里插入图片描述"></p>
<p>在比特币中，其最基本的数据结构便是一个个区块形成的区块链。</p>
<p><strong>区块链与链表区别：</strong>哈希指针代替普通指针<br>如图为一个简单的区块链。其中，每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。需要注意的是，本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。<br>如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。<br>在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20200214173245117.png" alt="在这里插入图片描述"></p>
<h3 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h3><p>Merkle Tree可以用于提供Merkle Proof。比特币中节点分为<strong>轻节点</strong>和<strong>全节点</strong>。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。</p>
<blockquote>
<p>为什么要分轻节点和全节点？<br>因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容即可。</p>
</blockquote>
<p>当需要向轻节点证明某条交易是否被写入区块链，便需要用到Merkle proof。我们将交易到根节点这一条路径称为Merkle proof，全节点将整个Merkle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221125150306565.png" alt="image-20221125150306565"></p>
<p>以上图为例，要验证黄色的交易是否被写到区块中，我们首先要请求第三层的红色的哈希值，然后根据黄色的交易求出第三层的绿色哈希值，然后通过这两个已知的哈希值求出第二层的绿色哈希值，再请求第二层的红色哈希值，以此类推最终求得根哈希值，然后与存储在自身结点中的根哈希值比较，若相同则证明交易已经写入到了区块中。</p>
<p>上面的验证是proof of membership 时间复杂度为O(logn)<br>关于proof of non-membership验证，如果交易是无序的，我们只能证明每个结点都是对的，说明没有该节点，时间复杂度为O(n)<br>如果交易是按hash值从小到大排序，我们对要检验的交易取hash，判断它应处的位置，然后计算他前后的两个结点的hash，若这两个结点确实相邻（merkle proof），则证明我们要找的结点不存在（若存在则会在这两个结点之间，这两个结点不会相邻），时间复杂度为O(logn)。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中 DecimalFormat 用法详解</title>
    <url>/posts/43254.html</url>
    <content><![CDATA[<h3 id="对Java中-DecimalFormat-的所有基础用法进行了一个汇总。"><a href="#对Java中-DecimalFormat-的所有基础用法进行了一个汇总。" class="headerlink" title="对Java中 DecimalFormat 的所有基础用法进行了一个汇总。"></a>对Java中 DecimalFormat 的所有基础用法进行了一个汇总。</h3><span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumberFormat</span>&#123; </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">　　　　<span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">　　　　<span class="comment">//取一位整数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">　　　　<span class="comment">//取一位整数和两位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">　　　　<span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">　　　　<span class="comment">//取所有整数部分</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">　　　　<span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line">　　 　 <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">　　　　<span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));　<span class="comment">//2.99792E8</span></span><br><span class="line">　　　　<span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));　<span class="comment">//29.9792E7</span></span><br><span class="line">　　　　<span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));　　　<span class="comment">//299,792,458</span></span><br><span class="line">　　　　<span class="comment">//将格式嵌入文本</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line">  </span><br><span class="line">　　&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecimalFormat 类主要靠 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。上面的例子包含了差不多所有的基本用法</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解开发Servlet</title>
    <url>/posts/11551.html</url>
    <content><![CDATA[<p>关于Java自动注解开发Servlet</p>
<span id="more"></span>
<h1 id="自动注解配置"><a href="#自动注解配置" class="headerlink" title="自动注解配置"></a>自动注解配置</h1><p>自动注解开发的实现步骤：</p>
<ol>
<li>创建一个web项目</li>
<li>定义一个类，继承HttpServlet</li>
<li>重写一个doGet和doPost方法</li>
<li>在类上使用<code>@WebServlet</code>注解配置Servlet</li>
<li>部署并启动项目</li>
<li>通过浏览器进行测试</li>
</ol>
<h2 id="1-配置步骤"><a href="#1-配置步骤" class="headerlink" title="1 配置步骤"></a>1 配置步骤</h2><h4 id="第一步：创建JavaWeb工程，并移除web-xml"><a href="#第一步：创建JavaWeb工程，并移除web-xml" class="headerlink" title="第一步：创建JavaWeb工程，并移除web.xml"></a>第一步：创建JavaWeb工程，并移除web.xml</h4><p><img src="https://img.imgdb.cn/item/605c192d8322e6675c76ce08.jpg" alt=""></p>
<p><img src="https://img.imgdb.cn/item/605c1a2d8322e6675c773eda.jpg" alt=""></p>
<p>项目创建完成后在web目录没有web.xml文件，只有一个index.jsp文件，可以将index.jsp文件删除。但是在web目录下我们仍然需要WEB-INF文件夹，因为里面不止web.xml这一个配置文件，还会有第三方的依赖包，所以我们要在web目录下手动创建WEB-INF，大小写一致。</p>
<p><img src="https://img.imgdb.cn/item/605c1b6f8322e6675c77d9e3.jpg" alt=""></p>
<h4 id="第二步：编写Servlet，配置注解"><a href="#第二步：编写Servlet，配置注解" class="headerlink" title="第二步：编写Servlet，配置注解"></a>第二步：编写Servlet，配置注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cstube.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基于注解方式开发Servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span> (<span class="string">&quot;/servletDemo01&quot;</span>)  <span class="comment">//配置注解的映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletDemo01执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第三步：测试"><a href="#第三步：测试" class="headerlink" title="第三步：测试"></a>第三步：测试</h4><p>浏览器地址栏输入<code>http://localhost:8080/demo3/servletDemo01</code>,有下面结果：</p>
<p><img src="https://img.imgdb.cn/item/605c1e9d8322e6675c79703f.jpg" alt=""></p>
<h2 id="2-自动注解开发的注解详解"><a href="#2-自动注解开发的注解详解" class="headerlink" title="2 自动注解开发的注解详解"></a>2 自动注解开发的注解详解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebServlet注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定Servlet的名称。</span></span><br><span class="line"><span class="comment">     * 相当于xml配置中&lt;servlet&gt;标签下的&lt;servlet-name&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于映射Servlet访问的url映射</span></span><br><span class="line"><span class="comment">     * 相当于xml配置时的&lt;url-pattern&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相当于xml配置时的&lt;url-pattern&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于配置Servlet的启动时机</span></span><br><span class="line"><span class="comment">     * 相当于xml配置的&lt;load-on-startup&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于配置Servlet的初始化参数</span></span><br><span class="line"><span class="comment">     * 相当于xml配置的&lt;init-param&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于配置Servlet是否支持异步</span></span><br><span class="line"><span class="comment">     * 相当于xml配置的&lt;async-supported&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的小图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的大图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的描述信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的显示名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合面试题</title>
    <url>/posts/java-collection.html</url>
    <content><![CDATA[<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/java-collection-hierarchy.71519bdb.png" alt=""></p>
<h3 id="2-ArrayList和Vector的区别"><a href="#2-ArrayList和Vector的区别" class="headerlink" title="2.ArrayList和Vector的区别"></a><a href="">2.ArrayList和Vector的区别</a></h3><p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList与Vector的区别，这主要包括两个方面：</p>
<p>（1）同步性：</p>
<p>Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
<p>（2）数据增长：</p>
<p>ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。</p>
<p>总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</p>
<h3 id="3-HashMap和Hashtable的区别"><a href="#3-HashMap和Hashtable的区别" class="headerlink" title="3.HashMap和Hashtable的区别"></a><a href="">3.HashMap和Hashtable的区别</a></h3><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
<p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
<p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
<p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小.</p>
<p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
<h3 id="4-List-和-Map-区别"><a href="#4-List-和-Map-区别" class="headerlink" title="4.List 和 Map 区别?"></a><a href="">4.List 和 Map 区别?</a></h3><p>一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</p>
<h3 id="6-List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#6-List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="6.List、Map、Set三个接口，存取元素时，各有什么特点？"></a><a href="">6.List、Map、Set三个接口，存取元素时，各有什么特点？</a></h3><p>首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。</p>
<p>List表示有先后顺序的集合。当我们多次调用add(Obj e)方法时，每次加入的对象按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。</p>
<p>Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获得key和value组合成的Map.Entry对象的集合。</p>
<h3 id="7-说出ArrayList-Vector-LinkedList的存储性能和特性"><a href="#7-说出ArrayList-Vector-LinkedList的存储性能和特性" class="headerlink" title="7.说出ArrayList,Vector, LinkedList的存储性能和特性"></a><a href="">7.说出ArrayList,Vector, LinkedList的存储性能和特性</a></h3><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。</p>
<h3 id="9-Collection-和-Collections的区别。"><a href="#9-Collection-和-Collections的区别。" class="headerlink" title="9.Collection 和 Collections的区别。"></a><a href="">9.Collection 和 Collections的区别。</a></h3><p>Collection是集合类的上级接口，继承他的接口主要有Set 和List和Queue。</p>
<p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="10-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#10-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="10.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?"></a><a href="">10.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</a></h3><p>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</p>
<p>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h3 id="11-你所知道的集合类都有哪些？主要方法？"><a href="#11-你所知道的集合类都有哪些？主要方法？" class="headerlink" title="11.你所知道的集合类都有哪些？主要方法？"></a><a href="">11.你所知道的集合类都有哪些？主要方法？</a></h3><p>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。</p>
<p>Map 集合类用于存储键值对，其中每个键映射到一个值。</p>
<p>记的不是方法名，而是思想，知道它们都有增删改查的方法，记住的一些思想就是List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。</p>
<h3 id="12-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#12-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="12.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?"></a><a href="">12.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?</a></h3><p>对。</p>
<p>如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。</p>
<p>如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。</p>
<h3 id="13-TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！"><a href="#13-TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！" class="headerlink" title="13.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！"></a><a href="">13.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！</a></h3><p>当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的。</p>
<h3 id="14-HashMap中的Hash方法为什么要右移16位异或？（美团）（滴滴）"><a href="#14-HashMap中的Hash方法为什么要右移16位异或？（美团）（滴滴）" class="headerlink" title="14.HashMap中的Hash方法为什么要右移16位异或？（美团）（滴滴）"></a><a href="">14.HashMap中的Hash方法为什么要右移16位异或？（美团）（滴滴）</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">  <span class="comment">// ^ ：按位异或	 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐	  return (key == null) ? 0 : (h = 		key.hashCode()) ^ (h &gt;&gt;&gt; 16);	</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p> HashMap 将key通过hash方法处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>首先这个方法的返回值还是一个哈希值。为什么不直接返回<code>key.hashCode()</code>呢？还要与 (h &gt;&gt;&gt; 16)异或。</p>
<p>先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h = key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1111</span><br><span class="line">^</span><br><span class="line">h &gt;&gt;&gt; 16           0000 0000 0000 0000 1111 1101 1101 1111</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">h ^ (h &gt;&gt;&gt; 16)     1111 1101 1101 1111 1010 0000 1111 0000</span><br><span class="line">h = key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1111  </span><br></pre></td></tr></table></figure>
<p>对比<code>h = key.hashcode()</code> 与 <code>h ^ (h &gt;&gt;&gt; 16)</code> 发现，将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原<code>hashcode</code>做异或运算，<strong>可以将高低位二进制特征混合起来</strong>。例子中可以看出高区的16位并没有变化。低区的16位发 生了较大的变化。这样做的目的是什么呢？</p>
<p>我们计算出的hash值在后面会参与到元素index的计算中。计算公式为 hash &amp; (length - 1)。</p>
<p>仔细观察上文不难发现，高区的16位很有可能会被数组长度的二进制码所屏蔽，<strong>如果我们不做刚才移位异或运算，那么在计算index时将丢失高区特征。如果</strong>没有上面这个异或操作，假设里两个hash值只有高位一点点的差异，然后在计算index过程中还丢失了高位的信息，那么就计算出同一个index。</p>
<h3 id="15-HashMap中的hash方法使用异或运算的原因？（美团）"><a href="#15-HashMap中的hash方法使用异或运算的原因？（美团）" class="headerlink" title="15.HashMap中的hash方法使用异或运算的原因？（美团）"></a><a href="">15.HashMap中的hash方法使用异或运算的原因？（美团）</a></h3><p><strong>异或运算能更平均的保留各部分的特征</strong>，如果采用<strong>&amp;</strong>运算计算出来的值会向1靠拢，采用<strong>|</strong>运算计算出来的值会向0靠拢</p>
<h3 id="16-为什么HashMap的数组长度必须使用2-n？（美团）"><a href="#16-为什么HashMap的数组长度必须使用2-n？（美团）" class="headerlink" title="16.为什么HashMap的数组长度必须使用2^n？（美团）"></a><a href="">16.为什么HashMap的数组长度必须使用2^n？（美团）</a></h3><p>首先我们计算key的hash值之后还要先做对数组的长度取模运算，得到的余数才能用来作为存放的位置也就是对应的数组下标。这个数组下标的计算方法是<code>(n - 1) &amp; hash</code>。<strong>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</strong>，<strong>也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；</strong>并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率</strong>。</p>
<p>其次是为了让计算得到的元素索引更加均匀，如果 length = 17 那么 hash &amp; (17 - 1) 。16转化为二进制包含更多的0，这样一来计算会被更多的0屏蔽。</p>
<p>最后是为了便于扩容后的重新计算元素index。</p>
<h3 id="17-为什么HashMap扩容时总是把capacity扩大为原来的2倍？"><a href="#17-为什么HashMap扩容时总是把capacity扩大为原来的2倍？" class="headerlink" title="17.为什么HashMap扩容时总是把capacity扩大为原来的2倍？"></a><a href="">17.为什么HashMap扩容时总是把capacity扩大为原来的2倍？</a></h3><p>由于我们要维护hashmap的大小为2^n，这样就使得len-1的二进制中全部都是1。进行位运算时可以降低hash碰撞的出现。</p>
<h3 id="18-HashMap的负载因子为什么是0-75？（美团）"><a href="#18-HashMap的负载因子为什么是0-75？（美团）" class="headerlink" title="18.HashMap的负载因子为什么是0.75？（美团）"></a><a href="">18.HashMap的负载因子为什么是0.75？（美团）</a></h3><p>负载因子主要与扩容有关，如果将负载因子设置为1，空间利用的就更加充分了，但是这样一来<strong>会增大hash碰撞</strong>的出现，有些位置的链表会过长，不利于查找。如果设置的过小的话虽然降低了hash碰撞的发生，但是会频繁触发扩容机制，也会导致数组的利用率较低。</p>
<p>所以为了折中，将负载因子设置为0.75是对空间与时间的取舍。</p>
<h3 id="19-HashMap的线程安全问题？（滴滴）"><a href="#19-HashMap的线程安全问题？（滴滴）" class="headerlink" title="19.HashMap的线程安全问题？（滴滴）"></a><a href="">19.HashMap的线程安全问题？（滴滴）</a></h3><p>1.多线程的put操作可能导致元素丢失</p>
<p>2.put和get并发时可能导致get为null</p>
<ul>
<li>线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。</li>
</ul>
<p>3.jdk 1.7 中并发put导致的循环链表导致get出现死循环</p>
<ul>
<li>发生在多线程并发resize的情况下可能会导致环形链表的出现。</li>
</ul>
<h3 id="21-解决hash冲突的方法？（美团）"><a href="#21-解决hash冲突的方法？（美团）" class="headerlink" title="21.解决hash冲突的方法？（美团）"></a><a href="">21.解决hash冲突的方法？（美团）</a></h3><p><strong>1.拉链法（链地址）：</strong></p>
<p><strong>2.线性探测法：</strong>冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p><strong>3.二次探测法：</strong>冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<h3 id="22-说说-List-Set-Queue-Map-四者的区别？"><a href="#22-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="22.说说 List, Set, Queue, Map 四者的区别？"></a><a href="">22.说说 List, Set, Queue, Map 四者的区别？</a></h3><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p>
<p><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</p>
<p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
<p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
<h3 id="23-Arraylist-与-LinkedList-区别"><a href="#23-Arraylist-与-LinkedList-区别" class="headerlink" title="23. Arraylist 与 LinkedList 区别?"></a><a href="">23. Arraylist 与 LinkedList 区别?</a></h3><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="24-无序性和不可重复性的含义是什么"><a href="#24-无序性和不可重复性的含义是什么" class="headerlink" title="24.无序性和不可重复性的含义是什么"></a><a href="">24.无序性和不可重复性的含义是什么</a></h3><p>什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="25-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#25-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="25.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a><a href="">25.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></h3><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p>
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
<h3 id="26-ArrayDeque-与-LinkedList-的区别"><a href="#26-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="26.ArrayDeque 与 LinkedList 的区别"></a><a href="">26.ArrayDeque 与 LinkedList 的区别</a></h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="27-说一说-PriorityQueue"><a href="#27-说一说-PriorityQueue" class="headerlink" title="27.说一说 PriorityQueue"></a><a href="">27.说一说 PriorityQueue</a></h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<h3 id="28-HashSet-如何检查重复"><a href="#28-HashSet-如何检查重复" class="headerlink" title="28.HashSet 如何检查重复"></a><a href="">28.HashSet 如何检查重复</a></h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h3 id="29-ConcurrentHashMap-和-Hashtable-的区别"><a href="#29-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="29. ConcurrentHashMap 和 Hashtable 的区别"></a><a href="">29. ConcurrentHashMap 和 Hashtable 的区别</a></h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashTable的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。② </strong><code>Hashtable</code>(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h3 id="30-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#30-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="30.ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a><a href="">30.ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</a></h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg" alt=""></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。<code>HashEntry</code> 用于存储键值对数据。</p>
<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。 </p>
<h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220209165135940.png" alt="image-20220209165135940"></p>
<p>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的Node数组+链表+红黑树结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加细粒度的锁。</p>
<p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h3 id="31-Map有哪些常用的实现类及其作用？"><a href="#31-Map有哪些常用的实现类及其作用？" class="headerlink" title="31.Map有哪些常用的实现类及其作用？"></a><a href="">31.<strong>Map有哪些常用的实现类及其作用？</strong></a></h3><p><strong>HashMap:</strong>上面也说了，<strong>HashMap的底层实现是数组+链表+红黑树的形式的，</strong>同时它的<strong>数组的默认初始容量是16、扩容因子为0.75，每次采用2倍的扩容。</strong>也就是说，每当我们数组中的存储容量达到75%的时候，就需要对数组容量进行2倍的扩容。</p>
<p><strong>HashTable:</strong>HashTable接口是线程安全，但是很早之前有使用，现在几乎属于一个遗留类了，<strong>在开发中不建议使用。</strong></p>
<p><strong>ConcurrentHashMap:</strong>这是现阶段使用使用比较多的一种线程安全的Map实现类。<strong>在1.7以前使用的是分段锁机制实现的线程安全的。但是在1.8以后使用synchronized关键字实现的线程安全。</strong></p>
<h3 id="32-请阐述HashMap的put过程？"><a href="#32-请阐述HashMap的put过程？" class="headerlink" title="32.请阐述HashMap的put过程？"></a><a href="">32.<strong>请阐述HashMap的put过程？</strong></a></h3><p>在HashMap中使用的是数组+链表的实现方式，<strong>在HashMap的上层使用数组的形式对“相同”的key进行存储，下层对相应的key和value使用链表的形式进行链接和存储。</strong></p>
<p>HashMap将要存储的值按照key计算其对应的数组下标，如果对应的数组下标的位置上是没有元素的，那么就将存储的元素存放上去，但是如果该位置上已经存在元素了，那么这就需要用到我们上面所说的链表存储了，将数据按照链表的存储顺序依次向下存储就可以了。这就是put的简单过程，存储结果如下：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20210606155342841.jpg" alt=""></p>
<p>但是我们有时候存储的数据会很多，那么如果一直使用链表的形式进行数据的存储的话就或造成我们的链表的长度非常大，这样无论在进行删除还是在进行插入操作都是十分麻烦的，<strong>这里就涉及到了一个链表中数据存储时，进行“树化”和“链化”的一个过程</strong>。当我们在对键值对进行存储的时候，如果我们在同一个数组下标下存储的数据过多的话，就会造成我们的链表长度过长，导致进行删除和插入操作比较麻烦，所以在java中规定，<strong>当链表长度大于8时，我们会对链表进行“树化”操作，</strong>将其转换成一颗红黑树（一种二叉树，左边节点的值小于根节点，右边节点的值大于根节点），这样我们在对元素进行查找时，就类似于进行二分查找了，这样的查找效率就会大大增加。但是当我们进行删除操作，将其中的某些节点删除了之后，链表的长度不再大于8了，<strong>当链表的长度小于6的时候，我们会将红黑树重新转化为链表，这个过程就叫做“链化”。</strong></p>
<p><strong>那么为什么要在长度8的时候进行“树化”，而在长度小于6的时候才进行“链化”呢？为什么不直接在长度小于8的时候就进行“链化”？</strong></p>
<p><strong>主要原因是因为：</strong>当删除一个元素，链表长度小于8的时候直接进行“链化”，而再增加一个元素，长度又等于8的时候，又要进行“树化”，这样反复的进行“链化”和“树化”操作特别的消耗时间，而且也比较麻烦。所以程序就规定，只有当当链表长度大于等于8的时候才进行“树化”，而长度小于6的时候才进行“链化”，<strong>其中关于8树化、6链化这两个阈值希望大家牢记！</strong></p>
<h3 id="33-HashMap的链表中是按照怎样的顺序存放数据的？"><a href="#33-HashMap的链表中是按照怎样的顺序存放数据的？" class="headerlink" title="33.HashMap的链表中是按照怎样的顺序存放数据的？"></a><a href="">33.HashMap的<strong>链表中是按照怎样的顺序存放数据的？</strong></a></h3><p>在JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。</p>
<h3 id="34-HashMap是如何扩容的？"><a href="#34-HashMap是如何扩容的？" class="headerlink" title="34.HashMap是如何扩容的？"></a><a href="">34.<strong>HashMap是如何扩容的？</strong></a></h3><p>HashMap的数组的初始容量是16，但是很显然16个存储位是显然不够的，<strong>在这里需要用到一个参数叫“扩容因子”，在HashMap中“扩容因子”的大小是0.75，</strong> <strong>对于初始长度为16的数组，当其中存储的数据长度等于16*0.75=12时。就会对数组元素进行扩容，扩容量是原来数组容量的2倍。</strong></p>
<h3 id="35-HashMap扩容后元素怎么存放的？"><a href="#35-HashMap扩容后元素怎么存放的？" class="headerlink" title="35.HashMap扩容后元素怎么存放的？"></a><a href="">35.HashMap<strong>扩容后元素怎么存放的？</strong></a></h3><p>我们知道HashMap的数组在进行扩容之后，数组长度是增加的，那么这个时候，后面新扩容的部分就是空的。这样会造成内存的很大浪费。<strong>因此在HashMap的数组扩容之后，原先HashMap数组中存放的数据元素会进行重新的位置分配，重新将元素在新数组中进行存储。以充分利用数组空间。</strong></p>
<h3 id="36-JDK1-8-中ConCurrentHashMap为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？"><a href="#36-JDK1-8-中ConCurrentHashMap为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？" class="headerlink" title="36.JDK1.8 中ConCurrentHashMap为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？"></a><a href="">36.JDK1.8 中ConCurrentHashMap为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？</a></h3><p>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步升级。</p>
<p>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p>
<h3 id="37-ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#37-ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="37.ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a><a href="">37.ConcurrentHashMap 的 put 方法执行逻辑是什么？</a></h3><p>整体流程跟HashMap比较类似，大致是以下几步：</p>
<p>（1）如果桶数组未初始化，则初始化；</p>
<p>（2）如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</p>
<p>（3）如果正在扩容，则当前线程一起加入到扩容的过程中；</p>
<p>（4）如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）；</p>
<p>（5）如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</p>
<p>（6）如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</p>
<p>（7）如果元素存在，则返回旧值；</p>
<p>（8）如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容；</p>
<p>添加元素操作中使用的锁主要有（自旋锁 + CAS + synchronized + 分段锁）。</p>
<h3 id="38-数组和链表的区别-、使用场景"><a href="#38-数组和链表的区别-、使用场景" class="headerlink" title="38.数组和链表的区别 、使用场景"></a><a href="">38.数组和链表的区别 、使用场景</a></h3><p><strong>数组和链表的区别</strong><br><strong>数组</strong>是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效<br>率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大<br>小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现<br>越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低<br><strong>链表</strong>是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需<br>要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任<br>意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）<br><strong>链表和数组使用场景</strong><br>数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建<br>的线性表较稳定。<br>链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/posts/java-basic.html</url>
    <content><![CDATA[<h3 id="1-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#1-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="1.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a><a href="">1.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</a></h3><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p>
<h3 id="2-Java有没有goto"><a href="#2-Java有没有goto" class="headerlink" title="2.Java有没有goto?"></a><a href="">2.Java有没有goto?</a></h3><p>没有，但是 goto 是 java 中的保留字。</p>
<h3 id="3-说说-amp-和-amp-amp-的区别"><a href="#3-说说-amp-和-amp-amp-的区别" class="headerlink" title="3.说说&amp;和&amp;&amp;的区别"></a><a href="">3.说说&amp;和&amp;&amp;的区别</a></h3><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。</p>
<h3 id="4-在JAVA中如何跳出当前的多重嵌套循环？-华为"><a href="#4-在JAVA中如何跳出当前的多重嵌套循环？-华为" class="headerlink" title="4.在JAVA中如何跳出当前的多重嵌套循环？(华为)"></a><a href="">4.在JAVA中如何跳出当前的多重嵌套循环？(华为)</a></h3><p>让外层的循环条件表达式的结果可以受到内层循环体代码的控制，例如，要在二维数组中查找到某个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length &amp;&amp; !found; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] == <span class="number">5</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#5-switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a><a href="">5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</a></h3><p>在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。</p>
<p>switch 不支持 long 类型；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖,内部实现在 switch 中使用字符串的 hash code。</p>
<h3 id="6-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#6-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a><a href="">6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</a></h3><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。</p>
<p>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<h3 id="7-char型变量中能不能存贮一个中文汉字-为什么"><a href="#7-char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="7.char型变量中能不能存贮一个中文汉字?为什么?"></a><a href="">7.char型变量中能不能存贮一个中文汉字?为什么?</a></h3><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h3 id="8-用最有效率的方法算出2乘以8等于几"><a href="#8-用最有效率的方法算出2乘以8等于几" class="headerlink" title="8.用最有效率的方法算出2乘以8等于几?"></a><a href="">8.用最有效率的方法算出2乘以8等于几?</a></h3><p>2 &lt;&lt; 3。因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算是cpu直接支持的，效率最高，所以，2乘以8等于几的最高效的方法是2 &lt;&lt; 3。</p>
<h3 id="10-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#10-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a><a href="">10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</a></h3><p><strong>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。</strong>例如，对于如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuffer a=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;immutable&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>执行如下语句将报告编译期错误：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><br>但是，执行如下语句则可以通过编译：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.append(<span class="string">&quot; broken!&quot;</span>);</span><br></pre></td></tr></table></figure><br>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="keyword">final</span> StringBuffer param)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">param.append(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="11-”-”和equals方法究竟有什么区别？"><a href="#11-”-”和equals方法究竟有什么区别？" class="headerlink" title="11.”==”和equals方法究竟有什么区别？"></a><a href="">11.”==”和equals方法究竟有什么区别？</a></h3><p><code>==</code>对于基本数据类型和引用数据类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p>因为 Java 只有值传递，所以，对于 <code>==</code> 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>==o;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals()</code>方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的内容是否相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<h3 id="12-静态变量和成员变量的区别？"><a href="#12-静态变量和成员变量的区别？" class="headerlink" title="12.静态变量和成员变量的区别？"></a><a href="">12.静态变量和成员变量的区别？</a></h3><p>在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</p>
<p>在程序运行时的区别：成员变量是属于某个对象的属性，必须创建了实例对象，其中的成员变量才会被分配空间，才能使用这个成员变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，成员变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<h3 id="13-是否可以从一个static方法内部发出对非static方法的调用？"><a href="#13-是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="13.是否可以从一个static方法内部发出对非static方法的调用？"></a><a href="">13.是否可以从一个static方法内部发出对非static方法的调用？</a></h3><p>不可以。</p>
<p>因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不可以发出对非static方法的调用。</p>
<h3 id="14-Integer与int的区别"><a href="#14-Integer与int的区别" class="headerlink" title="14.Integer与int的区别"></a><a href="">14.Integer与int的区别</a></h3><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<h3 id="15-Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#15-Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="15.Math.round(11.5)等于多少? Math.round(-11.5)等于多少?"></a><a href="">15.Math.round(11.5)等于多少? Math.round(-11.5)等于多少?</a></h3><p>Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；<strong>最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</strong></p>
<h3 id="16-请说出作用域public，private，protected，以及不写时的区别。"><a href="#16-请说出作用域public，private，protected，以及不写时的区别。" class="headerlink" title="16.请说出作用域public，private，protected，以及不写时的区别。"></a><a href="">16.请说出作用域public，private，protected，以及不写时的区别。</a></h3><p>这四个作用域的可见范围如下表所示</p>
<p>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">作用域</th>
<th style="text-align:left">当前类</th>
<th style="text-align:left">同一package</th>
<th style="text-align:left">子孙类</th>
<th style="text-align:left">其他package</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
</tr>
<tr>
<td style="text-align:left">friendly</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p>
</li>
<li><p>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用。</p>
</li>
<li><p>protected：protected对于子类、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。</p>
</li>
</ul>
<h3 id="17-Overload-重载-和Override-重写-的区别。Overloaded的方法是否可以改变返回值的类型-（美团）"><a href="#17-Overload-重载-和Override-重写-的区别。Overloaded的方法是否可以改变返回值的类型-（美团）" class="headerlink" title="17.Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?（美团）"></a><a href="">17.Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?（美团）</a></h3><p>重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
<p>重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。<strong>如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</strong></p>
<p>如果几个Overloaded的方法的参数列表不一样，它们的返回者类型也可以不一样。</p>
<p>如果两个方法的参数列表完全一样，则不可以让它们的返回值不同来实现重载Overload。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候<strong>假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</strong></p>
<p>override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：</p>
<p>1）覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
<p>2）覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
<p>3）覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
<p>4）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<h3 id="18-构造方法是否可以被override"><a href="#18-构造方法是否可以被override" class="headerlink" title="18.构造方法是否可以被override?"></a><a href="">18.构造方法是否可以被override?</a></h3><p>构造方法不能被继承，因此不能重写Override，但可以被重载Overload。</p>
<h3 id="19-接口是否可继承接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concrete-class-抽象类中是否可以有静态的main方法？"><a href="#19-接口是否可继承接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concrete-class-抽象类中是否可以有静态的main方法？" class="headerlink" title="19.接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？"></a><a href="">19.接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？</a></h3><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。</p>
<p>抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。</p>
<h3 id="20-写clone-方法时，通常都有一行代码，是什么？"><a href="#20-写clone-方法时，通常都有一行代码，是什么？" class="headerlink" title="20.写clone()方法时，通常都有一行代码，是什么？"></a><a href="">20.写clone()方法时，通常都有一行代码，是什么？</a></h3><p>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。</p>
<h3 id="21-面向对象的特征有哪些方面"><a href="#21-面向对象的特征有哪些方面" class="headerlink" title="21.面向对象的特征有哪些方面"></a><a href="">21.面向对象的特征有哪些方面</a></h3><p>面向对象的编程语言有<strong>封装、继承 、抽象、多态</strong>等4个主要的特征。</p>
<p>1）封装：</p>
<p>面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了。</p>
<p>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。</p>
<p>优点:</p>
<ul>
<li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p><strong>说到封装，为什么有了私有属性，还要提供对外访问的公有方法，这样属性私有有什么意义</strong>？</p>
<p>其实这里体现的就是封装的思想: <strong>将数据与行为进行分离。</strong></p>
<p>试想， 如果外面的程序可以随意修改一个类的成员变量，会造成不可预料的程序错误， 就象一个人的名字，<br>不能被外部随意修改，只能通过各种给定的方法去修改这个属性。<br>所以我们将成员变量声明为private，再通过 public的方法来对这个变量进行访问。</p>
<p>对一个变量的操作，一般都有读取和赋值操作，我们分别定义两个方法来实现这两种操作：<br>一个是getXxx()（Xxx 表示要访问的成员变量的名字），用来获取这个成员变量；<br>另外一个是 setXxx()用来对这个成员变量修改。<strong>我们可以在set方法里做变量赋值逻辑判断，如果外部类赋的值不符合规则的话，就赋值失败。</strong></p>
<p>2）继承：</p>
<p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p>
<p>3）抽象：</p>
<p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：</p>
<p>class Person{</p>
<p>String name;</p>
<p>int age;</p>
<p>}</p>
<p>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。</p>
<p>4）多态：</p>
<p>多态分为编译时多态和运行时多态:</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件:</p>
<ul>
<li>继承</li>
<li>覆盖(重写)</li>
<li>向上转型</li>
</ul>
<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。</p>
<h3 id="22-Java中实现多态的机制是什么？"><a href="#22-Java中实现多态的机制是什么？" class="headerlink" title="22.Java中实现多态的机制是什么？"></a><a href="">22.Java中实现多态的机制是什么？</a></h3><p>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<h3 id="23-abstract-class-抽象类-和interface-接口-有什么区别-（美团）"><a href="#23-abstract-class-抽象类-和interface-接口-有什么区别-（美团）" class="headerlink" title="23.abstract class(抽象类)和interface(接口)有什么区别?（美团）"></a><a href="">23.abstract class(抽象类)和interface(接口)有什么区别?（美团）</a></h3><p>含有abstract修饰符的class即为抽象类，<strong>abstract 类不能创建实例对象。</strong>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p>
<p>下面比较一下两者的语法区别：</p>
<p>1）抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>2）抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>3）抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>4） 抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p>
<p>5）抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>6）抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
<p>7）一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p><strong>接口的变量为什么是static和final的？</strong></p>
<p>static：必须。因为接口是可以多继承的。如果一个类实现了两个接口，且两个接口都具有相同名字的变量，此时这个变量可以被实现类使用，那么如果不是static的，这个变量来自哪一个接口就会产生歧义，所以实现类使用接口中的变量必须通过接口名指定，也就只能定为static的。</p>
<p>final：我认为因为必须是<a href="https://so.csdn.net/so/search?q=static&amp;spm=1001.2101.3001.7020">static</a>的，那么所有子类共享，而接口是一种抽象， 所以一个子类修改了值会影响到其他所有子类，因此就不应该允许子类修改这个值，所以定义为final。</p>
<p><strong>下面接着再说说两者在应用上的区别：</strong></p>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 记录访问日志, 进行权限判断</span></span><br><span class="line">        <span class="keyword">if</span> (具有权限) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doService(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// todo：记录异常信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet1</span> <span class="keyword">extends</span> <span class="title class_">BaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion, ServletException &#123;</span><br><span class="line">        <span class="comment">// 本Servlet只处理的具体业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。</p>
<h3 id="24-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized"><a href="#24-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized" class="headerlink" title="24.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?"></a><a href="">24.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</a></h3><p>abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</p>
<p>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputStream类要和硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下：</p>
<p>private native void open(String name) throws FileNotFoundException;</p>
<p>如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。</p>
<p>关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。</p>
<h3 id="25-什么是内部类？Static-Nested-Class-和-Inner-Class的不同。"><a href="#25-什么是内部类？Static-Nested-Class-和-Inner-Class的不同。" class="headerlink" title="25.什么是内部类？Static Nested Class 和 Inner Class的不同。"></a><a href="">25.什么是内部类？Static Nested Class 和 Inner Class的不同。</a></h3><p>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out_x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在方法体内部定义的内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner2</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                out_x = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner2</span> <span class="variable">inner2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在方法体外面定义的内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法体外面定义的内部类的访问类型可以是public,protected,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner1</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Innner1</span>();</span><br></pre></td></tr></table></figure>
<p><strong>在方法内部定义的内部类前面不能有访问类型修饰符</strong>，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>
<p>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。</p>
<p>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>备注：首先根据印象说出自己对内部类的总体方面的特点。例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</p>
<h3 id="26-内部类可以引用它的包含类的成员吗？有没有什么限制？"><a href="#26-内部类可以引用它的包含类的成员吗？有没有什么限制？" class="headerlink" title="26.内部类可以引用它的包含类的成员吗？有没有什么限制？"></a><a href="">26.内部类可以引用它的包含类的成员吗？有没有什么限制？</a></h3><p>完全可以。如果不是静态内部类，那没有什么限制！</p>
<p>如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            syso(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以implements-实现-interface-接口"><a href="#27-Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以implements-实现-interface-接口" class="headerlink" title="27.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?"></a><a href="">27.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?</a></h3><p>可以继承其他类或实现其他接口。不仅是可以，而是必须!</p>
<h3 id="28-super-getClass-方法调用"><a href="#28-super-getClass-方法调用" class="headerlink" title="28.super.getClass()方法调用"></a><a href="">28.super.getClass()方法调用</a></h3><p>下面程序的输出结果是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Test</span>().test();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">super</span>.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很奇怪，结果是Test。</p>
<p>在test方法中，直接调用getClass().getName()方法，返回的是Test类名。由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。</p>
<p>如果想得到父类的名称，应该用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getClass().getSuperClass().getName();</span><br></pre></td></tr></table></figure>
<h3 id="29-String是最基本的数据类型吗"><a href="#29-String是最基本的数据类型吗" class="headerlink" title="29.String是最基本的数据类型吗?"></a><a href="">29.String是最基本的数据类型吗?</a></h3><p>基本数据类型包括byte、int、char、long、float、double、boolean和short。</p>
<p>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类</p>
<h3 id="30-String-s-“Hello”-s-s-“-world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？"><a href="#30-String-s-“Hello”-s-s-“-world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？" class="headerlink" title="30.String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？"></a><a href="">30.String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</a></h3><p>没有。</p>
<p>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。</p>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> Demo &#123;</span><br><span class="line">	s = <span class="string">&quot;Initial Value&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Initial Value&quot;</span>);</span><br></pre></td></tr></table></figure><br>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。</p>
<p>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。</p>
<p>至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。</p>
<h3 id="31-是否可以继承String类"><a href="#31-是否可以继承String类" class="headerlink" title="31.是否可以继承String类?"></a><a href="">31.是否可以继承String类?</a></h3><p>String类是final类故不可以继承。</p>
<h3 id="32-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？"><a href="#32-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？" class="headerlink" title="32.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？"></a><a href="">32.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</a></h3><p>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代码就不会创建”xyz”自己了，直接从缓冲区拿。</p>
<h3 id="33-String-和StringBuffer的区别"><a href="#33-String-和StringBuffer的区别" class="headerlink" title="33.String 和StringBuffer的区别"></a><a href="">33.String 和StringBuffer的区别</a></h3><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串可以进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffer来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p>
<p>接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	sbf.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	str = str + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。</p>
<h3 id="34-如何把一段逗号分割的字符串转换成一个数组"><a href="#34-如何把一段逗号分割的字符串转换成一个数组" class="headerlink" title="34.如何把一段逗号分割的字符串转换成一个数组?"></a><a href="">34.如何把一段逗号分割的字符串转换成一个数组?</a></h3><p>1）用正则表达式，代码大概为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] result = orgStr.split(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>2）用 StringTokenizer ,代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringTokenizer</span> <span class="variable">tokener</span> <span class="operator">=</span> StringTokenizer(orgStr,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">String [] result = <span class="keyword">new</span> <span class="title class_">String</span>[tokener.countTokens()];</span><br><span class="line">Int i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tokener.hasNext()&#123;result[i++]=toker.nextToken();&#125;</span><br></pre></td></tr></table></figure>
<h3 id="35-数组有没有length-这个方法-String有没有length-这个方法？"><a href="#35-数组有没有length-这个方法-String有没有length-这个方法？" class="headerlink" title="35.数组有没有length()这个方法? String有没有length()这个方法？"></a><a href="">35.数组有没有length()这个方法? String有没有length()这个方法？</a></h3><p>数组没有length()这个方法，有length的属性。String有length()这个方法。</p>
<h3 id="36-下面这条语句一共创建了多少个对象-String-s-”a”-”b”-”c”-”d”"><a href="#36-下面这条语句一共创建了多少个对象-String-s-”a”-”b”-”c”-”d”" class="headerlink" title="36.下面这条语句一共创建了多少个对象? String s=”a”+”b”+”c”+”d”;"></a><a href="">36.下面这条语句一共创建了多少个对象? String s=”a”+”b”+”c”+”d”;</a></h3><p>对于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">System.out.println(s3 == <span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。</p>
<p>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(s == <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>最终打印的结果应该为true。</p>
<h3 id="37-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#37-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="37.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?"></a><a href="">37.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</a></h3><p>也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ++x;</span><br><span class="line">           <span class="comment">// return x;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————-执行结果 ————-</p>
<p>1</p>
<p>运行结果是1，为什么呢？如果在try中return的情况下，先把try中将要return的值先存到一个本地变量中，即本例中的x=1将会被保存下来。接下来去执行finally语句，最后返回的是存在本地变量中的值，即返回x=1.</p>
<p>还有一点要注意的，如果你在finally里也用了return语句，比如return ++x。那么程序返回值会是2。因为JVM规范规定了，当try和finally里都有return时，会忽略try的return，而使用finally的return。</p>
<h3 id="38-final-finally-finalize的区别。"><a href="#38-final-finally-finalize的区别。" class="headerlink" title="38.final, finally, finalize的区别。"></a><a href="">38.final, finally, finalize的区别。</a></h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</p>
<p>内部类要访问局部变量，局部变量必须定义成final类型。</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用</p>
<h3 id="39-说出一些常用的类，包，接口，请各举5个。"><a href="#39-说出一些常用的类，包，接口，请各举5个。" class="headerlink" title="39.说出一些常用的类，包，接口，请各举5个。"></a><a href="">39.说出一些常用的类，包，接口，请各举5个。</a></h3><p>要让人家感觉你对java ee开发很熟，所以，不能仅仅只列core java中的那些东西，要多列你在做ssh项目中涉及的那些东西，就写你最近写的那些程序中涉及的那些类。</p>
<p>常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer</p>
<p>java.util.Date，System，Class，List,HashMap</p>
<p>常用的包：java.lang java.io java.util java.sql ,javax.servlet,org.apache.strtuts.action,org.hibernate</p>
<p>常用的接口：Remote List Map Document NodeList,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate)、Session(Hibernate),HttpSession</p>
<h3 id="40-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#40-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="40.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a><a href="">40.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</a></h3><p>字节流，字符流。</p>
<p>字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<h3 id="41-字节流与字符流的区别"><a href="#41-字节流与字符流的区别" class="headerlink" title="41.字节流与字符流的区别"></a><a href="">41.字节流与字符流的区别</a></h3><p>要把一片二进制数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>在应用中，经常要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</p>
<p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。</p>
<p>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p>
<h3 id="42-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"><a href="#42-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。" class="headerlink" title="42.什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。"></a><a href="">42.什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。</a></h3><p>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。</p>
<p>例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过RPC等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。</p>
<h3 id="43-Java源码的编译过程？（华为）"><a href="#43-Java源码的编译过程？（华为）" class="headerlink" title="43.Java源码的编译过程？（华为）"></a><a href="">43.Java源码的编译过程？（华为）</a></h3><p>Java源码是由Javac编译器编译的，流程如下：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20170205113216819.jpg" alt=""></p>
<p>源代码-&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器</p>
<p>Javac的任务就是将Java源代码编译成Java字节码，总结过程如下：</p>
<p> 1）<strong>词法分析</strong>：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程。</p>
<p>词法分析的结果：就是从源代码中找出了一些规范化的token流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。</p>
<p>2）<strong>语法分析</strong>：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。</p>
<p>语法分析的结果：就是形成一个符合Java语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。</p>
<p>3）<strong>语义分析</strong>：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。</p>
<p>语义分析结果：就是将复杂的语法转化为简单的语法，对应到Java就是将foreach转化为for循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。</p>
<p>4）<strong>字节码生成</strong>：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装文英文语句。代码生成器的结果就是生成符合java虚拟机规范的字节码。</p>
<p><strong>词法分析就是将关键词组织成token流即检查源码中的的关键词是否正确并组织成token流，而语法分析就是检查源码是否符合java语法规范并将词组成语句。语义分析就是简化复杂的添加缺少的，检查变量类型是否合法。代码生成器就是遍历这棵树生成符合JVM规范的字节码。</strong></p>
<h3 id="44-一个Object占多少字节？（shopee）"><a href="#44-一个Object占多少字节？（shopee）" class="headerlink" title="44.一个Object占多少字节？（shopee）"></a><a href="">44.一个Object占多少字节？（shopee）</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// o普通对象指针（Oops）4 字节（开启压缩占 4 字节，没开启占 8 字节），object对象占 16 字节 </span></span><br></pre></td></tr></table></figure>
<h3 id="46-什么是字节码-采用字节码的好处是什么"><a href="#46-什么是字节码-采用字节码的好处是什么" class="headerlink" title="46.什么是字节码?采用字节码的好处是什么?"></a><a href="">46.什么是字节码?采用字节码的好处是什么?</a></h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<h3 id="47-Java-程序从源代码到运行的过程"><a href="#47-Java-程序从源代码到运行的过程" class="headerlink" title="47.Java 程序从源代码到运行的过程"></a><a href="">47.<strong>Java 程序从源代码到运行的过程</strong></a></h3><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220209132736220.png" alt="image-20220209132736220"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。 </p>
<h3 id="48-为什么说-Java-语言“编译与解释并存”？"><a href="#48-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="48.为什么说 Java 语言“编译与解释并存”？"></a><a href="">48.为什么说 Java 语言“编译与解释并存”？</a></h3><p>因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="49-静态方法为什么不能调用非静态成员"><a href="#49-静态方法为什么不能调用非静态成员" class="headerlink" title="49.静态方法为什么不能调用非静态成员?"></a><a href="">49.静态方法为什么不能调用非静态成员?</a></h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="50-静态方法和实例方法有何不同？"><a href="#50-静态方法和实例方法有何不同？" class="headerlink" title="50.静态方法和实例方法有何不同？"></a><a href="">50.静态方法和实例方法有何不同？</a></h3><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h3 id="51-hashCode-有什么用？"><a href="#51-hashCode-有什么用？" class="headerlink" title="51. hashCode() 有什么用？"></a><a href="">51. hashCode() 有什么用？</a></h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h3 id="52-为什么要有-hashCode？"><a href="#52-为什么要有-hashCode？" class="headerlink" title="52.为什么要有 hashCode？"></a><a href="">52.为什么要有 hashCode？</a></h3><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HastSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="53-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#53-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="53.为什么重写 equals() 时必须重写 hashCode() 方法？"></a><a href="">53.为什么重写 equals() 时必须重写 hashCode() 方法？</a></h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h3 id="54-Java-中的几种基本数据类型了解么？"><a href="#54-Java-中的几种基本数据类型了解么？" class="headerlink" title="54. Java 中的几种基本数据类型了解么？"></a><a href="">54. Java 中的几种基本数据类型了解么？</a></h3><p>Java 中有 8 种基本数据类型，分别为：</p>
<ol>
<li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code></li>
</ol>
<h3 id="55-包装类型的常量池技术了解么？"><a href="#55-包装类型的常量池技术了解么？" class="headerlink" title="55.包装类型的常量池技术了解么？"></a><a href="">55.包装类型的常量池技术了解么？</a></h3><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<h3 id="56-自动装箱与拆箱了解吗？原理是什么？"><a href="#56-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="56. 自动装箱与拆箱了解吗？原理是什么？"></a><a href="">56. 自动装箱与拆箱了解吗？原理是什么？</a></h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h3 id="57-面向对象和面向过程的区别（美团）"><a href="#57-面向对象和面向过程的区别（美团）" class="headerlink" title="57.面向对象和面向过程的区别（美团）"></a><a href="">57.面向对象和面向过程的区别（美团）</a></h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="58-成员变量与局部变量的区别有哪些？"><a href="#58-成员变量与局部变量的区别有哪些？" class="headerlink" title="58.成员变量与局部变量的区别有哪些？"></a><a href="">58.成员变量与局部变量的区别有哪些？</a></h3><p><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
<p><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h3 id="59-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#59-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="59.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a><a href="">59.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p>
<h3 id="60-String-为什么是不可变的"><a href="#60-String-为什么是不可变的" class="headerlink" title="60.String 为什么是不可变的?"></a><a href="">60.String 为什么是不可变的?</a></h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="61-String、StringBuffer、StringBuilder-的区别？（美团）"><a href="#61-String、StringBuffer、StringBuilder-的区别？（美团）" class="headerlink" title="61. String、StringBuffer、StringBuilder 的区别？（美团）"></a><a href="">61. String、StringBuffer、StringBuilder 的区别？（美团）</a></h3><ul>
<li><p><strong>可变性</strong>：String是不可变的，<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
</li>
<li><p><strong>线程安全性</strong>:<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。 </p>
</li>
<li><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p>
</li>
</ul>
<h3 id="62-字符串常量池的作用了解吗？"><a href="#62-字符串常量池的作用了解吗？" class="headerlink" title="62.字符串常量池的作用了解吗？"></a><a href="">62.字符串常量池的作用了解吗？</a></h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗专为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
<h3 id="63-Java-泛型了解么？什么是类型擦除？"><a href="#63-Java-泛型了解么？什么是类型擦除？" class="headerlink" title="63.Java 泛型了解么？什么是类型擦除？"></a><a href="">63.Java 泛型了解么？什么是类型擦除？</a></h3><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。比如我们向一个整型list集合里面添加一个字符，直接调用add方法的话，会报错，但是可以通过反射的方法添加，这就说明在运行期间所有的泛型信息都会被擦掉。</p>
<p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h4 id="泛型的上限和下限？"><a href="#泛型的上限和下限？" class="headerlink" title="泛型的上限和下限？"></a>泛型的上限和下限？</h4><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h3 id="64-常用的通配符有哪些？"><a href="#64-常用的通配符有哪些？" class="headerlink" title="64.常用的通配符有哪些？"></a><a href="">64.常用的通配符有哪些？</a></h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h3 id="65-何为反射？"><a href="#65-何为反射？" class="headerlink" title="65.何为反射？"></a><a href="">65.何为反射？</a></h3><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h4 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h4><ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>
</ul>
<h3 id="66-Java-中-IO-流分为几种"><a href="#66-Java-中-IO-流分为几种" class="headerlink" title="66.Java 中 IO 流分为几种?"></a><a href="">66.Java 中 IO 流分为几种?</a></h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="67-既然有了字节流-为什么还要有字符流"><a href="#67-既然有了字节流-为什么还要有字符流" class="headerlink" title="67.既然有了字节流,为什么还要有字符流?"></a><a href="">67.既然有了字节流,为什么还要有字符流?</a></h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h3 id="68-java和c语言的区别是什么"><a href="#68-java和c语言的区别是什么" class="headerlink" title="68.java和c语言的区别是什么"></a><a href="">68.<strong>java和c语言的区别是什么</strong></a></h3><p>相同的地方：</p>
<p>　　1、语法类似：</p>
<p>　　由于Java可以算是从C++发展而来的，因此Java与C语言的语法比较类似</p>
<p>　　2、编程的熟练程度就是对语言程序库的掌握程度：</p>
<p>　　从某种程度上来说，编程语言都是由语法和相应的程序库所构成，Java有自身的类库，C语言则有标准库。所谓的编程，就是使用与语法来调用和组合程序库中的函数。</p>
<p>　　不同的地方：</p>
<p>　　1、内存管理</p>
<p>　　在Java中，基本不用考虑内存的问题，如果想用一个对象，new一个就可以，这个过程的背后则是JRE为对象分类的一定内存，当JRE发现你不再使用这个对象的时候，他就会自动回收内存，也就是说你只管借东西，不用管归还，因为与有人当你的跟班，在你不使用的时候就把东西归还了，不过这个过程还是有的，只不过是JRE作的而已。</p>
<p>　　但是C则不同，如果你想用，你可以用malloc之类的方法申请内存，当你使用完了，因为没有跟班的，你需要自己把这块内存归还回去，也就是调用free方法来完成这个任务。由于需要显式的归还内存，因此当一个函数需要将一块内存返回给调用者的时候，问题就比较复杂了，不如面向对象和具有内存回收功能的Java那么直观了。对于这个问题，在C语言中，有几种解决方案：</p>
<p>　　（1） 在调用者中先分配好内存，作为参数传入到被调用的函数中</p>
<p>　　（2） 在被调用的函数中分配，使用完后在调用者中释放</p>
<p>　　（3） 在被调用函数中使用static变量，可以将该变量返回</p>
<p>　　2、面向对象</p>
<p>　　Java的面向对象的特点很明显，而C则是一个地道的结构化语言。 Java中有一个字符串类String， 通过调用 String.length（）就可以知道字符串的长度，但是在C语言中，则需要调用函数strlen（str）来得到字符串（字符数组）的长度。由于C不是面向对象的语言，也就没有this的概念，因此当使用一个与某个“东西”相关的函数时，就需要不厌其烦的将代表这个“东西”的变量作为参数传递进去。</p>
<p>　　3、名称空间</p>
<p>　　Java通过包（package）来实现名称空间，在C语言中，所有的函数都处于同一名称空间，也就是没有名称空间，因此就会很多程序提供的api接口函数都有一个前缀，例如MYSQL的mysql<em>init（）， mysql_real_connect（）， mysql_real_query（）等函数名称前面的mysql</em>。</p>
<h3 id="69-int类型和long类型相加，结果是什么类型-美团"><a href="#69-int类型和long类型相加，结果是什么类型-美团" class="headerlink" title="69.int类型和long类型相加，结果是什么类型(美团)"></a><a href="">69.int类型和long类型相加，结果是什么类型(美团)</a></h3><p>结果是long类型，int类型会自动进行类型提升</p>
<p><a href="https://segmentfault.com/a/1190000020905371">https://segmentfault.com/a/1190000020905371</a></p>
<h3 id="70-static-关键字有什么作用"><a href="#70-static-关键字有什么作用" class="headerlink" title="70.static 关键字有什么作用"></a><a href="">70.static 关键字有什么作用</a></h3><p>static关键字可以用来修饰代码块表示静态代码块，修饰成员变量表示全局静态成员变量，修饰方法表示静态方法。(注意：不能修饰普通类，除了内部类）</p>
<p>静态是相对于动态的，动态是指Java程序在JVM上运行时，JVM会根据程序的需要动态创建对象并存储对象(分配内存)，对象使命结束后，对象会被垃圾回收器销毁，即内存回收由JVM统一管理并分配给其他新创建的对象；静态是指Java程序还没有运行时，JVM就会为加载的类分配空间存储被static关键字修饰的内容；如静态成员变量，Java类加载到JVM中，JVM会把类以及类的静态成员变量存储在方法区，我们知道方法区是线程共享且很少发生GC的区域，所以被static关键字修饰的内容都是全局共享的，且只会为其分配一次存储空间。</p>
<p>所以当类的某些内容不属于对象，而由对象共享即属于类的时候，就可以考虑是否用static关键字进行修饰。</p>
<p><strong>static关键字的的作用</strong></p>
<p><strong>1 修饰代码块</strong></p>
<p>类中用static关键字修饰的代码块称为静态代码，反之没有用static关键字修饰的代码块称为实例代码块。</p>
<p>实例代码块会随着对象的创建而执行，即每个对象都会有自己的实例代码块，表现出来就是实例代码块的运行结果会影响当前对象的内容，并随着对象的销毁而消失(内存回收)；而静态代码块是当Java类加载到JVM内存中而执行的代码块，由于类的加载在JVM运行期间只会发生一次，所以静态代码块也只会执行一次。</p>
<p>因为静态代码块的主要作用是用来进行一些复杂的初始化工作，所以静态代码块跟随类存储在方法区的表现形式是静态代码块执行的结果存储在方法区，即初始化量存储在方法区并被线程共享。</p>
<p><strong>2 修饰成员变量</strong></p>
<p>类中用static关键字修饰的成员变量称为静态成员变量，因为static不能修饰局部变量(为什么？)，因此静态成员变量也能称为静态变量。静态变量跟代码块类似，在类加载到JVM内存中，JVM会把静态变量放入方法区并分配内存，也由线程共享。访问形式是：类名.静态成员名。</p>
<p>一个类的静态变量和该类的静态代码块的加载顺序。类会优先加载静态变量，然后加载静态代码块，但有多个静态变量和多个代码块时，会按照编写的顺序进行加载。</p>
<p><strong>static关键不能修饰局部变量，包括实例方法和静态方法，不然就会与static关键字的初衷-共享相违背。</strong></p>
<p><strong>3 修饰方法</strong></p>
<p>用static关键字修饰的方法称为静态方法，否则称为实例方法。通过类名.方法名调用，但需要注意静态方法可以直接调用类的静态变量和其他静态方法，不能直接调用成员变量和实例方法(除非通过对象调用)。</p>
<p><strong>注意</strong>：既然类的实例方法需要对象调用才能访问，而静态方法直接通过类名就能访问，那么在不考虑部署服务器的情况下，一个类是如何开始执行的呢？最大的可能就是通过“类名.静态方法”启动Java，而我定义那么多静态方法，JVM又是如何知道主入口呢？</p>
<p>或许，你想到了main方法。</p>
<p>没错，就是main方法被Java规范定义成Java类的主入口。Java类的运行都由main方法开启</p>
<p><strong>static关键字的缺点</strong></p>
<p>封装是Java类的三大特性之一，也是面向对象的主要特性。因为不需要通过对象，而直接通过类就能访问类的属性和方法，这有点破坏类的封装性；所以除了Utils类，代码中应该尽量少用static关键字修饰变量和方法。</p>
<h3 id="71-Tomcat处理HTTP请求过程分析（菜鸟网络）"><a href="#71-Tomcat处理HTTP请求过程分析（菜鸟网络）" class="headerlink" title="71.Tomcat处理HTTP请求过程分析（菜鸟网络）"></a><a href="">71.Tomcat处理HTTP请求过程分析（菜鸟网络）</a></h3><p>Tomcat是一个web应用服务器，是一个Servlet/Jsp容器，主要负责将客户端请求传递给对应的Servlet，并且将Servlet的响应数据返回给客户端。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20181214143933248.jpg" alt=""></p>
<p>Tomcat的心脏是两个核心组件：Connector（连接器）和Container（容器）。其中一个Container可以选择多个Connector。</p>
<p>redirectPort字面意思是重定向端口。当用户用http请求某个资源，而该资源本身又被设置了必须要https方式访问，此时Tomcat会自动重定向到这个redirectPort设置的https端口。</p>
<h4 id="1、Connector组件"><a href="#1、Connector组件" class="headerlink" title="1、Connector组件"></a><strong>1、Connector组件</strong></h4><p>Connector 最重要的功能就是接收连接请求然后分配线程让 Container来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。Connector监听指定端口上请求，当请求到来时创建一个request和response对象交换数据，然后新建一个线程来处理请求并把request和response传递给Engine组件，最后从Engine获取一个响应并返回给客户端。</p>
<p>Connector组件常用属性说明：</p>
<p>（1） address：指定连接器监听的地址，默认为所有地址，即0.0.0.0，可以自己指定地。（2） maxThreads：支持的最大并发连接数，默认为200；</p>
<p>（3） port：监听的端口；</p>
<p>（4） protocol：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3；</p>
<p>（5） redirectPort：如果某连接器支持的协议是HTTP，当接收客户端发来的HTTPS请求时，则转发至此属性定义的端口；</p>
<p>（6） connectionTimeout：等待客户端发送请求的超时时间，单位为毫秒，默认为60000，即1分钟；</p>
<p>（7） enableLookups：是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名；默认为true； 进行反解的，可以设置为false。</p>
<p>（8） acceptCount：设置等待队列的最大长度；通常在tomcat所有处理线程均处于繁忙状态时，新发来的请求将被放置于等待队列中；</p>
<h4 id="2-container组件"><a href="#2-container组件" class="headerlink" title="2.container组件"></a><strong>2.container组件</strong></h4><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20181214144120710.jpg" alt=""></p>
<p>Container是容器的父接口，该容器的设计用的是典型的责任链的设计模式，它由四个自容器组件构成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。通常一个Servlet class对应一个Wrapper，如果有多个Servlet则定义多个Wrapper，如果有多个Wrapper就要定义一个更高的Container，如Context。 Context定义在父容器 Host 中，其中Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。</p>
<p>2.1、Engine<br>Engine是Servlet处理器的一个实例，即servlet引擎，默认为定义在server.xml中的Catalina。Engine需要defaultHost属性来为其定义一个接收所有请求的虚拟主机host组件。</p>
<p>2.2、Host<br>Host是Engine的子容器。一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用、接收并处理请求、保存一个主机应该有的信息。</p>
<p>常用属性说明：</p>
<p>（1）appBase：此Host的webapps目录，项目存放路径，可以使用绝对路径；</p>
<p>（2）autoDeploy：在Tomcat处于运行状态时放置于appBase目录中的应用程序文件是否自动进行deploy；默认为true；</p>
<p>（3）unpackWars：在启用此webapps时是否对WAR格式的归档文件先进行展开；默认为true；</p>
<p>2.3、Context<br>Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的</p>
<p>常用属性定义：</p>
<p>（1） docBase：相应的Web应用程序的存放位置；也可以使用相对路径，起始路径为此Context所属Host中appBase定义的路径；切记，docBase的路径名不能与相应的Host中appBase中定义的路径名有包含关系，比如，如果appBase为deploy，而docBase绝不能为deploy-bbs类的名字；</p>
<p>（2）path：相对于Web服务器根路径而言的URI；如果为空“”，则表示为此webapp的根路径；如果context定义在一个单独的xml文件中，此属性不需要定义，有可能是别名；</p>
<p>（3） reloadable：是否允许重新加载此context相关的Web应用程序的类；默认为false；</p>
<p>2.4、Wrapper<br>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>2.5、Realm<br>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>2.6、Value<br>Valve类似于过滤器，它可以工作于Engine和Host/Context之间、Host和Context之间以及Context和Web应用程序的某资源之间。一个容器内可以建立多个Valve，而且Valve定义的次序也决定了它们生效的次序。</p>
<h4 id="Tomcat处理一个HTTP请求的过程"><a href="#Tomcat处理一个HTTP请求的过程" class="headerlink" title="Tomcat处理一个HTTP请求的过程"></a>Tomcat处理一个HTTP请求的过程</h4><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20181214144140580.jpg" alt=""></p>
<p>1.用户在浏览器中输入网址localhost:8080/test/index.jsp，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得；</p>
<p>2.Connector把该请求交给它所在的Service的Engine（Container）来处理，并等待Engine的回应；</p>
<p>3.Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；</p>
<p>4.Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）。名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）；</p>
<p>5.path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL Pattern为*.jsp的Servlet，对应于JspServlet类；</p>
<p>6.构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost(),执行业务逻辑、数据存储等；</p>
<p>7.Context把执行完之后的HttpServletResponse对象返回给Host；</p>
<p>8.Host把HttpServletResponse对象返回给Engine；</p>
<p>9.Engine把HttpServletResponse对象返回Connector；</p>
<p>10.Connector把HttpServletResponse对象返回给客户Browser。</p>
<h3 id="72-a-a-b-与-a-b-的区别"><a href="#72-a-a-b-与-a-b-的区别" class="headerlink" title="72. a = a + b 与 a += b 的区别"></a><a href="">72. a = a + b 与 a += b 的区别</a></h3><p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)</p>
<h3 id="73-3-0-1-0-3-将会返回什么-true-还是-false"><a href="#73-3-0-1-0-3-将会返回什么-true-还是-false" class="headerlink" title="73. 3*0.1 == 0.3 将会返回什么? true 还是 false?"></a><a href="">73. 3*0.1 == 0.3 将会返回什么? true 还是 false?</a></h3><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h3 id="74-this-amp-super-在构造方法中的区别？"><a href="#74-this-amp-super-在构造方法中的区别？" class="headerlink" title="74. this() &amp; super()在构造方法中的区别？"></a><a href="">74. this() &amp; super()在构造方法中的区别？</a></h3><ul>
<li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li>
<li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li>
<li>尽管可以用this调用一个构造器, 却不能调用2个</li>
<li>this和super不能出现在同一个构造器中, 否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ul>
<h3 id="75-Java移位运算符？"><a href="#75-Java移位运算符？" class="headerlink" title="75.Java移位运算符？"></a><a href="">75.Java移位运算符？</a></h3><p>java中有三种移位运算符</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现RSA算法</title>
    <url>/posts/49034.html</url>
    <content><![CDATA[<p>1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人的名字命名，叫做 RSA 算法。直到现在，RSA 算法仍是最广泛使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。<br><span id="more"></span></p>
<h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><ul>
<li>选取大素数$p,q$;计算$n=pq$以及n的欧拉函数$φ(n) = φ(p) φ(q)=(p-1)(q-1)$。</li>
<li>选择一个$e(1&lt;e&lt;φ (n))$,使得$e$和$φ (n)$互素</li>
<li>计算$d$,使得$ed≡1(modφ(n))$，继而$(n,e)$为公钥发送到公钥空间，$(n,d)$为私钥，自己妥善保存。  </li>
</ul>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>假设明文为$m$ ,则密文为$c$, 加密公式为$c = m^e mod n$  </p>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>通过对明文$m$加密得密文为$c$,解密公式为$m=c^d mod n$  </p>
<h3 id="python代码如下"><a href="#python代码如下" class="headerlink" title="python代码如下:"></a>python代码如下:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ex_gcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;扩展欧几里德算法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        q = a // b</span><br><span class="line">        r = a % b</span><br><span class="line">        s, t = ex_gcd(b, r)</span><br><span class="line">        s, t = t, s-q*t</span><br><span class="line">    <span class="keyword">return</span> [s, t]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速幂算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fast_expmod</span>(<span class="params">a,e,n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速幂&quot;&quot;&quot;</span></span><br><span class="line">    d = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> e != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span>(e &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            d = (d * a) % n</span><br><span class="line">        e &gt;&gt;= <span class="number">1</span></span><br><span class="line">        a = a * a % n</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_key</span>(<span class="params">p, q, e</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成公私钥</span></span><br><span class="line"><span class="string">    参数1：大素数p</span></span><br><span class="line"><span class="string">    参数2：大素数q</span></span><br><span class="line"><span class="string">    参数3：随机生成e，满足 gcd(e,fin)</span></span><br><span class="line"><span class="string">    返回值：[公钥,私钥]-------[[n,e],[n,d]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = p * q</span><br><span class="line">    fin = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">    d = ex_gcd(e, fin)[<span class="number">0</span>]      <span class="comment"># 辗转相除法求逆(广义欧几里得)</span></span><br><span class="line">    <span class="keyword">while</span> d &lt; <span class="number">0</span>:</span><br><span class="line">        d = (d+fin) % fin</span><br><span class="line">    <span class="keyword">return</span> [[n, e], [n, d]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encryption</span>(<span class="params">key, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加密</span></span><br><span class="line"><span class="string">    参数1：列表[n,e]----公钥</span></span><br><span class="line"><span class="string">    参数2：待价密数据</span></span><br><span class="line"><span class="string">    返回值：密文</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n, e = key</span><br><span class="line">    plaintext = <span class="built_in">list</span>(data)</span><br><span class="line">    ciphertext = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> plaintext:</span><br><span class="line">        ciphertext.append(fast_expmod(<span class="built_in">ord</span>(item), e, n))</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">key, ciphertext</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解密</span></span><br><span class="line"><span class="string">    参数1：key为私钥</span></span><br><span class="line"><span class="string">    参数2：密文数据</span></span><br><span class="line"><span class="string">    返回值：明文</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n, d = key</span><br><span class="line">    plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ciphertext:</span><br><span class="line">        plaintext += (<span class="built_in">chr</span>(fast_expmod(item, d, n)))</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_p_q_e</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回值：[p,q,e]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p = <span class="number">33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489</span></span><br><span class="line">    q = <span class="number">36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917</span></span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    <span class="keyword">return</span> [p, q, e]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    p, q, e = make_p_q_e()</span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    plaintext = <span class="built_in">input</span>(<span class="string">&quot;待加密数据：&quot;</span>)</span><br><span class="line">    <span class="comment"># 公钥、私钥</span></span><br><span class="line">    public_key, private_key = make_key(p, q, e)</span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    ciphertext = encryption(public_key, plaintext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加密后的数据：&quot;</span>, ciphertext)</span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = decrypt(private_key, ciphertext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密后的数据：&quot;</span>, plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用命令</title>
    <url>/posts/commandsForRedis.html</url>
    <content><![CDATA[<p>Redis 所有的 key（键）都是字符串。在谈基础数据结构时，我们讨论的是存储值的数据类型，主要包括常见的 5 种数据类型，分别是：String、List、Set、Zset、Hash。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Redis 是一个 key-value 的数据库，key 是一般的 String，不过 value 却是多种多样的：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1658728198413.png" alt="1658728198413"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>String字符串</td>
<td>可以是字符、整数或浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td>List列表</td>
<td>一个链表，链表上的每个节点都包含一个字符串</td>
<td>对链表的两端进行 push 和 pop 操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td>Set集合</td>
<td>包含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有：看是否存在添加、获取、删除；还包含计算交集、并集、差集等；</td>
</tr>
<tr>
<td>Hash散列</td>
<td>包含键值对的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td>Zset 有序集合</td>
<td>和散列一样，用于存储键值对</td>
<td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素；</td>
</tr>
</tbody>
</table>
</div>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul>
<li><p>KEYS pattern：查看符合模版的所有 keys, 不建议在生产坏境下使用，因为当Redis中的数据量很大时，执行模糊查询会阻塞其他请求。</p>
</li>
<li><p>DEL key：删除一个指定的 key</p>
</li>
<li><p>EXISTS key：判断 key 是否存在</p>
</li>
<li><p>EXPIRE key seconds：给一个 key 设置过期时间，单位是秒，有效期到期时该key会被自动删除</p>
</li>
<li><p>TTL key：查看指定 key 的剩余有效时间 。-1 表示当前 key 没有设置有效时间 ，-2 表示当前 key 不存在</p>
</li>
<li><p>PERSIST key：持久化指定 key</p>
</li>
<li><p>TYPE key：查看指定 key 的类型</p>
</li>
<li><p>MOVE key num：移动指定 key 到指定数据库</p>
</li>
<li><p>RANDOMKEY：随即返回库中的一个 key</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; select <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">k2</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; persist <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> -<span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type k1</span><br><span class="line">string</span><br></pre></td></tr></table></figure>
<h3 id="String-字符串命令"><a href="#String-字符串命令" class="headerlink" title="String 字符串命令"></a>String 字符串命令</h3><blockquote>
<p>String类型是Redis基本类型，一个键最大能存储512MB且是二进制安全的。意思是 redis 的 String 类型可以存储任何数据，如数字，字符串，jpg图片或者序列化的对象。</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>redis中的String是动态字符串，内部结构类似ArrayList。采用预分配冗余空间的方式减少内存的频繁分配。</p>
<blockquote>
<p>内部为字符串分配的实际空间一般高于字符串长度，当字符串长度<1MB时，扩容方式是加倍 也就是原来的两倍。当字符串长度>1MB时，一次扩容1MB，直到最大512MB.</p>
</blockquote>
<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增.自减操作</li>
<li>float：浮点类型，可以做自增.自减操作</li>
</ul>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1652890121291.png" alt="1652890121291"></p>
<h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p>
<ul>
<li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>MSET和MGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>INCR和INCRBY和DECY</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>SETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SETEX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex name <span class="number">10</span> jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="Redis命令-Key的层级结构"><a href="#Redis命令-Key的层级结构" class="headerlink" title="Redis命令-Key的层级结构"></a>Redis命令-Key的层级结构</h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1652941631682.png" alt="1652941631682"></p>
<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>heima:user:1</td>
<td>{“id”:1, “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1, “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody>
</table>
</div>
<p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1652941883537.png" alt="1652941883537"></p>
<h3 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1652941995945.png" alt="1652941995945"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1652942027719.png" alt="1652942027719"></p>
<p><strong>Hash类型的常见命令</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li>HKEYS：获取一个hash类型的key中的所有的field</li>
<li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li>
</ul>
<ul>
<li>HSET和HGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HMSET和HMGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HGETALL</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HKEYS和HVALS</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HINCRBY</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HSETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p><strong>List的常见命令有：</strong></p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1652943604992.png" alt="1652943604992"></p>
<ul>
<li>LPUSH和RPUSH</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LPOP和RPOP</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LRANGE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集.并集.差集等功能</li>
</ul>
<p><strong>Set类型的常见命令</strong></p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
<li>SDIFF key1 key2 … ：求key1与key2的差集</li>
<li>SUNION key1 key2 ..：求key1和key2的并集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114142002049.png" alt="image-20221114142002049"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221114142018642.png" alt="image-20221114142018642"></p>
<p><strong>具体命令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<ul>
<li>将下列数据用Redis的Set集合来存储：</li>
<li>张三的好友有：李四.王五.赵六</li>
<li>李四的好友有：王五.麻子.二狗</li>
<li>利用Set的命令实现下列功能：</li>
<li>计算张三的好友有几人</li>
<li>计算张三和李四有哪些共同好友</li>
<li>查询哪些人是张三的好友却不是李四的好友</li>
<li>查询张三和李四的好友总共有哪些人</li>
<li>判断李四是否是张三的好友</li>
<li>判断张三是否是李四的好友</li>
<li>将李四从张三的好友列表中移除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li>
<li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的高阶函数</title>
    <url>/posts/57202.html</url>
    <content><![CDATA[<p>把函数作为参数传入，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。</p>
<span id="more"></span>
<h2 id="体验高阶函数"><a href="#体验高阶函数" class="headerlink" title="体验高阶函数"></a>体验高阶函数</h2><p>在Python中，<code>abs()</code>函数可以完成对数字求绝对值计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(-<span class="number">10</span>)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p><code>round()</code>函数可以完成对数字的四舍五入计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">round</span>(<span class="number">1.2</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">round</span>(<span class="number">1.9</span>)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>需求：任意两个数字，按照指定要求整理数字后再进行求和计算。</p>
<ul>
<li>方法1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_num</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) + <span class="built_in">abs</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = add_num(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_num</span>(<span class="params">a, b, f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(a) + f(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = sum_num(-<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">abs</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。</p>
</blockquote>
<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
<h2 id="内置高阶函数"><a href="#内置高阶函数" class="headerlink" title="内置高阶函数"></a>内置高阶函数</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。</p>
<p>需求：计算<code>list1</code>序列中各个数字的2次方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">map</span>(func, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># &lt;map object at 0x0000013769653198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。</p>
<blockquote>
<p>注意：reduce()传入的参数func必须接收2个参数。</p>
</blockquote>
<p>需求：计算<code>list1</code>序列中各个数字的累加和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = functools.reduce(func, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个 filter 对象。如果要转换为列表, 可以使用 list() 来转换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">filter</span>(func, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># &lt;filter object at 0x0000017AF9DC3198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro认证流程源码分析</title>
    <url>/posts/29996.html</url>
    <content><![CDATA[<h2 id="创建认证测试类"><a href="#创建认证测试类" class="headerlink" title="创建认证测试类"></a>创建认证测试类</h2><span id="more"></span>
<p>创建<code>TestAuthenticator</code>类,代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAuthenticator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建安全管理器对象</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.给安全管理器设置realm</span></span><br><span class="line">        securityManager.setRealm(<span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.SecurityUtils 给全局安全工具类设置安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关键对象 subject 主体</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建令牌</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;heling&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            subject.login(token); <span class="comment">//用户认证</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：用户名不存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shiro.ini</code>内容为：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">heling</span>=<span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>运行测试结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">认证状态：false</span><br><span class="line">认证状态：true</span><br></pre></td></tr></table></figure>
<p>以上过程是shiro中最简单的一个认证，其中的权限管理数据是通过<code>IniRealm</code>的形式去读取配置文件<code>shiro.ini</code>来加载数据，但是以后的权限管理数据肯定都是来源于数据库的，所以我们要把数据更改到数据库。<br>Shiro从<code>Realm</code>获取安全数据 (如用户,角色，权限)，就是说<code>SecurityManager</code>要验证用户身份，那么它需要从<code>Realm</code>获取相应的用户进行比较，来确定用户的身份是否合法;也需要从<code>Realm</code>得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把<code>Realm</code>看<code>DataSource</code>;<code>Realm</code>可以决定我们的权限管理数据是来源于ini配置文件还是数据库，也就是数据的调配是由<code>Realm</code>来执行的，为了搞清楚<code>Realm</code>的调配流程，我们简单看一下认证的源码。</p>
<h2 id="认证源码分析"><a href="#认证源码分析" class="headerlink" title="认证源码分析"></a>认证源码分析</h2><h3 id="用户名认证"><a href="#用户名认证" class="headerlink" title="用户名认证"></a>用户名认证</h3><p>首先在<code>subject.login(token);</code>处打上断点，然后Debug运行。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/abb91f97c04344d185c28329c0b6e98b.png" alt="在这里插入图片描述"><br>程序停在断点之后，我们进行login方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/aa6db40626e548e7b84b269c7d89edb5.png" alt="在这里插入图片描述"><br>可以看到虽然是subject调用的login，但是真正去执行的是<code>DelegatingSubject</code>中的login，方法刚开始调用了一个clear方法，然后由安全管理器进行认证，内部的<code>this</code>就是<code>DelegatingSubject</code>类，token就是我们传过来的由身份信息和凭证信息组成的令牌。然后再进入<code>securityManager</code>的<code>login</code>方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/670c5123f30d46bbafbb6ff5e16041bf.png" alt="在这里插入图片描述">我们发现实际上真正去执行的是<code>DefaultSecurityManager</code>中的<code>login</code>方法，方法刚开始就执行一个<code>authenticate</code>方法，传入token，然后继续进入这个方法内部。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/ba35e85f6ad14c9fa897ce20e91398e3.png" alt="在这里插入图片描述"><br>继续调用<code>AuthenticatingSecurityManager</code>类中的<code>authenticate</code>方法，在这个方法中又调用了当前类中的<code>authenticator</code>对象的<code>authenticate</code>方法，继续进入这个方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/9402e1a1f8034893a9e8c5fd6a1bc5e8.png" alt="在这里插入图片描述"><br>发现调用了<code>AbstractAuthenticator</code>中的<code>authenticate</code>方法，在这个方法中由调用了<code>doAuthenticate</code>方法，继续进入<code>doAuthenticate</code>。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/f6ad84a63576444f9d8985ddb898fe17.png" alt="在这里插入图片描述"><br>来到了<code>ModularRealmAuthenticator</code>类中的<code>doAuthenticate</code>方法，方法开始时有一个断言询问是否配置Realm，然后<code>getRealms</code>方法拿到了所有的域，我们只有一个域，所以<code>realms.size() == 1</code>，进入<code>doSingleRealmAuthentication</code>方法。然后进入<code>doSingleRealmAuthentication</code>方法查看。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/96aad19cbd0546c78be891e7f315ccee.png" alt="在这里插入图片描述"><br><code>doSingleRealmAuthentication</code>方法刚开始询问realm是否支持token，realm肯定支持，所以realm调用<code>getAuthenticationInfo</code>方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/978beb8dbea941a2b5ebdb3d3fca5361.png" alt="在这里插入图片描述"><br>可以发现它是从缓存中拿取认证信息，因为程序第一次运行是没有缓存的，所以这次肯定拿不到信息。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/28c7b736e9c94d62b07ac7f62fc0125f.png" alt="在这里插入图片描述"><br>继续调用<code>doGetAuthenticationInfo</code>方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/685d1c660c3043a28430df813f7cb092.png" alt="在这里插入图片描述"><br>这里可以看到<code>doGetAuthenticationInfo</code>方法将token取出来，然后强转成UsernamePasswordToken，然后通过<code>upToken.getUsername()</code>获得用户名，最后使用<code>getUser</code>方法拿到用户。我们继续进入<code>getUsername</code>方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1cdc7bffae5a4828a4973396fd8c1cbf.png" alt="在这里插入图片描述"><br>可以看到已经拿到用户名<code>heling</code>。然后下一步回去。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/64f805fe727b41d5bf3f4c1342d0cfe1.png" alt="在这里插入图片描述"><br>再进入<code>getUser</code>方法。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/b699614a96b64ce48aaef3c747fccbc6.png" alt="在这里插入图片描述">username被传进来了，往下走，发现<code>this.users</code>的size=1，因为我们的配置文件<code>shiro.ini</code>中只有一个用户。然后这里根据用户名拿到用户，返回<code>SimpleAccount</code>，继续下一步。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/b94005b97f1842a1b7586e00722b5caa.png" alt="在这里插入图片描述"><br>这时已经拿到account，所以account肯定不为空，而且account也没有上锁，也没有做过验证密码是否过期的处理，所以最终在<code>SimpleAccountRealm</code>类中通过<code>doGetAuthenticationInfo</code>方法完成了一个用户名的认证。</p>
<h3 id="密码认证"><a href="#密码认证" class="headerlink" title="密码认证"></a>密码认证</h3><p>在<code>return acount</code>之后继续下一步，回到了<code>AuthenticatingRealm</code>类，<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/be85d7e965ec4682a6962d7b68bf3397.png" alt="在这里插入图片描述">这里拿到的info肯定不为空了，继续下一步，因为<code>token != null &amp;&amp; info != null</code>，所以增加了缓存（<code>this.cacheAuthenticationInfoIfPossible(token, info);</code>）。继续往下走。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/7a552b8a204045b6b64fb7eb59e6a684.png" alt="在这里插入图片描述"><br>如果info不为空的话，就进入一个断言，判断token中的密码和info中的密码是否相等。进入<code>assertCredentialsMatch</code>方法查看。<br><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1e0e04f22c8c46f5941a22a359aa21a1.png" alt="在这里插入图片描述"><br>进入方法，拿到了一个密码匹配器，如果密码匹配器不为空的话，就调用<code>doCredentialsMatch</code>方法对token中的密码和info中的密码进行比对，如果密码不正确就抛出<code>IncorrectCredentialsException</code>异常。所以最终密码的校验是在<code>AuthenticatingRealm</code>类中的<code>assertCredentialsMatch</code>方法中完成的。<br>如果以后我们要把数据换成数据库的实现，那么我们只需把<code>SimpleAccountRealm</code>类中<code>doGetAuthenticationInfo</code>方法的实现换成读取数据库，因为<code>SimpleAccountRealm</code>继承自<code>AuthorizingRealm</code>类，所以如果我们要自定义Realm，我们也应该自己写一个类去继承<code>AuthorizingRealm</code>并重写<code>doGetAuthenticationInfo</code>方法。密码校验是不需要我们自己处理的，因为我们在用户名认证之后返回info信息，<code>AuthenticatingRealm</code>类中的<code>assertCredentialsMatch</code>方法会自动帮我们校验。</p>
]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 必知必会</title>
    <url>/posts/5427.html</url>
    <content><![CDATA[<h2 id="一、是什么？能做什么？"><a href="#一、是什么？能做什么？" class="headerlink" title="一、是什么？能做什么？"></a>一、是什么？能做什么？</h2><ul>
<li><p>是一个快速开发的脚手架</p>
</li>
<li><p>作用：快速创建独立的、生产级的基于Spring的应用程序</p>
<p>SpringBoot是基于Spring的用来提升效率的框架，可以让编码更加简单，配置管理也更加简单，部署也更方</p>
<span id="more"></span></li>
<li><p>特性</p>
<ul>
<li>无需部署WAR文件</li>
<li>提供starter简化配置</li>
<li>尽可能自动配置Spring以及第三方库</li>
<li>提供“生产就绪”功能，例如指标、健康检查、外部配置等</li>
<li>无代码生成&amp;无XML</li>
</ul>
</li>
</ul>
<h2 id="二、编写第一个SpringBoot应用"><a href="#二、编写第一个SpringBoot应用" class="headerlink" title="二、编写第一个SpringBoot应用"></a>二、编写第一个SpringBoot应用</h2><ul>
<li>需求<ul>
<li>整合Spring MVC</li>
<li>/test路径（端点）</li>
</ul>
</li>
<li>使用Spring Initializr快速创建Spring Boot应用</li>
</ul>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929122815096.png" alt="image-20210929122815096"  /></p>
<p>左侧选择Spring Initializr，SDK选择JDK1.8，Custom使用<a href="http://start.aliyun.com">http://start.aliyun.com</a>可以加快下载速度，然后点击Next创建。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929131811905.png" alt="image-20210929131811905"></p>
<p>填写Group和项目唯一标识Artifact，打包方式选择Jar，这也是Sprint官方推荐的打包方式，Java版本选择8，点击Next。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929132216076.png" alt="image-20210929132216076"></p>
<p>选择最新版本的Spring Boot，添加Spring Web来整合Spring MVC。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929132409252.png" alt="image-20210929132409252"></p>
<p>填写项目名称以及项目地址，完成。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929132612574.png" alt="image-20210929132612574"></p>
<p>生成的项目其实已经整合了MVC。</p>
<p>下面写Test端点，在cn.cstube包下创建类TestController。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cstube;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> heling</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目启动之前，使用<code>mvn clean install</code>确保能够构建成功再去启动，主要是为了防止有Jar包没有下载完整，导致启动失败。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929140808446.png" alt="image-20210929140808446"></p>
<p>最后启动SpringBootDemoApplication类。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929141034166.png" alt="image-20210929141034166"></p>
<p>在浏览器访问<a href="localhost:8080/test">localhost:8080/test</a>，可以看到可以返回test。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929141226978.png" alt="image-20210929141226978"></p>
<p>以上是在Idea中的启动，在实际的项目部署中我们需要进到<code>target</code>目录，找到可以执行的jar包，然后执行<code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar</code>，同样在浏览器中也可以返回正常结果。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929141503364.png" alt="image-20210929141503364"></p>
<h2 id="三、Spring-Boot的应用组成分析"><a href="#三、Spring-Boot的应用组成分析" class="headerlink" title="三、Spring Boot的应用组成分析"></a>三、Spring Boot的应用组成分析</h2><ul>
<li>依赖：<code>pom.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springmvc整合--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单元测试支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动类：注解</li>
</ul>
<p><code>@SpringBootApplication</code>代表这个类为启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line">    <span class="comment">//启动类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置：application.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">spring-boot-demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure>
<ul>
<li>static目录：静态文件</li>
</ul>
<p>主要用于存放静态文件，比如html，css文件。</p>
<ul>
<li>templates目录：模板文件</li>
</ul>
<p>用于存放模板文件，因为Spring MVC支持多种视图格式，比如jsp,freemarker等模板引擎，但是现在的应用大多基于前后端分离开发，以后基本用不到模板引擎。</p>
<h2 id="四、Spring-Boot开发三板斧"><a href="#四、Spring-Boot开发三板斧" class="headerlink" title="四、Spring Boot开发三板斧"></a>四、Spring Boot开发三板斧</h2><ul>
<li>加依赖</li>
</ul>
<p>如果你想在Spring Boot整合xxx，那么只需要在<code>pom.xml</code>中上xxx的依赖即可。例如整合JPA和Mybatis。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        boot官方提供：spring-boot-starter-xxx--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        mybatis 非官方提供starter:xxx-spring-boot-starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>写注解</li>
</ul>
<p>在启动类中会添加各种各样的注解</p>
<ul>
<li>写配置</li>
</ul>
<p>在<code>application.properties</code>中添加各种配置</p>
<h2 id="五、Spring-Boot-Actuator"><a href="#五、Spring-Boot-Actuator" class="headerlink" title="五、Spring Boot Actuator"></a>五、Spring Boot Actuator</h2><ul>
<li>是什么？</li>
</ul>
<p>Spring Boot Actuator是Spring Boot中非常重要的组件，它为我们的应用提供了强大的监控能力。如今的应用越来越复杂，我们需要一些监控工具来帮助我们记录问题。</p>
<ul>
<li>如何整合?</li>
</ul>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动应用，可以看到actuator暴露了两个端点。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929145625923.png" alt="image-20210929145625923"></p>
<p>打开<a href="localhost:8080/actuator">localhost:8080/actuator</a></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929145852358.png" alt="image-20210929145852358" style="zoom:50%;" /></p>
<p>点击<a href="http://localhost:8080/actuator/health">http://localhost:8080/actuator/health</a></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929150133024.png" alt="image-20210929150133024" style="zoom:50%;" /></p>
<p>health端点是非常重要的端点，以后会经常用到。作用是健康检查，也就是检查应用的资源。我们需要在配置文件中添加配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">spring-boot-demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management.endpoint.health.show-details</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>启动应用。再次打开<a href="http://localhost:8080/actuator/health">http://localhost:8080/actuator/health</a></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929150622468.png" alt="image-20210929150622468" style="zoom:50%;" /></p>
<p>可以看到这里检查了磁盘资源，磁盘大小为325G，剩余空间为63.3G，如果剩余空间低于threshold，那么这个磁盘就是不健康的。</p>
<p>status取值：</p>
<ul>
<li>UP：正常</li>
<li>DOWN: 遇到了问题，不正常</li>
<li>OUT_OF_SERVICE: 资源未在使用，或者不该去使用</li>
<li>UNKNOWN: 不知道</li>
</ul>
<p><a href="http://localhost:8080/actuator/info">http://localhost:8080/actuator/info</a>是一个描述端点，主要用来描述应用信息。例如在配置文件中添加配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述应用</span></span><br><span class="line"><span class="attr">info.app-name</span>=<span class="string">spring-boot-demo</span></span><br><span class="line"><span class="attr">info.author</span>=<span class="string">heling</span></span><br><span class="line"><span class="attr">info.email</span>=<span class="string">xxx@email</span></span><br></pre></td></tr></table></figure>
<p>启动应用，然后访问info端点</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929151753941.png" alt="image-20210929151753941" style="zoom:50%;" /></p>
<p>下面是Spring Boot Actuator常见的监控端点</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929151934733.png" alt="image-20210929151934733"></p>
<p>除了health和info，其他的端点都是隐藏的。只需要在配置文件中添加配置即可激活所有端点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 激活所有的actuator端点</span></span><br><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure>
<p>重启应用，刷新<a href="localhost:8080/actuator">localhost:8080/actuator</a>就会发现已激活所有端点，如果只想激活个别端点，那么就更改一下配置，比如只激活metrics和health端点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">metrics,health</span></span><br></pre></td></tr></table></figure>
<h2 id="六、Spring-Boot配置管理"><a href="#六、Spring-Boot配置管理" class="headerlink" title="六、Spring Boot配置管理"></a>六、Spring Boot配置管理</h2><ul>
<li>支持的配置格式</li>
</ul>
<p>Spring Boot除了支持<code>.properties</code>类型的配置文件外，还支持<code>.yml</code>或者<code>.yaml</code>的文件。</p>
<p><strong>Yet Anther Markup Language（.yml/.yaml）</strong>是JSON子集，格式如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app-name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">heling</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">xxx@email</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">metrics,health</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-demo</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>:</code>后的空格一定不能缺少，另外每一行前有严格的缩进。</p>
<p>在实际项目中更推荐使用<code>.yml</code>格式的配置文件，因为其可读性更强，在业界更受欢迎，而且它可以保证配置读取的顺序。</p>
<ul>
<li><p>配置管理常用方式</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>环境变量</p>
<p>例如在将<code>always</code>改为<code>$&#123;SOME_ENV&#125;</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app-name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">heling</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">xxx@email</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">$&#123;SOME_ENV&#125;</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">metrics,health</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-demo</span></span><br></pre></td></tr></table></figure>
<p>然后在应用启动的时候指定环境变量</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929154407814.png" alt="image-20210929154407814"></p>
<p>启动应用发现依然可以展示详情，但是在重新构建应用的时候，会因为单元测试报错，因为单元测试拿不到idea中的配置，这时候可以删除测试类或者在使用<code>mvn clean install -DskipTests</code>跳过单元测试。构建应用之后，使用<code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --SOME_ENV=always</code>启动应用。</p>
</li>
<li><p>外部配置文件</p>
<p>将Jar包和配置文件放在同一目录下，然后使用命令启动应用，Spring Boot会优先读取配置文件中的配置，也就是说外部配置文件的优先级比Jar包的配置文件更高。</p>
</li>
<li><p>命令行参数</p>
<p>比如我希望应用的Tomcat运行端口为8081，但我又不想写在配置文件中，只需要在运行配置里填写<code>--server.port=8081</code>就可以了。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929155914558.png" alt="image-20210929155914558"></p>
<p>如果是使用命令的方式启动应用的话，使用<code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --    server.port=8081</code>启动即可。</p>
</li>
</ul>
</li>
</ul>
<h2 id="七、Profile"><a href="#七、Profile" class="headerlink" title="七、Profile"></a>七、Profile</h2><ul>
<li>如何实现不同环境不同配置</li>
</ul>
<p>在实际项目中我们往往需要在不同的环境使用不同的配置，例如开发环境的Tomcat不需要性能调优，但是生产环境的Tomcat往往需要设置一些性能调优参数，比如最大连接数，最大限制数等，这个时候就可以使用Profile。</p>
<ul>
<li>怎么使用</li>
</ul>
<p>如果应用是<code>yml</code>格式配置的，那么在配置文件中使用连字符<code>---</code>将配置文件分成若干段，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有环境公用的配置属性</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app-name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">heling</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">xxx@email</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">$&#123;SOME_ENV&#125;</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">metrics,health</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># profile=y的专用属性，也就是某个环境下的专用属性</span></span><br><span class="line"><span class="comment"># 生产环境</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>如果应用以<code>dev</code>启动的话就会使用1,2两段，如果以<code>prod</code>启动的话，就会使用1,3两段。例如使用<code>prod</code>启动</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929161705714.png" alt="image-20210929161705714"></p>
<p>如果想在配置文件中指定启动环境，则添加配置</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20210929162306832.png" alt="image-20210929162306832" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的Next主题实现数学公式渲染</title>
    <url>/posts/54574.html</url>
    <content><![CDATA[<p>在做密码学研究时，经常会使用数学公式进行一系列推导计算，而hexo博客默认使用 hexo-renderer-marked 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线<code>_</code>代表斜体，会被渲染引擎处理为<code>&lt;em&gt;</code>标签。<br><span id="more"></span><br>因为类 Latex 格式书写的数学公式下划线<code>_</code>表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括<code>*</code>,<code>&#123;</code>, <code>&#125;</code>, <code>\\</code>等。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。如果你是Windows系统，直接使用Git Bash的命令行在Hexo根目录下使用命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><br>然后，更换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为 hexo-renderer-kramed 引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，做相应的修改：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  // 第2行修改</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  ...</span><br><span class="line">  // 第20行修改</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="在-Next-主题中开启-MathJax-开关"><a href="#在-Next-主题中开启-MathJax-开关" class="headerlink" title="在 Next 主题中开启 MathJax 开关"></a>在 Next 主题中开启 MathJax 开关</h3><p>找到根目录下的/themes/next/_config.yml文件，按下Ctrl+F，在弹出的搜索框中输入mathjax查找匹配项，然后你找到了这样几行字,把 math 默认的 false 修改为true<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Math Formulas Render Support</span><br><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: true</span><br></pre></td></tr></table></figure><br>在需要使用数学公式的文章的Front-matter里打开mathjax开关，考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Python实现RSA算法</span><br><span class="line">categories: 密码学</span><br><span class="line">tags: RSA</span><br><span class="line">abbrlink: 49034</span><br><span class="line">mathjax: true</span><br><span class="line">date: 2020-08-02 09:16:24</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>最后一键三连<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><br>即可生效。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/posts/21238.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<span id="more"></span>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li>
<li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li>
</ul>
<p><strong>进一步优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_v2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo的Next主题首页文章添加阴影</title>
    <url>/posts/64817.html</url>
    <content><![CDATA[<p>在next主题文件下找到\next\source\css_common\components\post的post.styl文件<br><span id="more"></span><br>在.post_block位置,更改如下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">    .post-block &#123;</span><br><span class="line">     opacity: 0;</span><br><span class="line">     margin-top: 60px;</span><br><span class="line">     margin-bottom: 60px;</span><br><span class="line">     padding: 25px;</span><br><span class="line">     -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">     -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">    &#125;</span><br><span class="line">    .pagination, .comments &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后执行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><br>即可生效</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>启动SpringBoot项目时报错Error parsing HTTP request header</title>
    <url>/posts/53549.html</url>
    <content><![CDATA[<p>在服务器中使用Docker部署SpringBoot项目时，在启动日志里发现项目报错，报错内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">java.lang.IllegalArgumentException: Invalid character found in method name [0x040x010x00P0x8e]0x880x8e0...]. HTTP method names must be tokens</span><br><span class="line">        at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:417)</span><br><span class="line">        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:261)</span><br><span class="line">        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)</span><br><span class="line">        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)</span><br><span class="line">        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)</span><br><span class="line">        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)</span><br><span class="line">        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">        at java.base/java.lang.Thread.run(Thread.java:832)</span><br></pre></td></tr></table></figure>
<p>可以看到在请求信息中包含了非法字符，所以我们在项目中添加一个Tomcat配置类，使得可以插入\”#&lt;&gt;[\]^`{|}中的任意特殊字符，当然也可以自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Connector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">webServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        factory.addConnectorCustomizers((Connector connector) -&gt; &#123;</span><br><span class="line">                connector.setProperty(<span class="string">&quot;relaxedPathChars&quot;</span>, <span class="string">&quot;\&quot;#&lt;&gt;[\\]^`&#123;|&#125;&quot;</span>);</span><br><span class="line">                connector.setProperty(<span class="string">&quot;relaxedQueryChars&quot;</span>, <span class="string">&quot;\&quot;#&lt;&gt;[\\]^`&#123;|&#125;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新打包项目，并部署在docker中，发现已经没有报错。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>刷新JWT令牌应该如何设计</title>
    <url>/posts/663.html</url>
    <content><![CDATA[<h3 id="为什么要刷新Token的过期时间？"><a href="#为什么要刷新Token的过期时间？" class="headerlink" title="为什么要刷新Token的过期时间？"></a>为什么要刷新Token的过期时间？</h3><p>我们在定义JwtUtil工具类的时候，生成的<code>Token</code>都有过期时间。那么问题来了，假设<code>Token</code>过期时间为15天，用户在第14天的时候，还可以免登录正常访问系统。但是到了第15天，用户的Token过期，于是用户需要重新登录系统。</p>
<span id="more"></span>
<p><code>HttpSession</code>的过期时间比较优雅，默认为15分钟。如果用户连续使用系统，只要间隔时间不超过15分钟，系统就不会销毁<code>HttpSession</code>对象。JWT的令牌过期时间能不能做成<code>HttpSession</code>那样超时时间，只要用户间隔操作时间不超过15天，系统就不需要用户重新登录系统。实现这种效果的方案有两种：<code>双Token</code>和<code>Token缓存</code>，这里重点讲一下<code>Token</code>缓存方案。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/604388a80995d6ac22960228.jpg" alt="img"></p>
<p>Token缓存方案是把<code>Token</code>缓存到Redis，然后设置Redis里面缓存的<code>Token</code>过期时间为正常<code>Token</code>的1倍,然后根据情况刷新<code>Token</code>的过期时间。</p>
<p><strong>Token失效，缓存也不存在的情况</strong></p>
<p>当第15天，用户的<code>Token</code>失效以后，我们让Shiro程序到Redis查看是否存在缓存的<code>Token</code>，如果这个<code>Token</code>不存在于Redis里面，就说明用户的操作间隔了15天，需要重新登录。</p>
<p><strong>Token失效，但是缓存还存在的情况</strong></p>
<p>如果Redis中存在缓存的<code>Token</code>，说明当前<code>Token</code>失效后，间隔时间还没有超过15天，不应该让用户重新登录。所以要生成新的<code>Token</code>返回给客户端，并且把这个<code>Token</code>缓存到Redis里面，这种操作成为刷新<code>Token</code>过期时间。</p>
<h3 id="客户端如何更新令牌？"><a href="#客户端如何更新令牌？" class="headerlink" title="客户端如何更新令牌？"></a>客户端如何更新令牌？</h3><p>在我们的方案中，服务端刷新<code>Token</code>过期时间，其实就是生成一个新的<code>Token</code>给客户端。那么客户端怎么知道这次响应带回来的Token是更新过的呢？这个问题很容易解决。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/604388be09c7fd5520570382.jpg" alt="img"></p>
<p>只要用户成功登陆系统，当后端服务器更新<code>Token</code>的时候，就在响应中添加<code>Token</code>。客户端那边判断每次Ajax响应里面是否包含<code>Token</code>，如果包含，就把<code>Token</code>保存起来就可以了。</p>
<h3 id="如何在响应中添加令牌？"><a href="#如何在响应中添加令牌？" class="headerlink" title="如何在响应中添加令牌？"></a>如何在响应中添加令牌？</h3><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/604388d2095c736a14600633.jpg" alt="img"></p>
<p>我们定义<code>OAuth2Filter</code>类拦截所有的HTTP请求，一方面它会把请求中的<code>Token</code>字符串提取出来，封装成对象交给Shiro框架；另一方面，它会检查<code>Token</code>的有效性。如果<code>Token</code>过期，那么会生成新的<code>Token</code>，分别存储在<code>ThreadLocalToken</code>和<code>Redis</code>中。</p>
<p>之所以要把<code>新令牌</code>保存到<code>ThreadLocalToken</code>里面，是因为要向<code>AOP切面类</code>传递这个<code>新令牌</code>。虽然<code>OAuth2Filter</code>中有<code>doFilterInternal()</code>方法，我们可以得到响应并且写入<code>新令牌</code>。但是这个做非常麻烦，首先我们要通过IO流读取响应中的数据，然后还要把数据解析成JSON对象，最后再放入这个新令牌。如果我们定义了<code>AOP切面类</code>，拦截所有Web方法返回的<code>R对象</code>，然后在<code>R对象</code>里面添加<code>新令牌</code>，这多简单啊。但是<code>OAuth2Filter</code>和<code>AOP</code>切面类之间没有调用关系，所以我们很难把<code>新令牌</code>传给<code>AOP切面类</code>。</p>
<p>这里我想到了<code>ThreadLocal</code>，只要是同一个线程，往<code>ThreadLocal</code>里面写入数据和读取数据是完全相同的。在Web项目中，从<code>OAuth2Filter</code>到<code>AOP切面类</code>，都是由同一个线程来执行的，中途不会更换线程。所以我们可以放心的把新令牌保存都在<code>ThreadLocal</code>里面，<code>AOP切面类</code>可以成功的取出新令牌，然后往<code>R对象</code>里面添加新令牌即可。</p>
<p><code>ThreadLocalToken</code>是我自定义的类，里面包含了<code>ThreadLocal</code>类型的变量，可以用来保存线程安全的数据，而且避免了使用线程锁。</p>
<h3 id="创建ThreadLocal类"><a href="#创建ThreadLocal类" class="headerlink" title="创建ThreadLocal类"></a>创建ThreadLocal类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; local=<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToken</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        local.set(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> local.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        local.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建OAuth2Filter类"><a href="#创建OAuth2Filter类" class="headerlink" title="创建OAuth2Filter类"></a>创建<code>OAuth2Filter</code>类</h3><p>在创建过滤器的时候，首先应该判断哪些请求应该被<code>Shiro</code>框架处理，如果是<code>options</code>请求则直接放行，其余的所有请求都要被<code>Shiro</code>处理，在客户端提交请求的时候，如果数据是<code>application/json</code>数据，那么这个请求会被分成<code>options</code>和<code>post</code>两次请求，<code>options</code>请求只是一个试探性的请求，试探一下服务器是否支持，请求中不携带数据，如果服务器支持，那么就会继续发送<code>post</code>请求，这时候才会被<code>Shiro</code>处理。然后过滤器会判断一下<code>Token</code>是否过期，是真过期还是假过期，从请求头中提取中<code>Token</code>字符串，如果是真过期，那么就返回提示信息，让用户重新登录；如果是假过期，后端就生成新的令牌，刷新令牌，返回给客户端。最后就是把新令牌保存起来，同时保存到ThreadLocalToken和Reids。</p>
<blockquote>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>因为在<code>OAuth2Filter</code>类中要读写<code>ThreadLocal</code>中的数据，所以<code>OAuth2Filter</code>类必须要设置成多例的，否则<code>ThreadLocal</code>将无法使用。</p>
</blockquote>
<p>在配置文件中，添加JWT需要用到的密钥、过期时间和缓存过期时间。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">emos:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="comment">#密钥</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">abc123456</span></span><br><span class="line">    <span class="comment">#令牌过期时间（天）</span></span><br><span class="line">    <span class="attr">expire:</span>  <span class="number">5</span></span><br><span class="line">    <span class="comment">#令牌缓存时间（天数）</span></span><br><span class="line">    <span class="attr">cache-expire:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>在<code>com.example.emos.wx.config.shiro</code>中创建<code>OAuth2Filter</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.emos.wx.config.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.TokenExpiredException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.filter.authc.AuthenticatingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuth2Filter</span> <span class="keyword">extends</span> <span class="title class_">AuthenticatingFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocalToken threadLocalToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;emos.jwt.cache-expire&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cacheExpire;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 拦截请求之后，用于把令牌字符串封装成令牌对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取请求token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getRequestToken((HttpServletRequest) request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OAuth2Token</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 拦截请求，判断请求是否需要被Shiro处理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// Ajax提交application/json数据的时候，会先发出Options请求</span></span><br><span class="line">		<span class="comment">// 这里要放行Options请求，不需要Shiro处理</span></span><br><span class="line">		<span class="keyword">if</span> (req.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 除了Options请求之外，所有请求都要被Shiro处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该方法用于处理所有应该被Shiro处理的请求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">		resp.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">		<span class="comment">//允许跨域请求</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, req.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line"></span><br><span class="line">		threadLocalToken.clear();</span><br><span class="line">        <span class="comment">//获取请求token，如果token不存在，直接返回401</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getRequestToken((HttpServletRequest) request);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            resp.getWriter().print(<span class="string">&quot;无效的令牌&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jwtUtil.verifierToken(token); <span class="comment">//检查令牌是否过期</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">            <span class="comment">//客户端令牌过期，查询Redis中是否存在令牌，如果存在令牌就重新生成一个令牌给客户端</span></span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.hasKey(token)) &#123;</span><br><span class="line">                redisTemplate.delete(token);<span class="comment">//删除令牌</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> jwtUtil.getUserId(token);</span><br><span class="line">                token = jwtUtil.createToken(userId);  <span class="comment">//生成新的令牌</span></span><br><span class="line">                <span class="comment">//把新的令牌保存到Redis中</span></span><br><span class="line">                redisTemplate.opsForValue().set(token, userId + <span class="string">&quot;&quot;</span>, cacheExpire, TimeUnit.DAYS);</span><br><span class="line">                <span class="comment">//把新令牌绑定到线程</span></span><br><span class="line">                threadLocalToken.setToken(token);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果Redis不存在令牌，让用户重新登录</span></span><br><span class="line">                resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">                resp.getWriter().print(<span class="string">&quot;令牌已经过期&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">            resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            resp.getWriter().print(<span class="string">&quot;无效的令牌&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> executeLogin(request, response);</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginFailure</span><span class="params">(AuthenticationToken token,</span></span><br><span class="line"><span class="params">		AuthenticationException e, ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, req.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp.getWriter().print(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求头里面的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getRequestToken</span><span class="params">(HttpServletRequest httpRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//从header中获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> httpRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果header中不存在token，则从参数中获取token</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            token = httpRequest.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doFilterInternal(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>如何迁移Hexo博客到新电脑</title>
    <url>/posts/35875.html</url>
    <content><![CDATA[<p>换了台笔记本，懒得迁移博客，拖了好久还是做了一下迁移，记录一下过程，方便以后查看。<br><span id="more"></span></p>
<h1 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h1><p>安装<code>git</code>,<code>node.js</code></p>
<h1 id="选择文件"><a href="#选择文件" class="headerlink" title="选择文件"></a>选择文件</h1><p>从之前的博客文件夹中选择必须要拷贝的文件，备份起来。首先是之前自己修改的文件，像配置文件<code>_config.yml,theme</code>文件夹，<code>source</code>文件夹自己写的原始文件这些都是必须要拷贝走的。除此之外还有<code>scaffolds</code>文件夹(文件的模板)，<code>package.json</code>(使用哪些包)，<code>.gitignore</code>(提交忽略哪些文件夹)<br>总结：     </p>
<ul>
<li>_config.yml</li>
<li>themes</li>
<li>source</li>
<li>scaffolds</li>
<li>package.json</li>
<li>.gitignore<br>是需要备份的，其他文件不需要管。<h1 id="开始迁移"><a href="#开始迁移" class="headerlink" title="开始迁移"></a>开始迁移</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局安装hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">// 把必须拷贝的文件，拷贝到新建的文件夹内，执行以下命令</span><br><span class="line">// 在新建的文件夹内打开命令行，安装必要的模块，初始化</span><br><span class="line">// 这里不用hexo init初始化，因为配置文件我们已经拷贝过来</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">// 安装其他一些必要的组件</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<h1 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//先本地预览</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">//此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功</span><br></pre></td></tr></table></figure>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2>在你的博客文件夹中打开git bash,复制一下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
内容换成你自己的Github用户名和邮箱。<br>执行一下两条指令，检查你有没有输入正确。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
<p>然后创建SSH,一路回车<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><br>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。<br>ssh，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p>
<p>而后在GitHub的setting中，找到<code>SSH and GPC keys</code>的设置选项，点击<code>New SSH key</code><br>把你的<code>id_rsa.pub</code>里面的信息复制进去,title随便填写。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正式部署</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/42877.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>前提：有已排序数组 A（假设已经做好）</li>
<li>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</li>
<li>获取中间索引 M = Floor((L+R) /2)</li>
</ol>
<span id="more"></span>
<ol>
<li>中间索引的值  A[M] 与待搜索的值 T 进行比较</li>
</ol>
<p>​         ① A[M] == T 表示找到，返回中间索引</p>
<p>​         ② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p>
<p>​         ③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p>
<ol>
<li>当 L &gt; R 时，表示没有找到，应结束循环</li>
</ol>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决整数溢出问题</strong></p>
<p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>还有一种是移位，右移1位，相当<code>l + r</code> 的值除以2取整，且效率相比除法更高：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>其它考法</strong></p>
<ol>
<li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p>
</li>
<li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p>
</li>
<li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p>
</li>
</ol>
<p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20211103205108420.png" alt="image-20211103205108420"></p>
<p>其中 n 为查找次数，N 为元素个数</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/posts/11306.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>每一轮排序选择一个基准点（pivot）进行分区<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
<li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li>
</ol>
<span id="more"></span>
<p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p>
<ol>
<li><p>选择最右元素作为基准点元素</p>
</li>
<li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p>
</li>
<li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p>
</li>
<li><p>最后基准点与 i 交换，i 即为分区位置</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p>
<ol>
<li>选择最左元素作为基准点元素</li>
<li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li>
<li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li>
</ol>
<p>要点</p>
<ol>
<li><p>基准点在左边，并且要先 j 后 i</p>
</li>
<li><p>while( ==<strong>i</strong> <strong>&lt; j</strong>== &amp;&amp; a[j] &gt; pv ) j— </p>
</li>
<li>while ( ==<strong>i</strong> <strong>&lt; j</strong>== &amp;&amp; a[i] ==<strong>&lt;=</strong>== pv ) i++</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快排特点</strong></p>
<ol>
<li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p>
</li>
<li><p>数据量较大时，优势非常明显</p>
</li>
<li><p>属于不稳定排序</p>
</li>
</ol>
<p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p>
<ul>
<li>霍尔的移动次数平均来讲比洛穆托少3倍</li>
<li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私应用与展望</title>
    <url>/posts/40615.html</url>
    <content><![CDATA[<p>如何设计一个满足差分隐私的算法？</p>
<blockquote>
<p>一般做法：从一个不满足差分隐私的算法出发，往算法里适当地加入一定噪音，以使其输出满足差分隐私的要求。    </p>
</blockquote>
<span id="more"></span>
<h2 id="拉普拉斯机制"><a href="#拉普拉斯机制" class="headerlink" title="拉普拉斯机制"></a>拉普拉斯机制</h2><p>假设我们有一个病患数据集D，考虑以下数据库查询：<img src="https://img.imgdb.cn/item/6000fe873ffa7d37b316de43.png" alt=""></p>
<p>如果我们要发布这个查询结果，如何才能满足$\epsilon$-差分隐私？</p>
<p>我们首先考虑这个查询结果有多依赖于某个特定病人的信息，如果我们修改D中任意一个病患的数据，上述查询结果最多会改变1，所以我们能用噪声来“掩盖”这种不大于1的改变，就能满足差分隐私。具体来说，我们可以往查询结果中加入一个服从拉普拉斯分布的噪声。<img src="https://img.imgdb.cn/item/6001001a3ffa7d37b31775db.jpg" alt=""></p>
<p>参数$\lambda$设为$\frac{1}{\epsilon}$，即能满足$\epsilon$-差分隐私。</p>
<p>如果要发布的结果是下面这个查询结果呢？<img src="https://img.imgdb.cn/item/600101213ffa7d37b317f01b.jpg" alt=""></p>
<p>首先，我们修改一个病患的数据，则上述查询结果最多改变3，我们可以对其加入拉普拉斯噪声，并把参数</p>
<p>$\lambda$设为$\frac{3}{\epsilon}$，<img src="https://img.imgdb.cn/item/6001001a3ffa7d37b31775db.jpg" alt=""></p>
<blockquote>
<p>一般而言，如果我们要发布一组数值型查询结果，我们可以对每个结果加入独立的拉普拉斯噪声来满足差分隐私。</p>
<p>噪声参数$\lambda$取决于当我们修改一个人的数据时，查询结果<strong>总会</strong>改变多少。一组查询总共的“最大改变”被称为他们的<strong>敏感度</strong>，取$\lambda$=敏感度/$\epsilon$即能满足$\epsilon$-差分隐私。</p>
</blockquote>
<h2 id="随机化回答"><a href="#随机化回答" class="headerlink" title="随机化回答"></a>随机化回答</h2><p>如果我们要发布的数据不是数值型的话，我们可以用其他方法引入噪声，下面介绍一种数据采集的简单机制：随机化回答。</p>
<p>假设我向一组人提问一个敏感的是非题，出于隐私，有的人可能不愿意给真实答案，解决方案是让每个人在他的答案中加入噪声。<img src="https://img.imgdb.cn/item/600104713ffa7d37b319597d.jpg" alt=""></p>
<p><img src="https://img.imgdb.cn/item/600104903ffa7d37b3196a6c.jpg" alt=""></p>
<p>随机化回答可以满足$\epsilon$-差分隐私，直观原因是：由于其随机性，攻击者不能中随机化的输出反推出输入到底是“yes”还是“no”,只要根据$\epsilon$来调整随机化的概率即可。但是我们依然可以通过随机化回答的输出来回答如下问题：</p>
<p>大概有多少人的真实回答是“yes”?</p>
<p>假设有10000人用随机化回答给了我回复</p>
<ul>
<li>当中有5500个yes和4500个no</li>
</ul>
<p>每个人以80%概率给我假回复</p>
<ul>
<li>所以大致中共有8000个假回复</li>
<li>当中大致上有4000个假yes和4000个假no</li>
</ul>
<p>据此，我可以判断剩下的真实回答里大概有1500个yes和500个no</p>
<ul>
<li>所以大概75%的人的真实回答是yes</li>
</ul>
<p><img src="https://img.imgdb.cn/item/600106bd3ffa7d37b31a7115.jpg" alt=""></p>
<p>总结：</p>
<ul>
<li>通过随机修改回复来满足差分隐私</li>
<li>由于修改时引入的噪声分布已知，因此我们扔可以反推出源数据的大致分布</li>
<li>但无法反推出个体回复</li>
</ul>
<h2 id="差分隐私数据库"><a href="#差分隐私数据库" class="headerlink" title="差分隐私数据库"></a>差分隐私数据库</h2><p><img src="https://img.imgdb.cn/item/600107b13ffa7d37b31ad2c3.jpg" alt=""></p>
<ul>
<li>只回答聚合查询的结果</li>
<li>通过往查询结果中加入噪声来满足差分隐私</li>
<li>例子：微软的PINQ,Uber的Chorus</li>
</ul>
<p>技术难点：</p>
<ul>
<li>如何用尽量少的噪声来达到$\epsilon$-差分隐私<ul>
<li>尤其是在查询需要连接多张数据库表的时候</li>
</ul>
</li>
<li>如何高效地计算查询的敏感度</li>
<li>如何将差分隐私模块整合到现有数据库中</li>
</ul>
<p>展望：</p>
<p>现有算法尚未能在隐私保护、查询准确性及计算效率三者间取得很好的平衡，例如：Uber的Chrous在不少查询中误差可达100%以上</p>
<h2 id="差分隐私机器学习"><a href="#差分隐私机器学习" class="headerlink" title="差分隐私机器学习"></a>差分隐私机器学习</h2><p><img src="https://img.imgdb.cn/item/600108bc3ffa7d37b31b519f.jpg" alt=""></p>
<ul>
<li><p>在机器学习算法中引入噪声，使得算法生成的模型能满足差分隐私</p>
</li>
<li><p>例子：谷歌的TensorFlow Privacy</p>
<p><a href="https://github.com/tensorflow/privacy">https://github.com/tensorflow/privacy</a></p>
<p>可用于神经网络训练</p>
</li>
</ul>
<h3 id="TensorFlow-Privacy的基本原理"><a href="#TensorFlow-Privacy的基本原理" class="headerlink" title="TensorFlow Privacy的基本原理"></a>TensorFlow Privacy的基本原理</h3><p>神经网络通常是用随机梯度下降来进行训练的：</p>
<ol>
<li>从一组随机的神经网络权重参数出发</li>
<li>拿一组随机选取的元组来计算权重的梯度</li>
<li>用梯度来更新权重参数</li>
<li>重复步骤2-3</li>
</ol>
<p>TensorFlow Privacy对步骤2中的梯度加入噪声，以保证训练过程满足差分隐私。</p>
<p>关于差分隐私机器学习，现有算法的不足：</p>
<ul>
<li>准确性还有待 提高</li>
<li>尚不能很好地处理复杂模型，如GAN</li>
</ul>
<p>另有一些新方向，如：</p>
<ul>
<li>联邦学习</li>
<li>与安全多方计算的结合</li>
</ul>
<h2 id="差分隐私数据采集"><a href="#差分隐私数据采集" class="headerlink" title="差分隐私数据采集"></a>差分隐私数据采集</h2><p><img src="https://img.imgdb.cn/item/60010a903ffa7d37b31c58e3.jpg" alt=""></p>
<p>场景：从移动设备中采集用户数据，入应用程序的使用时长等</p>
<p>为满足差分隐私，让用户采用类似于随机化回答 的方法来提供数据</p>
<p>例子：谷歌Chrome、苹果iPhone、iPad和Mac、微软Windows10</p>
<p>技术难点：需要采集的数据可能比较复杂，无法用传统随机化回答问题</p>
<ul>
<li>例子：用户输入的新词（字典里面没有的）</li>
</ul>
<p>为此，谷歌，苹果和微软都因其采集需要提出了新的随机化算法</p>
<p>现有不足：</p>
<ul>
<li>现有算法要求每个用户对其数据加入相当程度的噪声</li>
<li>这对后期估计统计数据带来了一些困难</li>
</ul>
<p>近年来大家开始探索的新方向：</p>
<ul>
<li>与安全计算相结合，以减少满足差分隐私所需的噪声</li>
</ul>
<h2 id="差分隐私数据合成"><a href="#差分隐私数据合成" class="headerlink" title="差分隐私数据合成"></a>差分隐私数据合成</h2><p><img src="https://img.imgdb.cn/item/6001175e3ffa7d37b324e1e1.jpg" alt=""></p>
<p>基本原理：</p>
<ul>
<li>先对源数据进行建模，得到一个统计模型</li>
<li>用统计模型来合成出虚拟产品</li>
</ul>
<p>例子：美国普查局的一些数据产品，如<a href="https://onthemap.ces.census.gov/">https://onthemap.ces.census.gov/</a></p>
<p>技术难点：</p>
<ul>
<li>如何找到一个合适的统计模型？</li>
<li>如何在统计模型中加入噪声，以满足差分隐私？</li>
</ul>
<p>现有不足：</p>
<ul>
<li>目前的算法只能处理关系型数据</li>
<li>对非关系型数据的合成基本上还在摸索阶段，如图数据、文本数据等</li>
</ul>
<h2 id="展望：弥补差分隐私本身的不足"><a href="#展望：弥补差分隐私本身的不足" class="headerlink" title="展望：弥补差分隐私本身的不足"></a>展望：弥补差分隐私本身的不足</h2><ul>
<li>如何设计一个更加贴近实际的隐私模型</li>
<li>现有文献中已有不少改进差分隐私的尝试，但尚未得到广泛应用，原因：改进后的模型往往过于复杂，难以被大众所认同</li>
<li>差分隐私虽然有着优雅的数学表达，但并不直接对应任何法律条文<ul>
<li>满足差分隐私不等于满足隐私保护法律</li>
</ul>
</li>
<li>要解决这一问题，需要计算机界与法律界相互合作</li>
<li>近来已有学者尝试中法律条文出发来设计隐私保护模型，并借鉴差分隐私的思想</li>
</ul>
]]></content>
      <categories>
        <category>差分隐私</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>抵御跨站脚本(XSS)攻击</title>
    <url>/posts/8078.html</url>
    <content><![CDATA[<h2 id="一、XSS攻击的危害"><a href="#一、XSS攻击的危害" class="headerlink" title="一、XSS攻击的危害"></a>一、XSS攻击的危害</h2><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<span id="more"></span>
<p>例如用户在发帖或者注册的时候，在文本框中输入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，这段代码如果不经过转义处理，而直接保存到数据库。将来视图层渲染HTML的时候，把这段代码输出到页面上，那么<code>&lt;script&gt;</code>标签的内容就会被执行。</p>
<p>通常情况下，我们登陆到某个网站。如果网站使用<code>HttpSession</code>保存登陆凭证，那么<code>SessionId</code>会以<code>Cookie</code>的形式保存在浏览器上。如果黑客在这个网页发帖的时候，填写的<code>JavaScript</code>代码是用来获取<code>Cookie</code>内容的，并且把<code>Cookie</code>内容通过Ajax发送给黑客自己的电脑。于是只要有人在这个网站上浏览黑客发的帖子，那么视图层渲染HTML页面，就会执行注入的XSS脚本，于是你的<code>Cookie</code>信息就泄露了。黑客在自己的电脑上构建出<code>Cookie</code>，就可以冒充已经登陆的用户。</p>
<p>即便很多网站使用了JWT，登陆凭证（<code>Token令牌</code>）是存储在浏览器上面的。所以用XSS脚本可以轻松的从Storage中提取出<code>Token</code>，黑客依然可以轻松的冒充已经登陆的用户。</p>
<p>所以避免XSS攻击最有效的办法就是对用户输入的数据进行转义，然后存储到数据库里面。等到视图层渲染HTML页面的时候。转义后的文字是不会被当做JavaScript执行的，这就可以抵御XSS攻击。</p>
<h2 id="二、导入依赖库"><a href="#二、导入依赖库" class="headerlink" title="二、导入依赖库"></a>二、导入依赖库</h2><p>因为<code>Hutool</code>工具包带有XSS转义的工具类，所以我们要导入<code>Hutool</code>，然后利用<code>Servlet</code>规范提供的请求包装类，定义数据转义功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="三、定义请求包装类"><a href="#三、定义请求包装类" class="headerlink" title="三、定义请求包装类"></a>三、定义请求包装类</h2><p>我们平时写Web项目遇到的<code>HttpServletRequest</code>，它其实是个接口。如果我们想要重新定义请求类，扩展这个接口是最不应该的。因为<code>HttpServletRequest</code>接口中抽象方法太多了，我们逐一实现起来太耗费时间。所以我们应该挑选一个简单一点的自定义请求类的方式。那就是继承<code>HttpServletRequestWrapper</code>父类。</p>
<p>JavaEE只是一个标准，具体的实现由各家应用服务器厂商来完成。比如说<code>Tomcat</code>在实现<code>Servlet</code>规范的时候，就自定义了<code>HttpServletRequest</code>接口的实现类。同时JavaEE规范还定义了<code>HttpServletRequestWrapper</code>，这个类是请求类的包装类，用上了装饰器模式。不得不说这里用到的设计模式真的非常棒，无论各家应用服务器厂商怎么去实现<code>HttpServletRequest</code>接口，用户想要自定义请求，只需要继承<code>HttpServletRequestWrapper</code>，对应覆盖某个方法即可，然后把请求传入请求包装类，装饰器模式就会替代请求对象中对应的某个方法。用户的代码和服务器厂商的代码完全解耦，我们不用关心<code>HttpServletRequest</code>接口是怎么实现的，借助于包装类我们可以随意修改请求中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.http.HtmlUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ReadListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XssHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类定义一个构造器接收传入的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XssHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.getParameter(name);</span><br><span class="line">        <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">            <span class="comment">//将数据进行转义</span></span><br><span class="line">            value = HtmlUtil.filter(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        String[] values = <span class="built_in">super</span>.getParameterValues(name);</span><br><span class="line">        <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">                <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">                    value = HtmlUtil.filter(value);</span><br><span class="line">                &#125;</span><br><span class="line">                values[i] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameters = <span class="built_in">super</span>.getParameterMap();</span><br><span class="line">        Map&lt;String, String[]&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String key : parameters.keySet()) &#123;</span><br><span class="line">                String[] values = parameters.get(key);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">                    <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">                        value = HtmlUtil.filter(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    values[i] = value;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(key, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHeader</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.getHeader(name);</span><br><span class="line">        <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">            value = HtmlUtil.filter(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringMVC框架通过这个方法从请求里面提取客户端提交的数据，然后把这些数据封装到form对象里面，</span></span><br><span class="line"><span class="comment">     * 如果不对getInputStream()方法读取的数据做转义，那么后端项目就不具备抵御跨站脚本攻击的能力。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">super</span>.getInputStream();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> buffer.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            body.append(line);</span><br><span class="line">            line = buffer.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = JSONUtil.parseObj(body.toString());</span><br><span class="line">        Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(map.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (map.get(key) <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                resultMap.put(key, HtmlUtil.filter(val.toString()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultMap.put(key, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSONUtil.toJsonStr(resultMap);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">bain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(str.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> bain.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener listener)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、创建过滤器，把所有请求对象传入包装类"><a href="#四、创建过滤器，把所有请求对象传入包装类" class="headerlink" title="四、创建过滤器，把所有请求对象传入包装类"></a>四、创建过滤器，把所有请求对象传入包装类</h2><p>为了让刚刚定义的包装类生效，我们还要在请求包装类的所在目录下中创建<code>XssFilter</code>过滤器。过滤器拦截所有请求，然后把请求传入包装类，这样包装类就能覆盖所有请求的参数方法，用户从请求中获得数据，全都经过转义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XssFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">XssHttpServletRequestWrapper</span> <span class="variable">xssRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XssHttpServletRequestWrapper</span>(</span><br><span class="line">                (HttpServletRequest) request);</span><br><span class="line">        chain.doFilter(xssRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、给启动类添加注解"><a href="#五、给启动类添加注解" class="headerlink" title="五、给启动类添加注解"></a>五、给启动类添加注解</h2><p>给SpringBoot启动类添加<code>@ServletComponentScan</code>注解。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/posts/50190.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<span id="more"></span>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//退出排序，减少比较次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与选择排序比较</strong></p>
<ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$</p>
</li>
<li><p>大部分情况下，插入都略优于选择</p>
</li>
<li><p>有序集合插入的时间复杂度为 $O(n)$</p>
</li>
<li><p>插入属于稳定排序算法，而选择属于不稳定排序</p>
</li>
</ol>
<p><strong>提示</strong></p>
<blockquote>
<p><em>插入排序通常被轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私基础</title>
    <url>/posts/9305.html</url>
    <content><![CDATA[<p>数据的隐私保护问题最早由统计学家Dalenius 在20世纪70年代末提出，他认为，保护数据库中的隐私信息，就是要使任何用户（包括合法用户和潜在的攻击者）在访问数据库的过程中无法获取关于任意个体的确切信息 。</p>
<span id="more"></span>
<p>从已有的研究来看，k-anonymity及其扩展模型在隐私保护领域影响深远且被广泛应用。这些模 型的基本思想是将数据集里与攻击者背景知识相关的属性定义为准标识符，通过对记录的准标识符值进行泛化、压缩处理，使得所有记录被划分到若干个等价类（Equivalence Group）,每个等价类中的记录具有相同 的准标识符，从而实现将一个记录隐藏在一组记录中。因此，这类模型也被称为基于分组的隐私保护模型。</p>
<p>差分隐私是Dwork在2006年针对统计数据库的隐私泄露问题提出的一种新的隐私定义。在此定义下，对数据集的计算处理结果对于具体某个记录的变化是不敏感的，单个记录在数据集中或者不在数据集中，对计算结果的影响微乎其微。所以，一 个记录因其加入到数据集中所产生的隐私泄露风险被控制在极小的、可接受的范围内，攻击者无法通过观察计算结果而获取准确的个体信息。</p>
<p>差分隐私保护模型的思想源自于一个很朴素的观察：<strong>当数据集 Ｄ 中包含个体 Alice时，设 对 Ｄ 进行任意查询操作f（例如计数、求和、平均值、中位数 或其它范围查询等）所得到的结果为ｆ(Ｄ），如果将 Alice的信息从 Ｄ 中删除后进行查询得到的结果仍然为ｆ（Ｄ），则可以认为，Alice的信息并没有因为被包含在数据集 Ｄ 中而产生额外的风险。差分隐私保护就是要保证任一个体在数据集中或者不在数据 集中时，对最终发布的查询结果几乎没有影响。具体地说，设有两个几乎完全相同的数据集（两者的区别仅在于一个记录不同），分别对这两个数据集进行查 询访问，同一查询在两个数据集上产生同一结果的概率的比值接近于１。</strong></p>
<h2 id="差分隐私定义"><a href="#差分隐私定义" class="headerlink" title="差分隐私定义"></a>差分隐私定义</h2><p><img src="https://img.imgdb.cn/item/600153e13ffa7d37b34644c5.jpg" alt=""></p>
<p><img src="https://img.imgdb.cn/item/600155113ffa7d37b346de19.jpg"  /></p>
<h3 id="隐私保护预算"><a href="#隐私保护预算" class="headerlink" title="隐私保护预算"></a>隐私保护预算</h3><p>隐私保护预算$\epsilon$用来控制算法M在两个相邻数据集上获得相同输出的概率比值，它事实上体现了M所能够提供的隐私保护水平。实际应用中，$\epsilon$的取值很小，例如0.01,0.1，或者ln2,ln3等，$\epsilon$越小，表示隐私保护水平越高。当$\epsilon$为0时，表示对于任意临近数据集，算法都将输出两个概率分布完全相同的结果，这些结果也不能反映出任何关于数据集的有用的信息。因此，$\epsilon$的取值要考虑到安全性和可用性之间的平衡。</p>
<h3 id="敏感度"><a href="#敏感度" class="headerlink" title="敏感度"></a>敏感度</h3><p>敏感度是决定加入噪声大小的关键参数，它指删除数据集中任一记录对查询结果造成的<strong>最大改变</strong>。差分隐私中定义了两种敏感度，即<strong>全局敏感度</strong>和<strong>局部敏感度</strong>。</p>
<p><img src="https://img.imgdb.cn/item/600159893ffa7d37b349a7f5.jpg" alt=""></p>
<p>函数的全局敏感度由函数本身决定，不同的函数会有不同的全局敏感度。一些函数的全局敏感度较小，因此只需要加入少量的噪声即可掩盖因一个记录被删除对查询结果所产生的的影响。但某些函数的全局敏感度较大，必须在函数输出中添加足够大的噪声才能保证隐私安全，导致数据可用性较差。因此提出了<strong>局部敏感度</strong>的概念。</p>
<p><img src="https://img.imgdb.cn/item/60015bc43ffa7d37b34af6b4.jpg" alt=""></p>
<p><img src="https://img.imgdb.cn/item/60015bf33ffa7d37b34b0fa2.jpg" alt=""></p>
<p>但是，局部敏感度在一定程度上体现了数据集的数据分布特征，如果直接应用局部敏感度来计算噪声量则会泄露数据集中的敏感信息，因此局部敏感度的<strong>平滑上界</strong>被用来与局部敏感度一起确定噪声量的大小。</p>
<p><img src="https://img.imgdb.cn/item/6001614c3ffa7d37b34dc624.jpg" alt=""></p>
<p>所有满足这一定义的函数都可被定义为平滑上界，将局部敏感度带入到此函数中可得到<strong>平滑敏感度</strong>，进而用于计算噪声大小。</p>
<p><img src="https://img.imgdb.cn/item/600163743ffa7d37b34ed27d.jpg" alt=""></p>
<p>由于绝大部分关于差分隐私保护的研究均针对计数查询、求和查询等敏感度较小的函数，因此，若无特殊说明，本文中敏感度均指全局敏感度。</p>
<h2 id="差分隐私的组合性质"><a href="#差分隐私的组合性质" class="headerlink" title="差分隐私的组合性质"></a>差分隐私的组合性质</h2><p>一个复杂的隐私保护问题通常需要多次应用差分隐私才能解决。在这种情况下，为了保证整个过程的隐私保护水平控制在给定的预算$\epsilon$之内，需要合理地将全部预算分配到整个算法的各个步骤中。这时可以利用隐私保护算法的两个组合性质：</p>
<p><img src="https://img.imgdb.cn/item/60023e303ffa7d37b3ac3e30.jpg" alt=""></p>
<p><img src="https://img.imgdb.cn/item/60023e8b3ffa7d37b3ac582b.jpg" style="zoom: 67%;" /></p>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>为了使一个算法满足差分隐私保护的要求，对不同的问题有不同的实现方法，这些实现方法称为“机制”。<strong>拉普拉斯机制</strong>和<strong>指数机制</strong>是两种最基础的差分隐私保护机制。其中，<strong>拉普拉斯机制适用于对数值型结果的保护，指数机制适用于非数值型结果。</strong></p>
<h3 id="Laplace机制"><a href="#Laplace机制" class="headerlink" title="Laplace机制"></a>Laplace机制</h3><p>Laplace机制通过向确切的查询结果中加入服从Laplace分布的随机噪声来实现$\epsilon$-差分隐私保护。记位置参数为0、尺度参数为b的Laplace分布为<strong>Lap(b)</strong>，那么其概率密度函数为</p>
<p><img src="https://img.imgdb.cn/item/600240b93ffa7d37b3acfe3f.jpg" alt=""></p>
<p><img src="https://img.imgdb.cn/item/600241823ffa7d37b3ad3c91.jpg" style="zoom:67%;" /></p>
<p>噪声（尺度）参数b取决于当我们修改一个人的数据时，查询结果<strong>总会</strong>改变多少。一组查询总共的“最大改变”被称为他们的<strong>敏感度</strong>，取b=敏感度/$\epsilon$即能满足$\epsilon$-差分隐私。</p>
<h3 id="指数机制"><a href="#指数机制" class="headerlink" title="指数机制"></a>指数机制</h3><p>指数机制适用于非数值型的数据，设查询函数的输出域为$Range$,域中的每个值$r\in Range$为一个实体对象，在指数机制下，函数$q(D,r)\rightarrow R$称为输出值$r$的可用性函数，用来评估输出值$r$的优劣程度。</p>
<p><img src="https://img.imgdb.cn/item/600245b43ffa7d37b3aeb3db.jpg" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>差分隐私</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之双指针法</title>
    <url>/posts/36720.html</url>
    <content><![CDATA[<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。例如<a href="https://leetcode-cn.com/problems/remove-element/">27.移除元素</a></p>
<span id="more"></span>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p>
</blockquote>
<p>这道题目可以使用暴力破解的方法，通过两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组，不过时间复杂度是O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; ++j)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                --length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要降低时间复杂度为O(n),可以使用双指针法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;fastIndex &lt; nums.length; ++fastIndex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex]!=val)&#123;</span><br><span class="line">                nums[lowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/posts/51203.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<span id="more"></span>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li>
</ul>
<p><strong>与冒泡排序比较</strong></p>
<ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$ </p>
</li>
<li><p>选择排序一般要快于冒泡，因为其交换次数少</p>
</li>
<li><p>但如果集合有序度高，冒泡优于选择</p>
</li>
<li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p>
<ul>
<li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li>
<li>不稳定排序则反之</li>
</ul>
</li>
</ol>
<p><strong>稳定排序与不稳定排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure>
<p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p>
<ul>
<li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure>
<p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p>
</li>
<li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java注解</title>
    <url>/posts/Annotation.html</url>
    <content><![CDATA[<h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p>
<ul>
<li><strong>Java自带的标准注解</strong>，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>，<code>@Retention</code>用于标明注解被保留的阶段，<code>@Target</code>用于标明注解使用的范围，<code>@Inherited</code>用于标明注解可继承，<code>@Documented</code>用于标明是否生成javadoc文档。</li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<h3 id="注解的形式"><a href="#注解的形式" class="headerlink" title="注解的形式"></a>注解的形式</h3><p>Java 中，注解是以 <code>@</code> 字符开始的修饰符。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mySuperMethod</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注解可以包含命名或未命名的属性，并且这些属性有值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author(</span></span><br><span class="line"><span class="meta">   name = &quot;Benjamin Franklin&quot;,</span></span><br><span class="line"><span class="meta">   date = &quot;3/27/2003&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个名为 value 的属性，那么名称可以省略，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果注解没有属性，则称为<code>标记注解</code>。如：<code>@Override</code>。</p>
<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>从本质上来说，<strong>注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。</strong></p>
<p>解析一个注解往往有两种形式：</p>
<ul>
<li><strong>编译期直接的扫描</strong> - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。</li>
<li><strong>运行期的反射</strong> - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。</li>
</ul>
<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>注解有许多用途：</p>
<ul>
<li>编译器信息 - 编译器可以使用注解来检测错误或抑制警告。</li>
<li>编译时和部署时的处理 - 程序可以处理注解信息以生成代码，XML 文件等。</li>
<li>运行时处理 - 可以在运行时检查某些注解并处理。</li>
</ul>
<p>作为 Java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。</p>
<h3 id="注解的代价"><a href="#注解的代价" class="headerlink" title="注解的代价"></a>注解的代价</h3><p>凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：</p>
<ul>
<li>显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。</li>
<li>自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。</li>
<li>注解所产生的问题，相对而言，更难以 debug 或定位。</li>
</ul>
<p>但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。</p>
<h3 id="注解的应用范围"><a href="#注解的应用范围" class="headerlink" title="注解的应用范围"></a>注解的应用范围</h3><p>注解可以应用于类、字段、方法和其他程序元素的声明。</p>
<p>JDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：</p>
<p>类实例初始化表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="meta">@Interned</span> MyObject();</span><br></pre></td></tr></table></figure>
<p>类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myString = (<span class="meta">@NonNull</span> String) str;</span><br></pre></td></tr></table></figure>
<p>实现接口的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;T&gt; implements</span><br><span class="line">    <span class="meta">@Readonly</span> List&lt;<span class="meta">@Readonly</span> T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>抛出异常声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">monitorTemperature</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> <span class="meta">@Critical</span> TemperatureException &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>、<code>@SafeVarargs</code>（JDK7 引入）和<code>@FunctionalInterface</code>（JDK8 引入）：</p>
<ul>
<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>
<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>
<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>
<li><code>@SafeVarargs</code>：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用</li>
<li><code>@FunctionalInterface</code>：用于指示被修饰的接口是函数式接口</li>
</ul>
<p>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</p>
<h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html"><code>@Override</code></a>用于表明被修饰方法覆写了父类的方法。</strong></p>
<p>如果试图使用 <code>@Override</code> 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。</p>
<p>我们先来看一下这个注解类型的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p>
<p><code>@Override</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideAnnotationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;getName&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;override getName&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  放开下面的注释，编译时会告警</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public String getName2() &#123;</span></span><br><span class="line"><span class="comment">            return &quot;override getName2&quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        System.out.println(per.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p><strong><code>@Deprecated</code> 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</strong></p>
<p><code>@Deprecated</code> 有一定的<strong>延续性</strong>：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 <code>@Deprecated</code>，但编译器仍然会告警。</p>
<blockquote>
<p>🔔 注意： <code>@Deprecated</code> 这个注解类型和 javadoc 中的 <code>@deprecated</code> 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。</p>
</blockquote>
<p>这个注解的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p>
<p><code>@Deprecated</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeprecatedAnnotationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeprecatedField</span> &#123;</span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEPRECATED_FIELD</span> <span class="operator">=</span> <span class="string">&quot;DeprecatedField&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeprecatedMethod</span> &#123;</span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DeprecatedMethod&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeprecatedClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DeprecatedClass&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(DeprecatedField.DEPRECATED_FIELD);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeprecatedMethod</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeprecatedMethod</span>();</span><br><span class="line">        System.out.println(dm.print());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">DeprecatedClass</span> <span class="variable">dc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeprecatedClass</span>();</span><br><span class="line">        System.out.println(dc.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//DeprecatedField</span></span><br><span class="line"><span class="comment">//DeprecatedMethod</span></span><br><span class="line"><span class="comment">//DeprecatedClass</span></span><br></pre></td></tr></table></figure>
<h3 id="SuppressWarnnings"><a href="#SuppressWarnnings" class="headerlink" title="@SuppressWarnnings"></a>@SuppressWarnnings</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>用于关闭对类、方法、成员编译时产生的特定警告。</strong></p>
<p><code>@SuppressWarning</code> 不是一个标记注解。它有一个类型为 <code>String[]</code> 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 <code>-Xlint</code> 选项有效的警告名也同样对 <code>@SuppressWarings</code> 有效，同时编译器会忽略掉无法识别的警告名。</p>
<p>这个注解我们也比较常用到，先来看下它的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>原描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>抑制所有警告</td>
<td>to suppress all warnings</td>
</tr>
<tr>
<td>boxing</td>
<td>抑制装箱、拆箱操作时候的警告</td>
<td>to suppress warnings relative to boxing/unboxing operations</td>
</tr>
<tr>
<td>cast</td>
<td>抑制映射相关的警告</td>
<td>to suppress warnings relative to cast operations</td>
</tr>
<tr>
<td>dep-ann</td>
<td>抑制启用注释的警告</td>
<td>to suppress warnings relative to deprecated annotation</td>
</tr>
<tr>
<td>deprecation</td>
<td>使用了不赞成使用的类或方法时的警告</td>
<td>to suppress warnings relative to deprecation</td>
</tr>
<tr>
<td>fallthrough</td>
<td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告</td>
<td>to suppress warnings relative to missing breaks in switch statements</td>
</tr>
<tr>
<td>finally</td>
<td>任何 finally 子句不能正常完成时的警告</td>
<td>to suppress warnings relative to finally block that don’t return</td>
</tr>
<tr>
<td>hiding</td>
<td>抑制与隐藏变数的区域变数相关的警告</td>
<td>to suppress warnings relative to locals that hide variable（）</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td>忽略没有完整的switch语句</td>
<td>to suppress warnings relative to missing entries in a switch statement (enum case)</td>
</tr>
<tr>
<td>nls</td>
<td>忽略非nls格式的字符</td>
<td>to suppress warnings relative to non-nls string literals</td>
</tr>
<tr>
<td>null</td>
<td>忽略对null的操作</td>
<td>to suppress warnings relative to null analysis</td>
</tr>
<tr>
<td>rawtype</td>
<td>使用generics时忽略没有指定相应的类型</td>
<td>to suppress warnings relative to un-specific types when using</td>
</tr>
<tr>
<td>restriction</td>
<td>抑制与使用不建议或禁止参照相关的警告</td>
<td>to suppress warnings relative to usage of discouraged or</td>
</tr>
<tr>
<td>serial</td>
<td>当在可序列化的类上缺少 serialVersionUID 定义时的警告</td>
<td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td>
</tr>
<tr>
<td>static-access</td>
<td>抑制不正确的静态访问方式警告</td>
<td>to suppress warnings relative to incorrect static access</td>
</tr>
<tr>
<td>synthetic-access</td>
<td>抑制子类没有按最优方法访问内部类的警告</td>
<td>to suppress warnings relative to unoptimized access from inner classes</td>
</tr>
<tr>
<td>unchecked</td>
<td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型</td>
<td>to suppress warnings relative to unchecked operations</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td>抑制没有权限访问的域的警告</td>
<td>to suppress warnings relative to field access unqualified</td>
</tr>
<tr>
<td>unused</td>
<td>抑制没被使用过的代码的警告</td>
<td>to suppress warnings relative to unused code</td>
</tr>
</tbody>
</table>
</div>
<p><code>@SuppressWarning</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuppressWarningsAnnotationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SuppressDemo</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="keyword">var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuppressDemo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuppressDemo</span>();</span><br><span class="line">        d.setValue(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;地名：&quot;</span> + d.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;uncheck&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InternalAnnotationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@SuppressWarnings</span> 标记消除当前类的告警信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call method1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Deprecated</span> 标记当前方法为废弃方法，不建议使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call method2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Deprecated</span> 标记当前类为废弃类，不建议使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Override</span> 标记显示指明当前方法覆写了父类或接口的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        obj.method1();</span><br><span class="line">        obj.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><p><code>@SafeVarargs</code> 在 JDK7 中引入。</p>
<p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html"><code>@SafeVarargs</code></a>的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。</strong></p>
<p>简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 <code>ClassCastException</code> 异常。</p>
<p><code>@SafeVarargs</code> 注解使用范围：</p>
<ul>
<li><code>@SafeVarargs</code> 注解可以用于构造方法。</li>
<li><code>@SafeVarargs</code> 注解可以用于 <code>static</code> 或 <code>final</code> 方法。</li>
</ul>
<p><code>@SafeVarargs</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeVarargsAnnotationDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法实际上并不安全，不使用此注解，编译时会告警</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongMethod</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">        Object[] array = stringLists;</span><br><span class="line">        List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">        array[<span class="number">0</span>] = tmpList; <span class="comment">// 编译不告警</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 运行时报 ClassCastException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        wrongMethod(list, list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p><code>@FunctionalInterface</code> 在 JDK8 引入。</p>
<p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html"><code>@FunctionalInterface</code></a>用于指示被修饰的接口是函数式接口。</strong></p>
<p>需要注意的是，如果一个接口符合”函数式接口”定义，不加 <code>@FunctionalInterface</code> 也没关系；但如果编写的不是函数式接口，却使用 <code>@FunctionInterface</code>，那么编译器会报错。</p>
<p>什么是函数式接口？</p>
<p><strong>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong>。函数式接口可以被隐式转换为 lambda 表达式。</p>
<p>函数式接口的特点：</p>
<ul>
<li>接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。</li>
<li>不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。</li>
<li>允许有 default 实现方法。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalInterfaceAnnotationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Func1</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(T message)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@FunctionalInterface</span> 修饰的接口中定义两个抽象方法，编译时会报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*@FunctionalInterface</span></span><br><span class="line"><span class="comment">    public interface Func2&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">        void printMessage(T message);</span></span><br><span class="line"><span class="comment">        void printMessage2(T message);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Func1</span> <span class="variable">func1</span> <span class="operator">=</span> message -&gt; System.out.println(message);</span><br><span class="line">        func1.printMessage(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        func1.printMessage(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。</p>
<p><strong>元注解的作用就是用于定义其它的注解</strong>。</p>
<p>Java 中提供了以下元注解类型：</p>
<ul>
<li><code>@Retention</code></li>
<li><code>@Target</code></li>
<li><code>@Documented</code></li>
<li><code>@Inherited</code>（JDK8 引入）</li>
<li><code>@Repeatable</code>（JDK8 引入）</li>
<li><code>@Native</code>（JDK8 引入）</li>
</ul>
<p>这些类型和它们所支持的类在 <code>java.lang.annotation</code> 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html"><code>@Retention</code></a>指明了注解的保留级别。</strong></p>
<blockquote>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p>
</blockquote>
<p><code>@Retention</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<p><code>RetentionPolicy</code> 是一个枚举类型，它定义了被 <code>@Retention</code> 修饰的注解所支持的保留级别：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code> - 标记的注解仅在源文件中有效（源文件保留），编译器会忽略。</li>
<li><code>RetentionPolicy.CLASS</code> - 标记的注解在 class 文件中有效（编译期保留，默认值），JVM 会忽略。</li>
<li><code>RetentionPolicy.RUNTIME</code> - 标记的注解在运行时有效（运行期保留，可通过反射去获取注解信息）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    SOURCE,    <span class="comment">// 源文件保留</span></span><br><span class="line">    CLASS,       <span class="comment">// 编译期保留，默认值</span></span><br><span class="line">    RUNTIME   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SourcePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassPolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用定义好的三个注解类分别去注解一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetentionTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SourcePolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@ClassPolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@RuntimePolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过执行 <code>javap -verbose RetentionTest</code>命令获取到的RetentionTest 的 class 字节码内容如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> retention.RetentionTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">11</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">14</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p>
<ul>
<li>编译器并没有记录下 sourcePolicy() 方法的注解信息；</li>
<li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()</code>方法 和 <code>runtimePolicy()</code>方法 的注解信息；</li>
</ul>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html"><code>@Documented</code></a>表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）。更多内容可以参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html">Javadoc tools page</a>。</p>
<blockquote>
<p>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p>
</blockquote>
<p>以下代码在使用Javadoc工具可以生成<code>@TestDocAnnotation</code>注解信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestDocAnnotation &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestDocAnnotation(&quot;myMethodDoc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoc</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html"><code>@Target</code></a>指定注解可以修饰的元素类型。</strong></p>
<blockquote>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p>
</blockquote>
<p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。</p>
<p><code>@Target</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ElementType</code> 是一个枚举类型，它定义了被 <code>@Target</code> 修饰的注解可以应用的范围：</p>
<ul>
<li><code>ElementType.ANNOTATION_TYPE</code> - 标记的注解可以应用于注解类型。</li>
<li><code>ElementType.CONSTRUCTOR</code> - 标记的注解可以应用于构造函数。</li>
<li><code>ElementType.FIELD</code> - 标记的注解可以应用于字段或属性。</li>
<li><code>ElementType.LOCAL_VARIABLE</code> - 标记的注解可以应用于局部变量。</li>
<li><code>ElementType.METHOD</code> - 标记的注解可以应用于方法。</li>
<li><code>ElementType.PACKAGE</code> - 标记的注解可以应用于包声明。</li>
<li><code>ElementType.PARAMETER</code> - 标记的注解可以应用于方法的参数。</li>
<li><code>ElementType.TYPE</code> - 标记的注解可以应用于类的任何元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类</span></span><br><span class="line"> </span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量）</span></span><br><span class="line"> </span><br><span class="line">    METHOD, <span class="comment">// 成员方法</span></span><br><span class="line"> </span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数</span></span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法</span></span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量</span></span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类</span></span><br><span class="line"> </span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包</span></span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Target</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据表名称注解，默认值为类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tableName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;className&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NoDBColumn &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html"><code>@Inherited</code></a>表示注解类型可以被继承（默认情况下不是这样）</strong>。</p>
<blockquote>
<p>Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<p>🔔 注意：<code>@Inherited</code> 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。</p>
<p>此外，当 <code>@Inherited</code> 类型标注的注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，则反射 API 增强了这种继承性。如果我们使用 <code>java.lang.reflect</code> 去查询一个 <code>@Inherited</code> 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<p>我们来测试下这个注解：</p>
<ul>
<li>定义<code>@Inherited</code>注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInheritedAnnotation &#123;</span><br><span class="line">    String[] values();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">number</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用这个注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxxxxxx.TestInheritedAnnotation(values=[value], number=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>即使Student类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类Person被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此Student类自动有了该注解。</p>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html"><code>@Repeatable</code></a>表示注解可以重复使用。</strong>允许在同一申明类型(类，属性，或方法)多次使用同一个注解。</p>
<p>java 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseOldVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Authorities(&#123;@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。</p>
<p>我们再来看看java 8里面的做法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authorities.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseNewVersion</span> &#123;</span><br><span class="line">    <span class="meta">@Authority(role=&quot;Admin&quot;)</span></span><br><span class="line">    <span class="meta">@Authority(role=&quot;Manager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点。</p>
<h3 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h3><p>使用<code>@Native</code> 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。</p>
<h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><blockquote>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p>
</blockquote>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的相关接口</p>
<ul>
<li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li>
</ul>
<p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p>
<ul>
<li><code>Annotation[] getAnnotations()</code></li>
</ul>
<p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用 <code>@interface</code> 自定义注解时，自动继承了 <code>java.lang.annotation.Annotation</code> 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。<code>@interface</code> 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过 <code>default</code> 来声明参数的默认值。这里，我会通过实现一个名为 <code>RegexValid</code> 的正则校验注解工具来展示自定义注解的全步骤。</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure>
<p>我们来定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RegexValid &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>通过上一节对于元注解 <code>@Target</code>、<code>@Retention</code>、<code>@Documented</code> 的说明，这里就很容易理解了。</p>
<ul>
<li>上面的代码中定义了一个名为 <code>@RegexValid</code> 的注解。</li>
<li><code>@Documented</code> 表示 <code>@RegexValid</code> 应该使用 javadoc。</li>
<li><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</code> 表示 <code>@RegexValid</code> 可以在类成员或方法参数上修饰。</li>
<li>@Retention(RetentionPolicy.RUNTIME) 表示 <code>@RegexValid</code> 在运行时有效。</li>
</ul>
</blockquote>
<p>此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。</p>
<h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p>注解属性的语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问级别修饰符] [数据类型] 名称() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure>
<p>例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🔔 注意：<strong>在注解中，我们定义属性时，属性名后面需要加 <code>()</code></strong>。</p>
</blockquote>
<p>定义注解属性有以下要点：</p>
<ul>
<li><strong>注解属性只能使用 <code>public</code> 或默认访问级别（即不指定访问级别修饰符）修饰</strong>。</li>
<li><strong>注解属性的数据类型有限制要求</strong>。支持的数据类型如下：<ul>
<li>所有基本数据类型（byte、char、short、int、long、float、double、boolean）</li>
<li>String 类型</li>
<li>Class 类</li>
<li>enum 类型</li>
<li>Annotation 类型</li>
<li>以上所有类型的数组</li>
</ul>
</li>
<li><strong>注解属性必须有确定的值，建议指定默认值</strong>。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。</li>
<li>如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两种方式效果相同</span></span><br><span class="line"><span class="meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br><span class="line"><span class="meta">@RegexValid(value = &quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>了解了注解属性的定义要点，让我们来为 <code>@RegexValid</code> 注解定义几个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RegexValid &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Policy</span> &#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        EMPTY(<span class="literal">null</span>),</span><br><span class="line">        DATE(<span class="string">&quot;^(?:(?!0000)[0-9]&#123;4&#125;([-/.]?)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1&quot;</span></span><br><span class="line">            + <span class="string">&quot;(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|&quot;</span></span><br><span class="line">            + <span class="string">&quot;(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))$&quot;</span>),</span><br><span class="line">        MAIL(<span class="string">&quot;^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]&#123;2,&#125;)$&quot;</span>);</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String policy;</span><br><span class="line"></span><br><span class="line">        Policy(String policy) &#123;</span><br><span class="line">            <span class="built_in">this</span>.policy = policy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> policy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Policy <span class="title function_">policy</span><span class="params">()</span> <span class="keyword">default</span> Policy.EMPTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>在上面的示例代码中，我们定义了两个注解属性：<code>String</code> 类型的 value 属性和 <code>Policy</code> 枚举类型的 policy 属性。<code>Policy</code> 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。</p>
</blockquote>
<p>至此，<code>@RegexValid</code> 的声明已经结束。但是，程序仍不知道如何处理 <code>@RegexValid</code> 这个注解。我们还需要定义注解处理器。</p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建与使用注解处理器。JDK5 扩展了反射机制的 API，以帮助程序员快速地构造自定义注解处理器。</p>
<p><strong><code>java.lang.annotation.Annotation</code> 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据</strong>。</p>
<p><code>Annotation</code> 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，Java 中支持<strong>注解处理器接口 <code>java.lang.reflect.AnnotatedElement</code></strong> ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p>
<ul>
<li><code>Class</code> - 类定义</li>
<li><code>Constructor</code> - 构造器定义</li>
<li><code>Field</code> - 类的成员变量定义</li>
<li><code>Method</code> - 类的方法定义</li>
<li><code>Package</code> - 类的包定义</li>
</ul>
<p><code>java.lang.reflect</code> 包下主要包含一些实现反射功能的工具类。实际上，<code>java.lang.reflect</code> 包所有提供的反射 API 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 <code>AnnotatedElement</code> 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的<code>AnnotatedElement</code> 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：</p>
<ul>
<li><code>getAnnotation</code> - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。</li>
<li><code>getAnnotations</code> - 返回该程序元素上存在的所有注解。</li>
<li><code>isAnnotationPresent</code> - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。</li>
<li><code>getDeclaredAnnotations</code> - 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注解直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<p>了解了以上内容，让我们来实现 <code>@RegexValid</code> 的注解处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexValidUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Field[] fields = obj.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 判断成员是否被 @RegexValid 注解所修饰</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(RegexValid.class)) &#123;</span><br><span class="line">                <span class="type">RegexValid</span> <span class="variable">valid</span> <span class="operator">=</span> field.getAnnotation(RegexValid.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> valid.value();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                    RegexValid.<span class="type">Policy</span> <span class="variable">policy</span> <span class="operator">=</span> valid.policy();</span><br><span class="line">                    value = policy.getPolicy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过设置 setAccessible(true) 来访问私有成员</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">fieldObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fieldObj = field.get(obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fieldObj == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                        .append(String.format(<span class="string">&quot;%s 类中的 %s 字段不能为空！&quot;</span>, obj.getClass().getName(), field.getName()));</span><br><span class="line">                    result = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fieldObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (String) fieldObj;</span><br><span class="line">                        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(value);</span><br><span class="line">                        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text);</span><br><span class="line">                        result = m.matches();</span><br><span class="line">                        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                            sb.append(<span class="string">&quot;\n&quot;</span>).append(String.format(<span class="string">&quot;%s 不是合法的 %s ！&quot;</span>, text, field.getName()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;\n&quot;</span>).append(</span><br><span class="line">                            String.format(<span class="string">&quot;%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！&quot;</span>, obj.getClass().getName(), field.getName()));</span><br><span class="line">                        result = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>以上示例中的注解处理器，执行步骤如下：</p>
<ol>
<li>通过 getDeclaredFields 反射方法获取传入对象的所有成员。</li>
<li>遍历成员，使用 isAnnotationPresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。</li>
<li>如果成员被注解所修饰，通过 <code>RegexValid valid = field.getAnnotation(RegexValid.class);</code> 这样的形式获取，注解实例化对象，然后，就可以使用 <code>valid.value()</code> 或 <code>valid.policy()</code> 这样的形式获取注解中设定的属性值。</li>
<li>根据属性值，进行逻辑处理。</li>
</ol>
</blockquote>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>完成了以上工作，我们就可以使用自定义注解了，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexValidDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="meta">@RegexValid(policy = RegexValid.Policy.DATE)</span></span><br><span class="line">        <span class="keyword">private</span> String date;</span><br><span class="line">        <span class="meta">@RegexValid(policy = RegexValid.Policy.MAIL)</span></span><br><span class="line">        <span class="keyword">private</span> String mail;</span><br><span class="line">        <span class="meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String date, String mail, String phone)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.date = date;</span><br><span class="line">            <span class="built_in">this</span>.mail = mail;</span><br><span class="line">            <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, date=&#x27;&quot;</span> + date + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, mail=&#x27;&quot;</span> + mail + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, phone=&#x27;&quot;</span></span><br><span class="line">                + phone + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDate</span><span class="params">(<span class="meta">@RegexValid(policy = RegexValid.Policy.DATE)</span> String date)</span>&#123;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;1990-01-31&quot;</span>, <span class="string">&quot;xxx@163.com&quot;</span>, <span class="string">&quot;18612341234&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;2019-02-29&quot;</span>, <span class="string">&quot;sadhgs&quot;</span>, <span class="string">&quot;183xxxxxxxx&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (RegexValidUtil.check(user)) &#123;</span><br><span class="line">            System.out.println(user + <span class="string">&quot;正则校验通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RegexValidUtil.check(user2)) &#123;</span><br><span class="line">            System.out.println(user2 + <span class="string">&quot;正则校验通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><h3 id="注解支持继承吗？"><a href="#注解支持继承吗？" class="headerlink" title="注解支持继承吗？"></a>注解支持继承吗？</h3><blockquote>
<p>注解是不支持继承的</p>
</blockquote>
<p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.</p>
<p>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<h3 id="注解实现的原理？"><a href="#注解实现的原理？" class="headerlink" title="注解实现的原理？"></a>注解实现的原理？</h3><ul>
<li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li>
<li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li>
</ul>
<h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><h3 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="配置化到注解化 - 框架的演进"></a>配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p>
<h3 id="继承实现到注解实现-Junit3到Junit4"><a href="#继承实现到注解实现-Junit3到Junit4" class="headerlink" title="继承实现到注解实现 - Junit3到Junit4"></a>继承实现到注解实现 - Junit3到Junit4</h3><blockquote>
<p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p>
</blockquote>
<ul>
<li>被测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;hello....&quot;</span>);</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;world....&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Junit 3 实现UT</li>
</ul>
<p>通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="built_in">super</span>.setUp();</span><br><span class="line"> 		hw=<span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">//1.测试没有返回值</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			hw.sayHello();</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> 			System.out.println(<span class="string">&quot;发生异常.....&quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span>&#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//返回对象</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span>&#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="built_in">super</span>.tearDown();</span><br><span class="line"> 		hw=<span class="literal">null</span>;</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Junit 4 实现UT</li>
</ul>
<p>通过定义@Before，@Test，@After等等注解来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Before</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw = <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Test(expected=NumberFormatException.class)</span></span><br><span class="line"> 	<span class="comment">// 1.测试没有返回值,有别于junit3的使用，更加方便</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw.sayHello();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span> &#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 返回对象</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span> &#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@After</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		hw = <span class="literal">null</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。</p>
<h3 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h3><blockquote>
<p>最为常见的就是使用Spring AOP切面实现<strong>统一的操作日志管理</strong>，我这里找了一个开源项目中的例子（只展示主要代码），展示下如何通过注解实现解耦的。</p>
</blockquote>
<ul>
<li>自定义Log注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BusinessType <span class="title function_">businessType</span><span class="params">()</span> <span class="keyword">default</span> BusinessType.OTHER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作人类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否保存请求的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现日志的切面, 对自定义注解Log作切点进行拦截</li>
</ul>
<p>即对注解了@Log的方法进行切点拦截，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置织入点 - 自定义注解的包路径</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理完请求后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object jsonResult)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, <span class="literal">null</span>, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截异常操作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, e, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, <span class="keyword">final</span> Exception e, Object jsonResult)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得注解</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">controllerLog</span> <span class="operator">=</span> getAnnotationLog(joinPoint);</span><br><span class="line">            <span class="keyword">if</span> (controllerLog == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> ShiroUtils.getSysUser();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            <span class="type">OperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperLog</span>();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ShiroUtils.getIp();</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            <span class="comment">// 返回参数</span></span><br><span class="line">            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));</span><br><span class="line"></span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="keyword">if</span> (currentUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(currentUser.getLoginName());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotNull(currentUser.getDept())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) &#123;</span><br><span class="line">                    operLog.setDeptName(currentUser.getDept().getDeptName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(controllerLog, operLog);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注解中对方法的描述信息 用于Controller层注解</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> log 日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog 操作日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getControllerMethodDescription</span><span class="params">(Log log, OperLog operLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置action动作</span></span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        <span class="comment">// 设置操作人类别</span></span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        <span class="comment">// 是否需要保存request，参数和值</span></span><br><span class="line">        <span class="keyword">if</span> (log.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="comment">// 获取参数的信息，传入到数据库中。</span></span><br><span class="line">            setRequestValue(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的参数，放到log中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRequestValue</span><span class="params">(OperLog operLog)</span> &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> JSONObject.toJSONString(map);</span><br><span class="line">        operLog.setOperParam(StringUtils.substring(params, <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在注解，如果存在就获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Log <span class="title function_">getAnnotationLog</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) signature;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> method.getAnnotation(Log.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用@Log注解</li>
</ul>
<p>以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;system/dept&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDeptService deptService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增保存部门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:add&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">addSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;新增部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.insertDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:edit&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">editSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dept.getParentId().equals(dept.getDeptId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，上级部门不能是自己&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.updateDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:remove&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/remove/&#123;deptId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable(&quot;deptId&quot;)</span> Long deptId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deptService.selectDeptCount(deptId) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;存在下级部门,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deptService.checkDeptExistUser(deptId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;部门存在用户,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.deleteDeptById(deptId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样的，你也可以看到权限管理也是通过类似的注解（<code>@RequiresPermissions</code>）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/%E6%B3%A8%E8%A7%A3%E7%AE%80%E4%BB%8B.svg" alt="注解简介"></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3.svg" alt="内置注解"></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/%E5%85%83%E6%B3%A8%E8%A7%A3.svg" alt="元注解"></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.svg" alt="自定义注解"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存击穿问题及解决方法</title>
    <url>/posts/cachebreakdown.html</url>
    <content><![CDATA[<p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117180656666.png" alt="image-20221117180656666"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117180718900.png" alt="image-20221117180718900"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20221117180749105.png" alt="image-20221117180749105"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/1653357522914.png" alt="1653357522914"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
