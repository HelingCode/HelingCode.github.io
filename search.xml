<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>26.删除数组中的重复项</title>
    <url>/posts/5982.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">题目</a>描述：</p>
<span id="more"></span>
<blockquote>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。  </p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
</blockquote>
<p>使用双指针法，定义快慢指针，首先定义慢指针为0；快指针为1；然后循环快指针，如果快指针指向的元素不等于慢指针指向的元素，那么令快指针指向的元素等于慢指针指向的元素的后一个元素。最终返回慢指针+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">1</span>;fastIndex &lt; nums.length; ++fastIndex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[lowIndex] != nums[fastIndex])&#123;</span><br><span class="line">                nums[lowIndex + <span class="number">1</span>] = nums[fastIndex];</span><br><span class="line">                ++lowIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>977.有序数组的平方</title>
    <url>/posts/35851.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">题目</a>描述：</p>
<span id="more"></span>
<blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
</blockquote>
<p>简单的思路就是暴力破解了，没什么说的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; ++i)&#123;</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlogn)。</p>
<p>接下来使用双指针法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]*nums[l] &gt; nums[r]*nums[r])&#123;</span><br><span class="line">                res[k--] = nums[l]*nums[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[k--] = nums[r]*nums[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>209.长度最小的子数组</title>
    <url>/posts/44730.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">题目</a>描述：</p>
<span id="more"></span>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
</blockquote>
<p>首先想到的肯定是暴力解法，使用两个for循环，然后不断地寻找满足条件的子序列，时间复杂度是O(n^2)。</p>
<p>下面介绍使用滑动窗口的解法。</p>
<p>滑动窗口其实就是双指针，通过两个指针不断改变子序列的起始位置和结束位置，直到找到长度最小的子序列。解题的关键就是需要注意如何移动起始位置和结束位置的指针。如果当前的窗口里面的值的和大于给定的值了，那么就可以向前移动初始位置的指针，而结束位置的指针只是用来遍历数组的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; nums.length; ++right)&#123; <span class="comment">//结束指针遍历数组</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                result = Math.min(result,right-left+<span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++]; <span class="comment">//移动初始指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC中的数据结构</title>
    <url>/posts/ds_btc.html</url>
    <content><![CDATA[<h3 id="Hash-Pointer"><a href="#Hash-Pointer" class="headerlink" title="Hash Pointer"></a>Hash Pointer</h3><p>在程序运行过程中，需要用到数据。最简单的是直接获取数据，但当数据本身较大，需要占用较大空间时，明显会造成一定麻烦。因此，可以引入指针这一概念。当需要获取数据时，只需要按照指针所给的地址，去对应的位置读取数据即可，这样大大节省了内存空间。在实际中，为了便于程序移植性等原因，指针实际上存储的是逻辑地址而非物理地址。<br>区块链结构本身为一条链表，节点为区块。而传统链表实现，便是通过指针将各个节点串联起来而称为最终的链。如下便是我们最常见的一个链表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20200214173054674.png" alt="在这里插入图片描述"></p>
<p>但在区块链系统中，并未采用指针，而是使用了<strong>哈希指针</strong>。<br>如下图对于该节点，我们可以看到有两个指针指向这个节点（实际上为一个），其中P为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20200214173157391.png" alt="在这里插入图片描述"></p>
<p>在比特币中，其最基本的数据结构便是一个个区块形成的区块链。</p>
<p><strong>区块链与链表区别：</strong>哈希指针代替普通指针<br>如图为一个简单的区块链。其中，每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。需要注意的是，本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。<br>如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。<br>在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20200214173245117-20231217152518005.png" alt="在这里插入图片描述"></p>
<h3 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h3><p>Merkle Tree可以用于提供Merkle Proof。比特币中节点分为<strong>轻节点</strong>和<strong>全节点</strong>。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。</p>
<blockquote>
<p>为什么要分轻节点和全节点？<br>因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容即可。</p>
</blockquote>
<p>当需要向轻节点证明某条交易是否被写入区块链，便需要用到Merkle proof。我们将交易到根节点这一条路径称为Merkle proof，全节点将整个Merkle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221125150306565.png" alt="image-20221125150306565"></p>
<p>以上图为例，要验证黄色的交易是否被写到区块中，我们首先要请求第三层的红色的哈希值，然后根据黄色的交易求出第三层的绿色哈希值，然后通过这两个已知的哈希值求出第二层的绿色哈希值，再请求第二层的红色哈希值，以此类推最终求得根哈希值，然后与存储在自身结点中的根哈希值比较，若相同则证明交易已经写入到了区块中。</p>
<p>上面的验证是proof of membership 时间复杂度为O(logn)<br>关于proof of non-membership验证，如果交易是无序的，我们只能证明每个结点都是对的，说明没有该节点，时间复杂度为O(n)<br>如果交易是按hash值从小到大排序，我们对要检验的交易取hash，判断它应处的位置，然后计算他前后的两个结点的hash，若这两个结点确实相邻（merkle proof），则证明我们要找的结点不存在（若存在则会在这两个结点之间，这两个结点不会相邻），时间复杂度为O(logn)。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7启动Tomcat后浏览器无法访问的解决方法</title>
    <url>/posts/2483.html</url>
    <content><![CDATA[<p>自己的Linux系统是CentOS7,今天在学习Tomcat的使用的时候，在Linux里面启动成功之后，在Windows浏览器访问<code>http://ip地址:8080</code>失败，原来需要有防火墙的相关操作，要编辑/etc/sysconfig目录下面的iptables文件，但是CentOS7中没有这个文件，所以如果要对防火墙操作，需要更新或者重新安装防火墙服务。</p>
<span id="more"></span>
<p>解决步骤如下：</p>
<ol>
<li><p>安装或者更新iptables-services</p>
<p><code>yum install iptables-services</code></p>
</li>
<li><p>启动iptables</p>
<p><code>systemctl enable iptables</code></p>
<p>这个时候，/etc/sysconfig目录下面就有了iptables文件了。</p>
</li>
<li><p>打开iptables</p>
<p><code>systemctl start iptables</code></p>
</li>
<li><p>编辑防火墙配置</p>
<p><code>$ vi /etc/sysconfig/iptables</code></p>
</li>
<li><p>添加8080端口的防火墙,允许访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入i开始编辑,ESC键结束编辑,wq保存并退出.</p>
</li>
<li><p>重启防火墙</p>
<p><code>$ service iptables restart</code></p>
</li>
</ol>
<p>之后就可以在本机通过浏览器访问<code>http://ip地址:8080</code>,就可以正常看到tomcat的默认欢迎页面了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的安装及常用命令</title>
    <url>/posts/docker.html</url>
    <content><![CDATA[<h2 id="查看系统的内核版本"><a href="#查看系统的内核版本" class="headerlink" title="查看系统的内核版本"></a>查看系统的内核版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# uname -r</span><br><span class="line">3.10.0-1160.53.1.el7.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="yum-更新到最新版本"><a href="#yum-更新到最新版本" class="headerlink" title="yum 更新到最新版本"></a>yum 更新到最新版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo yum update</span><br></pre></td></tr></table></figure>
<h2 id="安装Docker所需的依赖包"><a href="#安装Docker所需的依赖包" class="headerlink" title="安装Docker所需的依赖包"></a>安装Docker所需的依赖包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<h2 id="设置Docker的yum的源"><a href="#设置Docker的yum的源" class="headerlink" title="设置Docker的yum的源"></a>设置Docker的yum的源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<ul>
<li>鉴于国内网络问题，强烈建议使用国内源。以下是阿里云的软件源。<strong>如果是海外如AWS云就不要设置yum源</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h2 id="查看仓库所有Docker版本"><a href="#查看仓库所有Docker版本" class="headerlink" title="查看仓库所有Docker版本"></a>查看仓库所有Docker版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<ul>
<li>这里可以看到你能安装的最新版本</li>
</ul>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo yum install docker</span><br></pre></td></tr></table></figure>
<ul>
<li>安装默认最新版本的 Docker</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo yum install &lt;FQPN&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>安装指定版本，例如：sudo yum install <a href="http://docker-ce-20.10.11.ce/">docker-ce-20.10.11.ce</a></li>
</ul>
<h2 id="启动Docker并添加开机自启动"><a href="#启动Docker并添加开机自启动" class="headerlink" title="启动Docker并添加开机自启动"></a>启动Docker并添加开机自启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<ul>
<li>启动 Docker</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# systemctl enable docker</span><br></pre></td></tr></table></figure>
<ul>
<li>设置开机启动 Docker</li>
</ul>
<h2 id="查看-Docker-版本"><a href="#查看-Docker-版本" class="headerlink" title="查看 Docker 版本"></a>查看 Docker 版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# docker --version</span><br><span class="line">Docker version 1.13.1, build 7d71120/1.13.1</span><br></pre></td></tr></table></figure>
<h2 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# docker --help    #Docker帮助</span><br><span class="line">[root@ecs-29043 ~]# docker --version   #查看Docker版本</span><br><span class="line">[root@ecs-29043 ~]# docker search &lt;image&gt;  #搜索镜像文件，如：docker search mysql</span><br><span class="line">[root@ecs-29043 ~]# docker pull &lt;image&gt;  #拉取镜像文件， 如：docker pull mysql</span><br><span class="line">[root@ecs-29043 ~]# docker images    #查看已经拉取下来的所以镜像文件</span><br><span class="line">[root@ecs-29043 ~]# docker rmi &lt;image&gt;  #删除指定镜像文件</span><br><span class="line">[root@ecs-29043 ~]# docker run --name &lt;name&gt; -p 80:8080 -d &lt;image&gt;  #发布指定镜像文件</span><br><span class="line">[root@ecs-29043 ~]# docker ps     #查看正在运行的所有镜像</span><br><span class="line">[root@ecs-29043 ~]# docker ps -a    #查看所有发布的镜像</span><br><span class="line">[root@ecs-29043 ~]# docker rm &lt;image&gt;   #删除执行已发布的镜像</span><br></pre></td></tr></table></figure>
<h2 id="拉取Portainer"><a href="#拉取Portainer" class="headerlink" title="拉取Portainer"></a>拉取Portainer</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-29043 ~]# docker pull portainer/portainer</span><br></pre></td></tr></table></figure>
<h2 id="启动Portainer"><a href="#启动Portainer" class="headerlink" title="启动Portainer"></a>启动Portainer</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK动态代理和Cglib动态代理</title>
    <url>/posts/spring_aop.html</url>
    <content><![CDATA[<p><strong>代理模式</strong>是一种设计模式，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了。只需要在代理类上增加就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/2244490621-6140109245c01_fix732.png" alt="2244490621-6140109245c01_fix732"></p>
<p>在Java中，代理又分静态代理和动态代理2种，其中动态代理根据不同实现又区分基于接口的的动态代理和基于子类的动态代理。</p>
<p>代理类完成的功能：</p>
<ul>
<li>调用目标方法，执行目标方法的功能。</li>
<li>功能增强，在目标方法调用时，增加功能。</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>所谓静态代理，就是通过<strong>声明一个明确的代理类</strong>来访问源对象。</p>
<p>我们有2个接口，Person和Animal。每个接口各有2个实现类，UML如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/43042188-6140109a1cbc8.png" alt="43042188-6140109a1cbc8"></p>
<p>每个实现类中代码都差不多一致，用Student来举例（其他类和这个几乎一模一样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span> + name + <span class="string">&quot;早晨醒来啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生&quot;</span> + name + <span class="string">&quot;晚上睡觉啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们现在要做一件事，就是在所有的实现类调用<code>wakeup()</code>前增加一行输出<code>早安~</code>，调用<code>sleep()</code>前增加一行输出<code>晚安~</code>。那我们只需要编写2个代理类<code>PersonProxy</code>和<code>AnimalProxy</code>：</p>
<p><strong>PersonProxy:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早安~&quot;</span>);</span><br><span class="line">        person.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚安~&quot;</span>);</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AnimalProxy:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalProxy</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnimalProxy</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早安~&quot;</span>);</span><br><span class="line">        animal.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚安~&quot;</span>);</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最终执行代码为：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="type">PersonProxy</span> <span class="variable">studentProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(student);</span><br><span class="line">    studentProxy.wakeup();</span><br><span class="line">    studentProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">doctor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>);</span><br><span class="line">    <span class="type">PersonProxy</span> <span class="variable">doctorProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(doctor);</span><br><span class="line">    doctorProxy.wakeup();</span><br><span class="line">    doctorProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">    <span class="type">AnimalProxy</span> <span class="variable">dogProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalProxy</span>(dog);</span><br><span class="line">    dogProxy.wakeup();</span><br><span class="line">    dogProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>);</span><br><span class="line">    <span class="type">AnimalProxy</span> <span class="variable">catProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalProxy</span>(cat);</span><br><span class="line">    catProxy.wakeup();</span><br><span class="line">    catProxy.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">早安~</span><br><span class="line">学生[张三]早晨醒来啦</span><br><span class="line">晚安~</span><br><span class="line">学生[张三]晚上睡觉啦</span><br><span class="line">早安~</span><br><span class="line">医生[王教授]早晨醒来啦</span><br><span class="line">晚安~</span><br><span class="line">医生[王教授]晚上睡觉啦</span><br><span class="line">早安~~</span><br><span class="line">小狗[旺旺]早晨醒来啦</span><br><span class="line">晚安~~</span><br><span class="line">小狗[旺旺]晚上睡觉啦</span><br><span class="line">早安~~</span><br><span class="line">小猫[咪咪]早晨醒来啦</span><br><span class="line">晚安~~</span><br><span class="line">小猫[咪咪]晚上睡觉啦</span><br></pre></td></tr></table></figure>
<p>这里用了2个代理类，分别代理了<code>Person</code>和<code>Animal</code>接口。</p>
<p>这种模式虽然好理解，但是缺点也很明显：</p>
<ul>
<li>会存在大量的冗余的代理类，这里演示了2个接口，如果有10个接口，就必须定义10个代理类。</li>
<li>不易维护，一旦接口更改，代理类和目标类都需要更改。</li>
<li>若类方法数量越来越多的时候，代理类的代码量十分庞大的。</li>
</ul>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>在程序的执行过程中，使用JDK的反射机制，创建代理类对象，并动态地指定要代理的目标类。</p>
<p>JDK动态代理的实现主要依靠三个类：InvocationHandler，Method，Proxy。</p>
<ul>
<li><strong>InvocationHandler（调用处理器）接口</strong>：里面只有一个Invoke() 方法，该方法表示代理对象要执行的功能代码。代理类要完成的功能就写在invoke() 方法中。方法原型如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Object proxy</code> 表示JDK创建的代理对象，无需赋值。<code>Method method</code> 表示目标类中的方法，JDK提供method对象。<code>Object[] args</code> 表示目标类中方法的参数，JDK提供的。</p>
<p>InvocationHandler接口：表示你的代理要干什么。</p>
<p><strong>用法：</strong>1.创建类实现<code>InvocationHandler</code>接口 2.重写i<code>nvoke()</code> 方法，把原来静态代理类要完成的功能，写在这里。</p>
<ul>
<li><strong>Method类</strong>： 表示方法，确切的说是目标类中的方法。</li>
</ul>
<p>作用：通过Method可以执行某个目标类的方法，<code>Method.invoke();</code> </p>
<p><code>method.invoke(目标对象，方法的参数);</code></p>
<ul>
<li><strong>Proxy类</strong>：核心的对象，用来创建代理对象。之前的静态代理中都是new类的构造方法，现在我们是使用Proxy类的方法，代替new的使 用。</li>
</ul>
<p>方法：静态方法<code>newProxyInstance()</code>;</p>
<p>作用：创建代理对象，等同于静态代理中的用new创建代理对象。</p>
<p>方法原型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>ClassLoader loader</code> 表示类加载器，负责向内存中加载对象，可以使用反射获取对象的ClassLoader。例如类a, <code>a.getClass().getClassLoader()</code>, 这里表示目标对象的类加载器。</p>
<p><code>Class&lt;?&gt;[] interfaces</code> : 接口，目标对象实现的接口，也是反射获取的。</p>
<p><code>InvocationHandler h</code> ： 我们自己写的，代理类要完成的功能。</p>
<p>返回值<code>Object</code> ： 就是生成的代理对象。</p>
<p>还是前面那个例子，用JDK动态代理类去实现的代码如下：</p>
<p><strong>创建一个JdkProxy类，用于统一代理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(bean, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JdkProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="comment">// student是代理对象，是com.sun.proxy.$Proxy类型的</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">    <span class="comment">// 通过代理对象执行方法调用，执行handler，student.wakeup(),此时执行的是proxy对象中的invoke()方法</span></span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">doctor</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;, proxy);</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;, proxy);</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，相对于静态代理类来说，无论有多少接口，这里只需要一个代理类。核心代码也很简单。唯一需要注意的点有以下2点：</p>
<ul>
<li>JDK动态代理是需要声明接口的，创建一个动态代理类必须得给这个”虚拟“的类一个接口。可以看到，这时候经动态代理类创造之后的每个bean已经不是原来那个对象了。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/2796530636-614010da5d63f_fix732.png" alt="2796530636-614010da5d63f_fix732"></p>
<ul>
<li>为什么这里<code>JdkProxy</code>还需要构造传入原有的bean呢？因为处理完附加的功能外，需要执行原有bean的方法，以完成<code>代理</code>的职责。</li>
</ul>
<p>这里<code>JdkProxy</code>最核心的方法就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>
<p>其中proxy为代理过之后的对象(并不是目标对象)，method为被代理的方法，args为方法的参数。</p>
<p>如果你不传原有的bean，直接用<code>method.invoke(proxy, args)</code>的话，那么就会陷入一个死循环。</p>
<h3 id="可以代理什么？"><a href="#可以代理什么？" class="headerlink" title="可以代理什么？"></a>可以代理什么？</h3><p>JDK的动态代理是也平时大家使用的最多的一种代理方式。也叫做接口代理。</p>
<p>JDK动态代理说白了只是根据接口”凭空“来生成类，至于具体的执行，都被代理到了<code>InvocationHandler</code> 的实现类里。上述例子我是需要继续执行原有bean的逻辑，才将原有的bean构造进来。只要你需要，你可以构造进任何对象到这个代理实现类。也就是说，你可以传入多个对象，或者说你什么类都不代理。只是为某一个接口”凭空“的生成多个代理实例，这多个代理实例最终都会进入<code>InvocationHandler</code>的实现类来执行某一个段共同的代码。</p>
<p>所以，在以往的项目中的一个实际场景就是，我有多个以y aml定义的规则文件，通过对yaml文件的扫描，来为每个yaml规则文件生成一个动态代理类。而实现这个，我只需要事先定义一个接口，和定义<code>InvocationHandler</code>的实现类就可以了，同时把yaml解析过的对象传入。最终这些动态代理类都会进入<code>invoke</code>方法来执行某个共同的逻辑。</p>
<h3 id="代理对象由谁产生？"><a href="#代理对象由谁产生？" class="headerlink" title="代理对象由谁产生？"></a>代理对象由谁产生？</h3><p>JVM，不像静态代理，我们得自己new个代理对象。</p>
<h3 id="代理对象实现了什么接口？"><a href="#代理对象实现了什么接口？" class="headerlink" title="代理对象实现了什么接口？"></a>代理对象实现了什么接口？</h3><p>实现的接口是目标对象实现的接口。 同静态代理中代理对象实现的接口。那个继承关系图还是相同的。 代理对象和目标对象都实现一个共同的接口。就是这个接口。 所以Proxy.newProxyInstance()方法返回的类型就是这个接口类型。</p>
<h3 id="代理对象的方法体是什么？"><a href="#代理对象的方法体是什么？" class="headerlink" title="代理对象的方法体是什么？"></a>代理对象的方法体是什么？</h3><p>代理对象的方法体中的内容就是拦截器中invoke方法中的内容。</p>
<p>所有代理对象的处理逻辑，控制是否执行目标对象的目标方法。都是在这个方法里面处理的。</p>
<h3 id="拦截器中的invoke方法中的method参数是在什么时候赋值的"><a href="#拦截器中的invoke方法中的method参数是在什么时候赋值的" class="headerlink" title="拦截器中的invoke方法中的method参数是在什么时候赋值的?"></a>拦截器中的invoke方法中的method参数是在什么时候赋值的?</h3><p>在客户端，代理对象调用目标方法的时候，此实例中为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.wakeup();</span><br></pre></td></tr></table></figure>
<p>实际上进入的是拦截器中的invoke方法，这时拦截器中的invoke方法中的method参数会被赋值。</p>
<h3 id="为什么叫JDK动态代理？"><a href="#为什么叫JDK动态代理？" class="headerlink" title="为什么叫JDK动态代理？"></a>为什么叫JDK动态代理？</h3><h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><p>CGLIB(Code Generation Library) 是一个开源项目。是一个强大的、高性能、高质量的Code生成类库，它可以在运行期拓展Java类与实现Java接口。它广泛地被许多AOP框架使用，例如Spring AOP。</p>
<p>使用JDK的Proxy实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。</p>
<p>但对于无接口的类，要为期创建动态代理，就要使用CGLIB来实现。CGLIB代理的生成原理是生成目标类的子类，通过子类对目标类的增强。这个子类就是代理对象。所以，使用CGLIB生成动态代理，要求目标类必须能被继承，即不能是final修饰的类。</p>
<p>CGLIB经常被应用在框架中，例如Spring,Hibernate等。Cglib的代理效率高于JDK。对于Cglib一般的开发中并不使用。</p>
<p>Spring在5.X之前默认的动态代理实现一直是jdk动态代理。但是从5.X开始，spring就开始默认使用Cglib来作为动态代理实现。并且springboot从2.X开始也转向了Cglib动态代理实现。</p>
<p>是什么导致了spring体系整体转投Cglib呢，jdk动态代理又有什么缺点呢？</p>
<p>那么我们现在就要来说下Cglib的动态代理。</p>
<p>Cglib是一个开源项目，它的底层是字节码处理框架ASM，Cglib提供了比jdk更为强大的动态代理。主要相比jdk动态代理的优势有：</p>
<ul>
<li>jdk动态代理只能基于接口，代理生成的对象只能赋值给接口变量，而Cglib就不存在这个问题，Cglib是通过生成子类来实现的，代理对象既可以赋值给实现类，又可以赋值给接口。</li>
<li>Cglib速度比jdk动态代理更快，性能更好。</li>
</ul>
<p>那何谓通过子类来实现呢？</p>
<p>还是前面那个例子，我们要实现相同的效果。代码如下</p>
<p><strong>创建CglibProxy类，用于统一代理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置需要创建子类的类</span></span><br><span class="line">        enhancer.setSuperclass(bean.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现MethodInterceptor接口方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用原bean的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(bean,args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) proxy.getProxy();</span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Doctor</span> <span class="variable">doctor</span> <span class="operator">=</span> (Doctor) proxy.getProxy();</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) proxy.getProxy();</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) proxy.getProxy();</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里用Cglib作为代理，其思路和jdk动态代理差不多。也需要把原始bean构造传入。</p>
<p>关键的代码在这里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置需要创建子类的类</span></span><br><span class="line">enhancer.setSuperclass(bean.getClass());</span><br><span class="line">enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line"><span class="keyword">return</span> enhancer.create();</span><br></pre></td></tr></table></figure>
<p>可以看到，Cglib”凭空”的创造了一个原bean的子类，并把Callback指向了this，也就是当前对象，也就是这个proxy对象。从而会调用<code>intercept</code>方法。而在<code>intercept</code>方法里，进行了附加功能的执行，最后还是调用了原始bean的相应方法。</p>
<p>在debug这个生成的代理对象时，我们也能看到，Cglib是凭空生成了原始bean的子类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1853665691-614010e6b05ac_fix732.png" alt="1853665691-614010e6b05ac_fix732"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程面试题</title>
    <url>/posts/java-juc.html</url>
    <content><![CDATA[<h3 id="🤣-用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？"><a href="#🤣-用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？" class="headerlink" title="🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？"></a>🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</h3><p>用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<h3 id="😂-sleep-和-wait-有什么区别"><a href="#😂-sleep-和-wait-有什么区别" class="headerlink" title="😂 sleep() 和 wait() 有什么区别?"></a>😂 sleep() 和 wait() 有什么区别?</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放）,该线程才能回到可运行状态等待获取锁。</p>
<h3 id="😄-同步和异步有何异同？"><a href="#😄-同步和异步有何异同？" class="headerlink" title="😄 同步和异步有何异同？"></a>😄 同步和异步有何异同？</h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="😅-多线程有几种实现方法-同步有几种实现方法"><a href="#😅-多线程有几种实现方法-同步有几种实现方法" class="headerlink" title="😅 多线程有几种实现方法?同步有几种实现方法?"></a>😅 多线程有几种实现方法?同步有几种实现方法?</h3><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。</p>
<p>同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 </p>
<p>notityAll():唤醒所有处于等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h3 id="😆-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#😆-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="😆 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>😆 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h3 id="😶-多线程操作-static-变量会有影响吗？"><a href="#😶-多线程操作-static-变量会有影响吗？" class="headerlink" title="😶 多线程操作 static 变量会有影响吗？"></a>😶 多线程操作 static 变量会有影响吗？</h3><p>当多个线程执行同一个方法的时候，并且方法中使用了静态变量的时候，就会出现安全问题， 因为静态成员（static member）作为公共变量，是放在共享内存区域的。 多个线程共享一块内存区域，在不加任何保护情况下对其操作就会出现异常结果。</p>
<p><strong>解决方法：</strong></p>
<p>不使用共享内存，每个线程内存空间相互独立；<br>多线程共享一块内存区域，但是对这块共享区域加锁访问。对调用static变量的方法使用lock或synchronized</p>
<h3 id="🙄-为什么要使用多线程"><a href="#🙄-为什么要使用多线程" class="headerlink" title="🙄 为什么要使用多线程?"></a>🙄 为什么要使用多线程?</h3><p>从系统应用上来思考：</p>
<ul>
<li>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间切换和调度的成本远远小于进程。另外，多核 CPU 时代，意味着多个线程可以同时运行，这减少了线程上下文切换的开销；</li>
<li>如今的系统，动不动就要求百万级甚至亿万级的并发量，而多线程并发编程，正是开发高并发系统的基础，利用好多线程机制，可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>从计算机背后来探讨：</p>
<p><strong>单核时代：</strong> 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程工作的时候，会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。可以简单地理解成，这两者的利用率最高都是 50%左右。但是当有两个线程的时候就不一样了，一个线程执行 CPU 计算时，另外一个线程就可以进行 IO 操作，这样 CPU 和 IO 设备两个的利用率就可以在理想情况下达到 100%；</p>
<p><strong>多核时代：</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只有一个 CPU 核心被利用到，而创建多个线程，就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p>
<p><strong>多线程相比单线程的优势，存在什么问题？</strong></p>
<p>多线程适用场景</p>
<p>   1）存在需要等待IO、网络或其他外部资源的任务。当前等待其他资源却依旧占用CPU的线程可让出CPU，让其他线程执行，大大提高了程序效率，充分利用了CPU资源。</p>
<p>   2）存在长时间占用CPU的任务。CPU以时间片为单位分配给各个线程，一个周期内各个线程都可以得到执行，而非卡在一个线程。而且多线程意味着分配到的CPU时间片也更多。</p>
<p>多线程弊端</p>
<p>   1）访问共享资源时要小心，需要更多的锁资源，同步更加复杂。</p>
<p>   2）<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>占用更多，资源开销更大。</p>
<p>   3）需要额外的线程调度和管理。如需要CPU时间来跟踪线程。</p>
<h3 id="👽-线程的基本概念、线程的基本状态以及状态之间的关系。"><a href="#👽-线程的基本概念、线程的基本状态以及状态之间的关系。" class="headerlink" title="👽 线程的基本概念、线程的基本状态以及状态之间的关系。"></a>👽 线程的基本概念、线程的基本状态以及状态之间的关系。</h3><p>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，从宏观上来看，cpu一会执行a线程，一会执行b线程，切换时间很快，给人的感觉是a,b在同时执行。</p>
<p>状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。</p>
<p>调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。</p>
<h3 id="👽-Java的线程模型"><a href="#👽-Java的线程模型" class="headerlink" title="👽 Java的线程模型"></a>👽 Java的线程模型</h3><p>1.用户线程与内核级线程</p>
<p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。</p>
<p>2.并发与并行</p>
<p><strong>并发：</strong>一个时间段内有很多的线程或进程在执行，但任何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。<br><strong>并行：</strong>一个时间段和时间点上都有多个线程或进程在执行。</p>
<p>3.多线程模型</p>
<p>多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。</p>
<h3 id="👽-线程与进程区别？"><a href="#👽-线程与进程区别？" class="headerlink" title="👽 线程与进程区别？"></a>👽 线程与进程区别？</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<h3 id="👽-程序计数器为什么线程是私有的"><a href="#👽-程序计数器为什么线程是私有的" class="headerlink" title="👽 程序计数器为什么线程是私有的?"></a>👽 程序计数器为什么线程是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="👽-虚拟机栈和本地方法栈为什么线程是私有的"><a href="#👽-虚拟机栈和本地方法栈为什么线程是私有的" class="headerlink" title="👽 虚拟机栈和本地方法栈为什么线程是私有的?"></a>👽 虚拟机栈和本地方法栈为什么线程是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="👽-什么是线程上下文切换"><a href="#👽-什么是线程上下文切换" class="headerlink" title="👽 什么是线程上下文切换?"></a>👽 什么是线程上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的<strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="👽-Java多线程编程有几种线程间通信方式"><a href="#👽-Java多线程编程有几种线程间通信方式" class="headerlink" title="👽 Java多线程编程有几种线程间通信方式"></a>👽 Java多线程编程有几种线程间通信方式</h3><ol>
<li><p><strong>共享内存法</strong></p>
<p>volatile，synchronized</p>
</li>
<li><p><strong>wait/notify机制</strong></p>
<p>来自Object类的方法。当满足某种情况时A线程调用wait()方法放弃CPU时间片，并进入阻塞状态。当满足某种条件时，B线程调用notify()方法通知A线程。唤醒A线程，并让它进入可运行状态。</p>
</li>
<li><p><strong>Lock/Condition机制</strong></p>
<p>Condition是Java提供来实现<strong>等待/通知</strong>的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p>
</li>
</ol>
<h3 id="😎-volatile如何实现内存可见性？"><a href="#😎-volatile如何实现内存可见性？" class="headerlink" title="😎 volatile如何实现内存可见性？"></a>😎 volatile如何实现内存可见性？</h3><p><strong>volatile为什么会出现：</strong></p>
<p>首先先分析一下没有volatile的情况下线程在自己的私有内存中对共享变量做出了改变之后无法及时告知其他线程，这就是volatile的作用，解决内存可见性问题。这种问题用synchronized关键字可以解决。但是一个问题是synchronized是重量级锁，同一时间内只允许一个线程去操作共享变量。操作完成之后再将改变后的变量值刷新回共享内存空间中。这样一来的话并发性就没有了。而且<strong>synchronized关键词的使用基于操作系统实现</strong>，会使得线程从用户态陷入内核态。这一步是很耗时间的。于是volatile应运而生。它是一个轻量级的synchronized。只是用来解决内存可见性问题的。</p>
<p><strong>1、volatile可见性实现原理：</strong></p>
<p>变量被volatile关键字修饰后，底层<strong>汇编指令</strong>中会出现一个<strong>lock前缀指令</strong>。会导致以下两种事情的发生：</p>
<ol>
<li>修改volatile变量时会<strong>强制</strong>将修改后的值刷新到主内存中。</li>
<li>修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新读取主内存中的值。</li>
</ol>
<p><strong>2、volatile有序性实现原理：</strong></p>
<p><strong>指令重排序：</strong>编译器在不改变单线程程序语义的前提下，会重新安排语句的执行顺序，指令重排序在单线程下不会有问题，但是在多线程下，可能会出现问题。</p>
<p>volatile有序性的保证就是通过<strong>禁止指令重排序</strong>来实现的。指令重排序包括编译器和处理器重排序，JMM会分别限制这两种指令重排序。禁止指令重排序又是通过加<strong>内存屏障</strong>实现的。</p>
<blockquote>
<p>内存屏障（memory barriers）：也叫内存栅栏，是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。</p>
<ul>
<li>LoadLoad 屏障:对于这样的语句 Load1; LoadLoad; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreStore 屏障: 对于这样的语句 Store1; StoreStore; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li>LoadStore 屏障:对于这样的语句 Load1; LoadStore; Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreLoad 屏障:对于这样的语句 Store1; StoreLoad; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的。 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
</blockquote>
<p>添加了volatile关键字可以避免半初始化的指令重排。</p>
<h3 id="😎-volatile为什么不保证原子性？"><a href="#😎-volatile为什么不保证原子性？" class="headerlink" title="😎 volatile为什么不保证原子性？"></a>😎 volatile为什么不保证原子性？</h3><p>Java中只有对变量的赋值和读取是原子性的，其他的操作都不是原子性的。所以即使volatile即使能保证被修饰的变量具有可见性，但是不能保证原子性。</p>
<h3 id="😎-DCL单例为什么需要加volatile-（半初始化的指令重排）？"><a href="#😎-DCL单例为什么需要加volatile-（半初始化的指令重排）？" class="headerlink" title="😎 DCL单例为什么需要加volatile （半初始化的指令重排）？"></a>😎 DCL单例为什么需要加volatile （半初始化的指令重排）？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。 使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<p>volatile两个作用：保持线程可见性；<strong>禁止指令重排序</strong>。</p>
<p><strong>DCL单例需要加volatile，来禁止指令重排。</strong></p>
<p>由于java编译器允许处理器乱序执行（以获得最优的性能），new对象的操作不是原子性的。这句代码最终会被编译成多条汇编指令。所以需要volatile关键字来禁止指令重排。</p>
<p><strong>创建一个对象的过程中一旦出现了指令重排，可能就会获得半初始化的对象，</strong>即还没来得及赋值就先建立了引用关系。要避免这种情况的发生就要使用volatile关键字修饰实列变量。</p>
<p><strong>第一次判断singleton是否为null</strong><br>  第一次判断是在Synchronized同步代码块外进行判断，由于单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以，第一次判断，是为了在singleton对象已经创建的情况下，避免进入同步代码块，提升效率。</p>
<p><strong>第二次判断singleton是否为null</strong><br>  第二次判断是为了避免以下情况的发生。<br>  (1)假设：线程A已经经过第一次判断，判断singleton=null，准备进入同步代码块.<br>  (2)此时线程B获得时间片，由于线程A并没有创建实例，所以，判断singleton仍然=null，所以线程B创建了实例singleton。<br>  (3)此时，线程A再次获得时间片，由于刚刚经过第一次判断singleton=null(不会重复判断)，进入同步代码块，这个时候，我们如果不加入第二次判断的话，那么线程A又会创造一个实例singleton，就不满足我们的单例模式的要求，所以第二次判断是很有必要的。</p>
<h3 id="😎-happen-before原则"><a href="#😎-happen-before原则" class="headerlink" title="😎 happen-before原则"></a>😎 happen-before原则</h3><ul>
<li>单线程 happen-before 原则:在同一个线程中，书写在前面的操作 happen- before 后面的操作。 锁的 happen-before 原则:同一个锁的 unlock 操作 happen-before 此锁的 lock 操作。</li>
<li>volatile 的 happen-before 原则:对一个 volatile 变量的写操作 happen- before 对此变量的任意操作(当然也包括写操作了)。</li>
<li>happen-before 的传递性原则:如果 A 操作 happen-before B 操作，B 操作 happen-before C 操作，那么 A 操作 happen-before C 操作。</li>
<li>线程启动的 happen-before 原则:同一个线程的 start 方法 happen-before 此线程的其它方法。</li>
<li>线程中断的 happen-before 原则 :对线程 interrupt 方法的调用 happen- before 被中断线程的检测到中断发送的代码。</li>
<li>线程终结的 happen-before 原则: 线程中的所有操作都 happen-before 线程的终止检测。</li>
<li>对象创建的 happen-before 原则: 一个对象的初始化完成先于他的 finalize 方法调用。</li>
</ul>
<h3 id="👻-Thread-Local-作用、原理、内存泄漏问题？"><a href="#👻-Thread-Local-作用、原理、内存泄漏问题？" class="headerlink" title="👻 Thread Local 作用、原理、内存泄漏问题？"></a>👻 Thread Local 作用、原理、内存泄漏问题？</h3><p><strong>作用：</strong></p>
<p><code>ThreadLocal</code>为解决多线程下的线程安全问题提供了一个新思路，它通过为每一个线程提供一个独立的变量副本解决了线程并发访问共享变量出现的安全问题。在很多情况下<code>ThreadLocal</code>比直接使用synchronized同步机制解决线程安全问题更加方便、简洁。且拥有更加高的并发性。</p>
<p><strong>原理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在每个线程Thread内部有一个<code>ThreadLocal.ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，这个<code>threadLocals</code>就是用来<strong>存储实际的变量副本</strong>的，键值为当前<code>ThreadLocal</code>的引用，value为变量副本（即T类型的变量）。</li>
<li>初始时，在Thread里面，<code>threadLocals</code>为空，当通过<code>ThreadLocal</code>变量调用get()方法或者set()方法，就会对Thread类中的<code>threadLocals</code>进行初始化，并且以当前<code>ThreadLocal</code>对象引用为键值，以<code>ThreadLocal</code>要保存的副本变量为value，存到<code>threadLocals</code>。</li>
<li>然后在当前线程里面，如果要使用副本变量，就可以通过get()方法在<code>threadLocals</code>里面查找。</li>
</ol>
<p><strong><code>ThreadLocal</code>内存泄漏</strong></p>
<p>由于<code>ThreadLocalMap</code>的key是弱引用，而<code>Value</code>是强引用。这就导致了一个问题，<code>ThreadLocal</code>在没有外部对象强引用时，发生GC时（无论是否OOM）弱引用Key会被回收。这个时候就会出现Entry中Key已经被回收，出现一个<code>null Key</code>的情况，外部读取<code>ThreadLocalMap</code>中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的<code>ThreadLocalMap</code>对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：<code>Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value</code>，这条强引用链会导致<code>Entry</code>不会回收， <code>Value</code>也不会回收，但Entry中的Key却已经被回收的情况，造成<strong>内存泄漏</strong>。</p>
<p><strong>解决办法：</strong>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</p>
<p><strong><code>ThreadLocal</code>应用场景</strong></p>
<p>最常见的<code>ThreadLocal</code>使用场景为用来解决数据库连接、Session管理等。</p>
<h3 id="😎🤢-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#😎🤢-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="😎🤢 说说 synchronized 关键字和 volatile 关键字的区别"></a>😎🤢 说说 synchronized 关键字和 volatile 关键字的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h3 id="😀-自旋锁-VS-适应性自旋锁"><a href="#😀-自旋锁-VS-适应性自旋锁" class="headerlink" title="😀 自旋锁 VS 适应性自旋锁"></a>😀 自旋锁 VS 适应性自旋锁</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是<strong>自旋锁</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/452a3363-20231217152835634.png" alt="img"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/83b3f85e.png" alt="img"></p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p><strong>自适应</strong>意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h3 id="🤢-Synchronized与ReentrantLock的区别？"><a href="#🤢-Synchronized与ReentrantLock的区别？" class="headerlink" title="🤢 Synchronized与ReentrantLock的区别？"></a>🤢 Synchronized与ReentrantLock的区别？</h3><p><strong>实现原理上:</strong></p>
<p><code>synchronized</code>是依靠<code>jvm</code>以及配合操作系统来实现，是一个<strong>关键字</strong>。<code>reentrantLock</code>是<code>jdk1.5</code>之后提供的<strong>API层面</strong>的互斥锁，实现了Lock接口。</p>
<p><strong>使用便利性上：</strong></p>
<p><code>synchronized</code>只需要添加上相关关键字即可，加锁与释放过程由操作系统完成。<code>reentrantLock</code>则需要手动加锁与释放锁。</p>
<p><strong>锁粒度与灵活度：</strong></p>
<p>reentrantLock<code>要强于</code>synchronized</p>
<p><code>reentrantLock</code>提供了<strong>三个高级功能</strong>:</p>
<ol>
<li><strong>等待可中断</strong>，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相对于Synchronized来说可以避免出现死锁的情况。通过<code>lock.lockInterruptibly()</code>来实现这个机制。</li>
<li>Synchronized锁是非公平锁，<code>ReentrantLock</code>默认的构造函数是创建的非公平锁，但可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
<li>一个<code>ReentrantLock</code>对象可以同时绑定多个对象。<code>ReenTrantLock</code>提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
</ol>
<p><strong>性能区别：</strong></p>
<p><code>synchronized</code>优化之后性能与<code>reentrantLock</code>已经不相上下了，官方甚至更建议使用<code>synchronized</code>关键字。</p>
<h3 id="🤢-synchronized修饰的对象"><a href="#🤢-synchronized修饰的对象" class="headerlink" title="🤢 synchronized修饰的对象"></a>🤢 synchronized修饰的对象</h3><ul>
<li>修饰一个类：其作用的范围是synchronized后面括号括起来的部分，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个方法：被修饰的方法称为同步方法，其作用的范围是整个方法，<strong>作用的对象是调用这个方法的对象</strong>；</li>
<li>修饰一个静态的方法：其作用的范围是整个方法，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个代码块：被修饰的代码块称为同步语句块，其作用范围是大括号{}括起来的代码块，<strong>作用的对象是调用这个代码块的对象</strong>；</li>
</ul>
<h3 id="🤢-Synchronized实现原理？"><a href="#🤢-Synchronized实现原理？" class="headerlink" title="🤢 Synchronized实现原理？"></a>🤢 Synchronized实现原理？</h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>每个对象（在对象头中）有一个<strong>监视器锁</strong><code>（monitor）</code>，当monitor被占用时就处于锁定状态。线程执行<code>monitorenter</code>（汇编指令）尝试获取monitor的所有权。实现原子性操作和解决共享变量的内存可见性问题。</p>
<ol>
<li>如果monitor计数器当前值为0，那么该线程进入monitor并将计数器加1，</li>
<li>如果当前monitor计数器值不为0，那么该线程阻塞并进入（OS维护的）队列等待，等到OS的调度。</li>
</ol>
<p>底层字节码被编译成<code>monitorenter</code>和<code>monitorexit</code>两个指令。线程执行<code>monitorexit</code>指令，monitor计数器减1，如果减到0了，表示当前线程不再拥有该监视器锁。等待队列中的线程有机会获得锁资源。</p>
<p><strong>内部处理过程</strong>(内部有两个队列waitSet和entryList):</p>
<ul>
<li>1、当多个线程进入同步代码块时，首先进入entryList</li>
<li>2、有一个线程获取到monitor锁后，就将对象头的Mark Word中的线程ID设置为当前线程，并且计数器+1</li>
<li>3、如果线程调用wait方法，将释放锁，当前线程ID置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</li>
<li>4、如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220701233410657-20231217152836086.png" alt="image-20220701233410657"></p>
<p>在synchronized大（优化）升级之前，是重量级锁，锁操作都要经过OS。向OS内核去申请。（<code>jdk1.5之后</code>）到现在的synchronized是有一个复杂的锁升级过程。</p>
<p><strong>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁） -&gt; （重量级锁）悲观锁。</strong></p>
<p>以上的升级状态都记录在对象头中。</p>
<p><strong>偏向锁：</strong>hotspot虚拟机认为大多数时间是不存在锁竞争的，所以每次都会把锁分配给上一次获得锁的线程，直到出现了锁竞争。</p>
<p><strong>自旋锁：</strong>线程之间以CAS的方式进行锁资源的争抢。当一个线程自旋超过了10次或者当前自旋等待的线程超过了CPU核数的1/2（升级后优化为自适应自旋），会进行锁升级。</p>
<p><strong>synchronized：</strong> 向OS申请资源，从用户态切换到内核态。线程挂起进入<strong>等待队列</strong>，等待OS的调度。然后再映射回用户空间。</p>
<h3 id="🤢-获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？"><a href="#🤢-获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？" class="headerlink" title="🤢 获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？"></a>🤢 获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？</h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor 实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><a href="https://mp.weixin.qq.com/s/VUwexGERUjTeMnDEpRMB3g">一文全面梳理各种锁机制</a></p>
<h3 id="🤢-Synchronized的锁升级过程"><a href="#🤢-Synchronized的锁升级过程" class="headerlink" title="🤢 Synchronized的锁升级过程"></a>🤢 Synchronized的锁升级过程</h3><p>首先为什么Synchronized能实现线程同步？</p>
<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<p><strong>Java对象头</strong>:</p>
<p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>Monitor:</strong></p>
<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220707164758951.png" alt="image-20220707164758951"></p>
<p><strong>无锁</strong></p>
<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<p><strong>轻量级锁</strong></p>
<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/8afdf6f2-20231217152836445.png" alt="img"></p>
<p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h3 id="🤢-为什么说-Synchronized-是可重入锁？"><a href="#🤢-为什么说-Synchronized-是可重入锁？" class="headerlink" title="🤢 为什么说 Synchronized 是可重入锁？"></a>🤢 为什么说 Synchronized 是可重入锁？</h3><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220309201446490.png" alt="image-20220309201446490"></p>
<h3 id="🤢-synchronized可重入锁的实现？"><a href="#🤢-synchronized可重入锁的实现？" class="headerlink" title="🤢 synchronized可重入锁的实现？"></a>🤢 synchronized可重入锁的实现？</h3><p>重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p>
<h3 id="🤢-为什么说-Synchronized-是非公平锁"><a href="#🤢-为什么说-Synchronized-是非公平锁" class="headerlink" title="🤢 为什么说 Synchronized 是非公平锁?"></a>🤢 为什么说 Synchronized 是非公平锁?</h3><p>Synchronized底层是调用mutex锁的，内核提供的这个锁并不保证公平。而Java所提供的公平锁Lock实际上是由Java的API支持的（即对AQS的实现）</p>
<p>非公平是指在获取锁的行为上，并不是按照线程申请顺序进行分配的，当锁被释放后，所有线程都有机会获取到锁，这样提高了性能，但是可能会出现某些线程饥饿的情况。</p>
<h3 id="🤢-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#🤢-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="🤢 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>🤢 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><p>分几种情况：</p>
<p>1）其他方法前是否加了synchronized关键字，如果没加，则能。</p>
<p>2）如果这个方法内部调用了wait，则可以进入其他synchronized方法。</p>
<p>3）如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</p>
<p>4）如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</p>
<h3 id="🤢-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？"><a href="#🤢-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？" class="headerlink" title="🤢 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？"></a>🤢 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？</h3><p>当 Synchronized升级为重量级锁时，他是一个悲观锁。<strong>获取不到锁资源的线程由OS统一管理</strong>，涉及到用户态到内核态的切换。</p>
<p>乐观锁就是，当一个线程想要对变量进行操作时，先读取变量值，然后真正更改时会再次对比当前值与自己之前读取的值是否相同，相同才会进行更改，不相同的话就会再次读取，然后在进行对比更改。主要是基于CAS实现。</p>
<h3 id="😡-悲观锁和乐观锁的区别"><a href="#😡-悲观锁和乐观锁的区别" class="headerlink" title="😡 悲观锁和乐观锁的区别"></a>😡 悲观锁和乐观锁的区别</h3><p><a href="https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82">https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82</a></p>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>
<ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>
</ul>
<h3 id="😡-MySQL如何实现乐观锁？"><a href="#😡-MySQL如何实现乐观锁？" class="headerlink" title="😡 MySQL如何实现乐观锁？"></a>😡 MySQL如何实现乐观锁？</h3><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p>
<p>乐观锁的实现原理：</p>
<ol>
<li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。</li>
<li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。</li>
<li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li>
</ol>
<p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h3 id="🧑-CAS原理"><a href="#🧑-CAS原理" class="headerlink" title="🧑 CAS原理"></a>🧑 CAS原理</h3><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V。</li>
<li>进行比较的值 A。</li>
<li>要写入的新值 B。</li>
</ul>
<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>
<p>CAS具有原子性,他的原子性由CPU保证,由JNI调用c++硬件代码实现,<code>jdk</code>中提供了unsafe来进行这些操作。</p>
<h3 id="🧑-CAS乐观锁有什么缺点？"><a href="#🧑-CAS乐观锁有什么缺点？" class="headerlink" title="🧑 CAS乐观锁有什么缺点？"></a>🧑 CAS乐观锁有什么缺点？</h3><ol>
<li>乐观锁的情况下，如果线程并发度确实很高，那么大多数的线程都会处于自旋等待以获取锁对象的状态。这样会导致CPU占用过高。</li>
<li>CAS另一个缺点就是ABA问题。一个值从A改为B又改为A,则CAS认为没有发生变化,解决的方式是使用<strong>版本号</strong>来记录操作次数。或者使用Java中提供的AtomicStampedReference，增加了标志字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部满足条件才会更新</li>
<li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/ID6_DQAuv6ire3u58XpSrg">CAS原理分析，解决银行转账ABA难题</a></p>
<h3 id="🐱-什么是锁消除和锁粗化？"><a href="#🐱-什么是锁消除和锁粗化？" class="headerlink" title="🐱 什么是锁消除和锁粗化？"></a>🐱 什么是锁消除和锁粗化？</h3><p>锁消除即删除不必要的加锁操作。JVM在运行时，对一些“在代码上要求同步，但是<strong>被检测到不可能存在共享数据竞争情况”的锁进行消除</strong>。根据代码逃逸技术，如果判断到一段代码中，<strong>堆上的数据不会逃逸出当前线程</strong>，那么就可以认为这段代码是线程安全的，无需加锁。</p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockClearTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearTest</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            test.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer的append代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码看出来，StringBuffer的append是个同步方法，但是LockClearTest中的 StringBuffer 属于一个局部变量，不可能从该方法中逃逸出去（即stringBuffer的引用没有传递到该方法外，不会被其他线程引用），因此其实这过程是线程安全的，可以将锁消除。</p>
<p>假设一系列的连续操作都会<strong>对同一个对象反复加锁及解锁</strong>，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会<strong>扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</strong></p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码每次调用 stringBuffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h3 id="🐱-AtomicInteger原子类源码解析"><a href="#🐱-AtomicInteger原子类源码解析" class="headerlink" title="🐱 AtomicInteger原子类源码解析"></a>🐱 AtomicInteger原子类源码解析</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/feda866e.png" alt="img"></p>
<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li>unsafe： 获取并操作内存的数据。</li>
<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>
<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>
</ul>
<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">  <span class="type">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>
<h3 id="🤢-ReentrantLock实现原理？"><a href="#🤢-ReentrantLock实现原理？" class="headerlink" title="🤢 ReentrantLock实现原理？"></a>🤢 ReentrantLock实现原理？</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/7aadb272069d871bdee8bf3a218eed8136919-20231217152837112.png" alt="img"></p>
<p>加锁：</p>
<ul>
<li>通过 ReentrantLock 的加锁方法 Lock 进行加锁操作。</li>
<li>会调用到内部类 Sync 的 Lock 方法，由于 Sync#lock 是抽象方法，根据 ReentrantLock 初始化选择的公平锁和非公平锁，执行相关内部类的 Lock 方法，本质上都会执行 AQS 的 Acquire 方法。</li>
<li>AQS 的 Acquire 方法会执行 tryAcquire 方法，但是由于 tryAcquire 需要自定义同步器实现，因此执行了 ReentrantLock 中的 tryAcquire 方法，由于 ReentrantLock 是通过公平锁和非公平锁内部类实现的 tryAcquire 方法，因此会根据锁类型不同，执行不同的 tryAcquire。</li>
<li>tryAcquire 是获取锁逻辑，获取失败后，会执行框架 AQS 的后续逻辑，跟 ReentrantLock 自定义同步器无关。</li>
</ul>
<p>解锁：</p>
<ul>
<li>通过 ReentrantLock 的解锁方法 Unlock 进行解锁。</li>
<li>Unlock 会调用内部类 Sync 的 Release 方法，该方法继承于 AQS。</li>
<li>Release 中会调用 tryRelease 方法，tryRelease 需要自定义同步器实现，tryRelease 只在 ReentrantLock 中的 Sync 实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>
<li>释放成功后，所有处理由 AQS 框架完成，与自定义同步器无关。</li>
</ul>
<p>通过上面的描述，大概可以总结出 ReentrantLock 加锁解锁时 API 层核心方法的映射关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt="img"></p>
<h3 id="🤢-AQS原理？"><a href="#🤢-AQS原理？" class="headerlink" title="🤢 AQS原理？"></a>🤢 AQS原理？</h3><p>AQS框架是用来构建锁的同步器框架,包括了常用的<code>ReentrantLock</code>,<code>ReadWriteLock</code>,<code>CountDownLatch</code>等都是基于AQS框架来实现的。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS 使用一个 int 成员变量state来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态state进行原子操作实现对其值的修改。一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把 state 重新置为0，同时 当前线程ID 置为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🤢-AQS中的公平锁和非公平锁"><a href="#🤢-AQS中的公平锁和非公平锁" class="headerlink" title="🤢 AQS中的公平锁和非公平锁"></a>🤢 AQS中的公平锁和非公平锁</h3><ul>
<li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<p><code>ReentrantLock</code> 默认采用非公平锁，因为考虑获得更好的性能，通过 <code>boolean</code> 来决定是否用公平锁（传入 true 用公平锁）。</p>
<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h3 id="🤢-AQS内部如何控制并发？"><a href="#🤢-AQS内部如何控制并发？" class="headerlink" title="🤢 AQS内部如何控制并发？"></a>🤢 AQS内部如何控制并发？</h3><p><code>AQS（AbstractQueuedSynchronizer）</code>是<code>J.U.C</code>包下<strong>lock</strong>实现的核心。主要是其提供的一个FIFO的队列来维护获取锁失败而进入阻塞的线程，以及一个volatile关键字修饰的state变量表示当前同步状态。当一个线程获取到同步状态（修改state=1），那么其他线程便无法获取，转而被构造成节点并加入同步队列中。<strong>加入队列的过程基于CAS算法。即比较当前线程认为的尾节点与当前节点，比较成功后才能正式加入队列尾部。</strong>队列头节点表示的为当前正在运行的线程，该线程执行结束后会激活它下面的一个线程进入执行状态。</p>
<p>FIFO同步队列控制并发。</p>
<h3 id="🤢-AQS为什么底层使用CAS和volatile？"><a href="#🤢-AQS为什么底层使用CAS和volatile？" class="headerlink" title="🤢 AQS为什么底层使用CAS和volatile？"></a>🤢 AQS为什么底层使用CAS和volatile？</h3><ol>
<li>AQS源码中<code>state</code>状态值使用<code>volatile</code>修饰保证内存的可见性。因为涉及到多线程对state的修改，必须保证其对所有线程的可见性。</li>
<li>CAS操作主要用于对state值的修改。</li>
</ol>
<h3 id="😡-了解CountDownLatch吗？"><a href="#😡-了解CountDownLatch吗？" class="headerlink" title="😡 了解CountDownLatch吗？"></a>😡 了解CountDownLatch吗？</h3><p>一个或者多个线程，等待其他多个线程完成某件事情之后才能执行;</p>
<p>主要包含两个方法，一个是<code>countDown()</code>，一个是<code>await()</code>;以及一个计数器变量<code>cnt</code>。<code>countDown()</code> 方法用来给计数器<code>cnt</code>减一； <code>await()</code> 方法是用来阻塞当前线程，直到计数器为0的时候再唤醒线程继续执行；</p>
<h3 id="😡-了解CyclicBarrier吗？"><a href="#😡-了解CyclicBarrier吗？" class="headerlink" title="😡 了解CyclicBarrier吗？"></a>😡 了解CyclicBarrier吗？</h3><p>多个线程互相等待，直到到达同一个同步点，再继续一起执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220909195445283-20231217152837474.png" alt="image-20220909195445283"  /></p>
<h3 id="😡-了解Semaphore吗"><a href="#😡-了解Semaphore吗" class="headerlink" title="😡 了解Semaphore吗?"></a>😡 了解Semaphore吗?</h3><p>信号量，用于多个共享资源的互斥使用，也可以<strong>用来控制线程的并发量</strong>，类似于线程池的作用。</p>
<p>可以用于限制线程的并发数。                                                                                                                                        </p>
<h3 id="😓-产生死锁必须具备以下四个条件"><a href="#😓-产生死锁必须具备以下四个条件" class="headerlink" title="😓 产生死锁必须具备以下四个条件"></a>😓 产生死锁必须具备以下四个条件</h3><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="😓-如何预防和避免线程死锁"><a href="#😓-如何预防和避免线程死锁" class="headerlink" title="😓 如何预防和避免线程死锁?"></a>😓 如何预防和避免线程死锁?</h3><p><a href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<p>​    1.<strong>破坏互斥条件</strong>:使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p> <strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。</p>
<h3 id="😓-死锁的产生、防止、避免、检测和解除"><a href="#😓-死锁的产生、防止、避免、检测和解除" class="headerlink" title="😓 死锁的产生、防止、避免、检测和解除"></a>😓 死锁的产生、防止、避免、检测和解除</h3><p><a href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<h3 id="😭-线程池以及使用线程池的好处"><a href="#😭-线程池以及使用线程池的好处" class="headerlink" title="😭 线程池以及使用线程池的好处"></a>😭 线程池以及使用线程池的好处</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p>
<h3 id="😭-线程池的创建方式（7种）"><a href="#😭-线程池的创建方式（7种）" class="headerlink" title="😭 线程池的创建方式（7种）"></a>😭 线程池的创建方式（7种）</h3><p>线程池的创建方法总共有 7 种，但总体来说可分为 2 类：</p>
<ul>
<li>一类是通过 <code>ThreadPoolExecutor</code> 创建的线程池；</li>
<li>另一个类是通过 <code>Executors</code> 创建的线程池。</li>
</ul>
<p>线程池的创建方式总共包含以下 7 种（其中 6 种是通过 <code>Executors</code> 创建的，1 种是通过 <code>ThreadPoolExecutor</code> 创建的）：</p>
<ol>
<li><strong>Executors.newFixedThreadPool（nThreads）</strong>：该方法创建一个固定数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行，若没有，则新的任务会被 暂存在一个任务<a href="https://so.csdn.net/so/search?q=队列&amp;spm=1001.2101.3001.7020">队列</a>中，待有空闲线程时，便处理在任务队列中的任务。</li>
<li><strong>Executors.newCachedThreadPool</strong>：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先 使用可复用的线程。 若所有线程均工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前安任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>Executors.newSingleThreadExecutor</strong>：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。虽然是单线程池，但提供了工作队列，生命周期管理，工作线程维护等功能。</li>
<li><strong>Executors.newScheduledThreadPool</strong>：创建一个可以执行延迟任务的线程池；</li>
<li><strong>Executors.newSingleThreadScheduledExecutor</strong>：创建一个单线程的可以执行延迟任务的线程池；虽然是单线程池，但提供了工作队列，生命周期管理，工作线程维护等功能。</li>
<li><strong>Executors.newWorkStealingPool</strong>：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li>
<li><strong>ThreadPoolExecutor</strong>：最原始的创建线程池的方式，它包含了 7 个参数可供设置</li>
</ol>
<h3 id="😭-线程池中的工作队列"><a href="#😭-线程池中的工作队列" class="headerlink" title="😭 线程池中的工作队列"></a>😭 线程池中的工作队列</h3><p>参数workQueue 指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象。 根据队列功能分类，在ThreadPoolExecutor的构造函数中可使用一下几种BlockingQueue。</p>
<p><strong>直接提交的队列</strong>： 该功能由 <strong>SynchronousQueue</strong>对象提供。SynchronousQueue 是一个特殊的BlocingQueue。 它没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如皋市使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的进程，则尝试创建新的进程，如果进程的数量已达到最大值，则执行拒绝策略。</p>
<p><strong>有界的任务队列</strong><br>有界的任务队列可以使用<strong>ArrayBlockingQueue</strong>实现。当使用有界队列时，若有新的任务需要执行，如果线程池的实际线程数小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务假如等待队列。若等待队列已满，无法加入，在总线程数，不大于maximumPoolSize的前提下，创建新的进程执行任务。若大于maximumPoolSize，则执行拒绝策略。</p>
<p><strong>无界的任务队列</strong><br>无界的任务队列可以通过<strong>LinkedBlockingQueue</strong>类实现。与有界队列相反，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，线程池会产生新的线程执行任务，但当系统的线程数达到corePoolSize后，就会继续增加。若后续仍有新的任务假如，而又没有空闲的线程资源，则任务直接进入对列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，知道耗尽系统内存。</p>
<p><strong>任务优先队列</strong><br>优先任务队列是带有执行优先级的队列，它通过<strong>PriorityBlockingQueue</strong>实现，可以控制任务的只想你个先后顺序。它是一个特殊的无界队列。</p>
<h3 id="😭-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#😭-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="😭 执行 execute()方法和 submit()方法的区别是什么呢？"></a>😭 执行 execute()方法和 submit()方法的区别是什么呢？</h3><p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="😭-Thread和Runnable的关系"><a href="#😭-Thread和Runnable的关系" class="headerlink" title="😭 Thread和Runnable的关系"></a>😭 Thread和Runnable的关系</h3><p>对于Thread，我们是定义一个类继承Thread，实现Thread中的run方法，然后new一个这个类的对象，调用类的start方法。当执行 start() 后，线程进入就绪状态，当对应的线程抢占到 cpu 调度资源之后，进入运行状态，此时调用的是 run 方法，执行完毕之后就结束了。</p>
<p>对于Runnable，一般是定义一个类MyTask实现Runnable接口，重写其中的run方法，这里 MyTask 就是一个 Runnable，实现了 run() 方法，作为 Thread() 的入参。</p>
<p>在Runnable的接口定义中的run方法中，<strong>当一个对象继承并实现了 run() 方法，当线程 start() 后，会在该线程中单独执行该对象的 run() 方法。</strong>所以Runnable和T患儿add的关系如下：</p>
<ol>
<li>MyTask 继承 Runnable，并实现了 run() 方法；</li>
<li>Thread 初始化，将 MyTask 作为自己的成员变量；</li>
<li>Thread 执行 run() 方法，线程处于“就绪”状态；</li>
<li>等待 CPU 调度，执行 Thread 的 run() 方法，但是 run() 的内部实现，其实是执行的 MyTask.run() 方法，线程处于“运行”状态。</li>
</ol>
<p>在Thread的源码中，在 Thread 初始化时，<strong>MyTask 作为入参 target，最后赋值给 Thread.target</strong>。当执行 Thread.run() 时，<strong>其实是执行的 target.run()，即 MyTask.run()，这个是典型的策略模式</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/640-20231217134127534-20231217152837660.png" alt="图片"></p>
<p>其实对于 Thread 和 Runable，其 run() 都是无返回值的，并且无法抛出异常，<strong>所以当你需要返回多线程的数据，就需要借助 Callable 和 Future。</strong></p>
<h3 id="😭-Callable和FutureTask的关系"><a href="#😭-Callable和FutureTask的关系" class="headerlink" title="😭 Callable和FutureTask的关系"></a>😭 Callable和FutureTask的关系</h3><p>Callable 是一个接口，里面有个 V call() 方法，这个 V 就是我们的返回值类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般会用匿名类的方式使用 Callable，call() 中是具体的业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is Callable is running&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过关系图谱，FutureTask 继承了 RunnableFuture，RunnableFuture 继承了 Runnable 和 Future.<strong>所以，FutureTask 也是个 Runnable ！</strong>既然 FutureTask 是个 Runnable，肯定就需要实现.run() 方法，那么 FutureTask 也可以作为 Thread 的初始化入参，使用姿势如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(FutureTask对象).start();</span><br></pre></td></tr></table></figure>
<p><strong>所以当执行 Thread.run() 时，其实是执行的 FutureTask.run()</strong></p>
<p><strong>Callable 和 FutureTask 的关系</strong>:</p>
<p>FutureTask 初始化时，Callable 必须作为 FutureTask 的初始化入参：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/640-20220815133621982.png" alt="图片"></p>
<p>当执行 FutureTask.run() 时，其实执行的是 Callable.call(),<strong>所以，这里又是一个典型的策略模式 ！</strong></p>
<p>现在我们应该可以很清楚知道 Thread 、Runnable、FutureTask 和 Callable 的关系：</p>
<ul>
<li>Thread.run() 执行的是 Runnable.run()；</li>
<li>FutureTask 继承了 Runnable，并实现了 FutureTask.run()；</li>
<li>FutureTask.run() 执行的是 Callable.run()；</li>
<li>依次传递，最后 Thread.run()，其实是执行的 Callable.run()。</li>
</ul>
<p>所以整个设计方法，其实就是 2 个策略模式，<strong>Thread 和 Runnable 是一个策略模式，FutureTask 和 Callable 又是一个策略模式，最后通过 Runnable 和 FutureTask 的继承关系，将这 2 个策略模式组合在一起。</strong></p>
<h3 id="😭-Future是什么？怎么使用？"><a href="#😭-Future是什么？怎么使用？" class="headerlink" title="😭 Future是什么？怎么使用？"></a>😭 Future是什么？怎么使用？</h3><p>Future可以当成是我们收货的凭证，当某些任务非常耗时的时候，我们可以先另起一个线程异步执行这个耗时的任务，同时拿到这个Future凭证。当我们这个线程结束相关的任务，想要获得结果的时候，就调用其中的<code>get()</code>方法获得结果。</p>
<ol>
<li>新建一个<code>Callable</code>匿名函数实现类对象，将业务逻辑放在<code>call()</code>之中，同时将<code>`Callable</code>的泛型设置成我们想要的返回结果类型</li>
<li>将<code>Callable</code>匿名函数对象作为<code>FutureTask</code>的构造参数传入，创建一个<code>futureTask</code>对象</li>
<li>再将<code>futureTask</code>作为<code>Thread</code>的构造参数传入，开启另一线程执行逻辑</li>
<li>在需要得到结果时候调用<code>futureTask</code>的<code>get()</code>方法。</li>
</ol>
<p>我们看一下 Future 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务，如果任务正在运行的，mayInterruptIfRunning为true时，表明这个任务会被打断的，并返回true；</span></span><br><span class="line">    <span class="comment">// 为false时，会等待这个任务执行完，返回true；若任务还没执行，取消任务后返回true，如任务执行完，返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消了,正常执行完不算被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成，任务取消或发生异常也算是完成，返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务返回结果，如果任务没有执行完成则等待完成将结果返回，如果获取的过程中发生异常就抛出异常，</span></span><br><span class="line">    <span class="comment">// 比如中断就会抛出InterruptedException异常等异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 在规定的时间如果没有返回结果就会抛出TimeoutException异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 FutureTask，Callable 就是他的任务，而 FutureTask 内部维护了一个任务状态，所有的状态都是围绕这个任务来进行的，随着任务的进行，状态也在不断的更新。</p>
<p>FutureTask 继承了 Future，实现对任务的取消、数据获取、任务状态判断等功能。</p>
<p>比如我们经常会调用 get() 方法获取数据，如果任务没有执行完成，会将当前线程放入阻塞队列等待，当任务执行完后，会唤醒阻塞队列中的线程。</p>
<h3 id="😭-FutureTask用来解决什么问题？"><a href="#😭-FutureTask用来解决什么问题？" class="headerlink" title="😭 FutureTask用来解决什么问题？"></a>😭 FutureTask用来解决什么问题？</h3><p>FutureTask可看作对异步任务的封装，异步任务在它的封装下，可灵活进行阻塞获取结果或者中断。它继承了Runable以及Future接口，所以它可以灵活的作为Runnable给thread执行，也可作为Future得到callable的计算结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/d0c8df53db8f45bf9295b1806d2db804~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片.png"></p>
<h3 id="😭-ThreadPoolExecutor构造函数重要参数分析"><a href="#😭-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="😭 ThreadPoolExecutor构造函数重要参数分析"></a>😭 <code>ThreadPoolExecutor</code>构造函数重要参数分析</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :线程工厂。</li>
<li><strong><code>handler</code></strong> :拒绝策略。</li>
</ol>
<p>​         <strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求，将工作队列中等待在最前面的任务丢弃，然后将新来的任务放进等待队列中。</li>
</ul>
<p>更多内容，参考<a href="https://mp.weixin.qq.com/s/SsbQc6WhFJxCarpRLGqzSA">史上最全ThreadPoolExecutor梳理(上篇)</a>，<a href="https://mp.weixin.qq.com/s/ZuD0amF-A4X7VeMuc_LJkg">史上最全ThreadPoolExecutor梳理(下篇)</a></p>
<h3 id="😭-提交一个任务到线程池的执行流程"><a href="#😭-提交一个任务到线程池的执行流程" class="headerlink" title="😭 提交一个任务到线程池的执行流程"></a>😭 提交一个任务到线程池的执行流程</h3><p>1.当线程池新加入一个线程时，首先判断当前线程数，是否小于coreSize，如果小于，则执行步骤2，否则执行3<br>2.创建新线程添加到线程池中，跳转结束<br>3.判断当前线程池等待队列是否已满，若已满，则跳转至步骤5<br>4.加入等待队列，等待线程池空闲，跳转结束<br>5.判断当前线程数是否已达到maximumPoolSize，若未达到，则跳转至步骤7<br>6.执行线程池拒绝策略，跳转结束<br>7.创建一个新线程，执行任务<br>8.跳转结束</p>
<h3 id="😭-线程池的参数怎么设置？"><a href="#😭-线程池的参数怎么设置？" class="headerlink" title="😭 线程池的参数怎么设置？"></a>😭 线程池的参数怎么设置？</h3><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="🤣-BIO-NIO-AIO"><a href="#🤣-BIO-NIO-AIO" class="headerlink" title="🤣 BIO/NIO/AIO"></a>🤣 BIO/NIO/AIO</h3><h4 id="Java中的IO原理"><a href="#Java中的IO原理" class="headerlink" title="Java中的IO原理"></a>Java中的IO原理</h4><p>首先Java中的IO都是依赖操作系统内核进行的，我们程序中的IO读写其实调用的是操作系统内核中的read&amp;write两大系统调用。</p>
<p>那内核是如何进行IO交互的呢？</p>
<ol>
<li>网卡收到经过网线传来的网络数据，并将网络数据写到内存中。</li>
<li>当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</li>
<li>将内存中的网络数据写入到对应socket的接收缓冲区中。</li>
<li>当接收缓冲区的数据写好之后，应用程序开始进行数据处理。</li>
</ol>
<p>对应抽象到java的socket代码简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//获取数据进行处理</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// socket、server，流关闭操作，省略不表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个过程和底层内核的网络IO很类似，主要体现在accept()等待从网络中的请求到来然后bytes[]数组作为缓冲区等待数据填满后进行处理。而BIO、NIO、AIO之间的区别就在于这些操作是同步还是异步，阻塞还是非阻塞。</p>
<p>所以我们引出同步异步，阻塞与非阻塞的概念。</p>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们的执行流程中：依次是方法一和方法二。</p>
<p>同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。</p>
<p>异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。</p>
<p>同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。</p>
<p>同步与异步是从多个线程之间的协调来实现效率差异。</p>
<blockquote>
<p>为什么需要异步呢？笔者认为异步的本质就是为了解决主线程的阻塞，所以网上很多讨论把同步异步、阻塞非阻塞进行了四种组合，其中一种就有异步阻塞这一情形，如果异步也是阻塞的？那为什么要特地进行异步操作呢？</p>
</blockquote>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p>
<p>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</p>
<p>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。</p>
<p>阻塞与非阻塞关注的是线程是否在原地等待。</p>
<blockquote>
<p>笔者认为阻塞和非阻塞仅能与同步进行组合。而异步天然就是非阻塞的，而这个非阻塞是对主线程而言。（可能有人认为异步方法里面放入阻塞操作的话就是异步阻塞，但是思考一下，正是因为是阻塞操作所以才会将它放入异步方法中，不要阻塞主线程）</p>
</blockquote>
<h4 id="例子讲解"><a href="#例子讲解" class="headerlink" title="例子讲解"></a>例子讲解</h4><blockquote>
<p>海底捞很好吃，但是经常要排队。我们就以生活中的这个例子进行讲解。</p>
</blockquote>
<ul>
<li>A顾客去吃海底捞，就这样干坐着等了一小时，然后才开始吃火锅。(BIO)</li>
<li>B顾客去吃海底捞，他一看要等挺久，于是去逛商场，每次逛一会就跑回来看有没有排到他。于是他最后既购了物，又吃上海底捞了。（NIO）</li>
<li>C顾客去吃海底捞，由于他是高级会员，所以店长说，你去商场随便玩吧，等下有位置，我立马打电话给你。于是C顾客不用干坐着等，也不用每过一会儿就跑回来看有没有等到，最后也吃上了海底捞（AIO）</li>
</ul>
<blockquote>
<p>哪种方式更有效率呢？是不是一目了然呢？</p>
</blockquote>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。服务器实现模式为一个连接一个线程，即客户端有连接请 求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，当然可以通过线程池机制改善。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。服务器实现模式为一个请求一个线程，即客户端发送的连 接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动 一个线程进行处理。线程发起io请求后，立即返回（非阻塞io）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。</p>
<p>NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。服务端不断轮询channel来获取客户端的信息。channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO是真正意义上的异步非阻塞IO模型。服务器实现模式为一个有效请求一个线程，客户端的 IO 请 求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。</p>
<p>AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。</p>
<h3 id="😇-线程安全有哪些实现思路"><a href="#😇-线程安全有哪些实现思路" class="headerlink" title="😇 线程安全有哪些实现思路?"></a>😇 线程安全有哪些实现思路?</h3><ol>
<li><strong>互斥同步</strong></li>
</ol>
<p>synchronized 和 ReentrantLock。</p>
<ol>
<li><strong>非阻塞同步</strong></li>
</ol>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<ul>
<li><code>CAS</code></li>
</ul>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，<code>CAS</code>)。<code>CAS</code> 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<ul>
<li><code>AtomicInteger</code></li>
</ul>
<p><code>J.U.C</code> 包里面的整数原子类 <code>AtomicInteger</code>，其中的 <code>compareAndSet()</code> 和 <code>getAndIncrement()</code> 等方法都使用了 Unsafe 类的 <code>CAS</code> 操作。</p>
<ol>
<li><strong>无同步方案</strong></li>
</ol>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<ul>
<li>栈封闭</li>
</ul>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<ul>
<li>线程本地存储(Thread Local Storage)</li>
</ul>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中 DecimalFormat 用法详解</title>
    <url>/posts/43254.html</url>
    <content><![CDATA[<h3 id="对Java中-DecimalFormat-的所有基础用法进行了一个汇总。"><a href="#对Java中-DecimalFormat-的所有基础用法进行了一个汇总。" class="headerlink" title="对Java中 DecimalFormat 的所有基础用法进行了一个汇总。"></a>对Java中 DecimalFormat 的所有基础用法进行了一个汇总。</h3><span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumberFormat</span>&#123; </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">　　　　<span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.1415927</span>;　<span class="comment">//圆周率</span></span><br><span class="line">　　　　<span class="comment">//取一位整数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">　　　　<span class="comment">//取一位整数和两位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>).format(pi));　<span class="comment">//3.14</span></span><br><span class="line">　　　　<span class="comment">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.000&quot;</span>).format(pi));<span class="comment">// 03.142</span></span><br><span class="line">　　　　<span class="comment">//取所有整数部分</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#&quot;</span>).format(pi));　　　<span class="comment">//3</span></span><br><span class="line">　　　　<span class="comment">//以百分比方式计数，并取两位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##%&quot;</span>).format(pi));　<span class="comment">//314.16%</span></span><br><span class="line">　　 　 <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">299792458</span>;　　<span class="comment">//光速</span></span><br><span class="line">　　　　<span class="comment">//显示为科学计数法，并取五位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#####E0&quot;</span>).format(c));　<span class="comment">//2.99792E8</span></span><br><span class="line">　　　　<span class="comment">//显示为两位整数的科学计数法，并取四位小数</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;00.####E0&quot;</span>).format(c));　<span class="comment">//29.9792E7</span></span><br><span class="line">　　　　<span class="comment">//每三位以逗号进行分隔。</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;,###&quot;</span>).format(c));　　　<span class="comment">//299,792,458</span></span><br><span class="line">　　　　<span class="comment">//将格式嵌入文本</span></span><br><span class="line">　　　　System.out.println(<span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;光速大小为每秒,###米。&quot;</span>).format(c));</span><br><span class="line">  </span><br><span class="line">　　&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecimalFormat 类主要靠 # 和 0 两种占位符号来指定数字长度。0 表示如果位数不足则以 0 填充，# 表示只要有可能就把数字拉上这个位置。上面的例子包含了差不多所有的基本用法</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解开发Servlet</title>
    <url>/posts/11551.html</url>
    <content><![CDATA[<p>关于Java自动注解开发Servlet</p>
<span id="more"></span>
<h1 id="自动注解配置"><a href="#自动注解配置" class="headerlink" title="自动注解配置"></a>自动注解配置</h1><p>自动注解开发的实现步骤：</p>
<ol>
<li>创建一个web项目</li>
<li>定义一个类，继承HttpServlet</li>
<li>重写一个doGet和doPost方法</li>
<li>在类上使用<code>@WebServlet</code>注解配置Servlet</li>
<li>部署并启动项目</li>
<li>通过浏览器进行测试</li>
</ol>
<h2 id="1-配置步骤"><a href="#1-配置步骤" class="headerlink" title="1 配置步骤"></a>1 配置步骤</h2><h4 id="第一步：创建JavaWeb工程，并移除web-xml"><a href="#第一步：创建JavaWeb工程，并移除web-xml" class="headerlink" title="第一步：创建JavaWeb工程，并移除web.xml"></a>第一步：创建JavaWeb工程，并移除web.xml</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/605c192d8322e6675c76ce08.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/605c1a2d8322e6675c773eda.jpg" alt=""></p>
<p>项目创建完成后在web目录没有web.xml文件，只有一个index.jsp文件，可以将index.jsp文件删除。但是在web目录下我们仍然需要WEB-INF文件夹，因为里面不止web.xml这一个配置文件，还会有第三方的依赖包，所以我们要在web目录下手动创建WEB-INF，大小写一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/605c1b6f8322e6675c77d9e3.jpg" alt=""></p>
<h4 id="第二步：编写Servlet，配置注解"><a href="#第二步：编写Servlet，配置注解" class="headerlink" title="第二步：编写Servlet，配置注解"></a>第二步：编写Servlet，配置注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cstube.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基于注解方式开发Servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span> (<span class="string">&quot;/servletDemo01&quot;</span>)  <span class="comment">//配置注解的映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletDemo01执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第三步：测试"><a href="#第三步：测试" class="headerlink" title="第三步：测试"></a>第三步：测试</h4><p>浏览器地址栏输入<code>http://localhost:8080/demo3/servletDemo01</code>,有下面结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/605c1e9d8322e6675c79703f.jpg" alt=""></p>
<h2 id="2-自动注解开发的注解详解"><a href="#2-自动注解开发的注解详解" class="headerlink" title="2 自动注解开发的注解详解"></a>2 自动注解开发的注解详解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebServlet注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定Servlet的名称。</span></span><br><span class="line"><span class="comment">     * 相当于xml配置中&lt;servlet&gt;标签下的&lt;servlet-name&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于映射Servlet访问的url映射</span></span><br><span class="line"><span class="comment">     * 相当于xml配置时的&lt;url-pattern&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相当于xml配置时的&lt;url-pattern&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于配置Servlet的启动时机</span></span><br><span class="line"><span class="comment">     * 相当于xml配置的&lt;load-on-startup&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于配置Servlet的初始化参数</span></span><br><span class="line"><span class="comment">     * 相当于xml配置的&lt;init-param&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于配置Servlet是否支持异步</span></span><br><span class="line"><span class="comment">     * 相当于xml配置的&lt;async-supported&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的小图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的大图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的描述信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定Servlet的显示名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>List集合中的过滤方法</title>
    <url>/posts/e2442faf.html</url>
    <content><![CDATA[<p>本文对List集合中的对象按某种规则进行过滤或者筛选，首先定义一个User类，重写toString方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">long</span> id, String name, Integer age, String birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(String birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, birthday=&#x27;&quot;</span> + birthday + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来构造一个userList集合，同时构造多个user对象，并将其存入userList集合中。我们的需求是按照年龄属性筛选出年龄大于35岁的对象将其裁掉（不是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilteringList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; userList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;user1&quot;</span>,<span class="number">33</span>,<span class="string">&quot;1991-01-01&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;user2&quot;</span>,<span class="number">34</span>,<span class="string">&quot;1992-01-01&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;user3&quot;</span>,<span class="number">35</span>,<span class="string">&quot;1993-01-01&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>,<span class="string">&quot;user4&quot;</span>,<span class="number">36</span>,<span class="string">&quot;1994-01-01&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">5</span>,<span class="string">&quot;user5&quot;</span>,<span class="number">37</span>,<span class="string">&quot;1995-01-01&quot;</span>);</span><br><span class="line">        userList = Arrays.asList(user1, user2, user3, user4, user5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一种方法是使用Java8提供的Stream流的方式进行过滤</strong>，这也是工作中最常使用的场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java8提供的Stream进行过滤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">filterByStream</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userList.stream().filter(user -&gt; user.getAge() &gt; <span class="number">35</span>).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在使用Stream流的场景中，<strong>如果List中的某个元素为null的话，就会抛出空指针异常，所以要在过滤前添加一层判空过滤</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java8提供的Stream进行过滤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">filterByStream</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userList.stream().filter(user -&gt; Objects.nonNull(user))</span><br><span class="line">            .filter(user -&gt; user.getAge() &gt; <span class="number">35</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>筛选结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;过滤前&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(User user : userList) &#123;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">FilteringList</span> <span class="variable">filteringList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilteringList</span>();</span><br><span class="line">    userList = filteringList.filterByStream(userList);</span><br><span class="line">    System.out.println(<span class="string">&quot;过滤后&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(User user : userList) &#123;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">过滤前</span><br><span class="line">User&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;user1&#x27;</span>, age=<span class="number">33</span>, birthday=<span class="string">&#x27;1991-01-01&#x27;</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">2</span>, name=<span class="string">&#x27;user2&#x27;</span>, age=<span class="number">34</span>, birthday=<span class="string">&#x27;1992-01-01&#x27;</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">3</span>, name=<span class="string">&#x27;user3&#x27;</span>, age=<span class="number">35</span>, birthday=<span class="string">&#x27;1993-01-01&#x27;</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">4</span>, name=<span class="string">&#x27;user4&#x27;</span>, age=<span class="number">36</span>, birthday=<span class="string">&#x27;1994-01-01&#x27;</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">5</span>, name=<span class="string">&#x27;user5&#x27;</span>, age=<span class="number">37</span>, birthday=<span class="string">&#x27;1995-01-01&#x27;</span>&#125;</span><br><span class="line">过滤后</span><br><span class="line">User&#123;id=<span class="number">4</span>, name=<span class="string">&#x27;user4&#x27;</span>, age=<span class="number">36</span>, birthday=<span class="string">&#x27;1994-01-01&#x27;</span>&#125;</span><br><span class="line">User&#123;id=<span class="number">5</span>, name=<span class="string">&#x27;user5&#x27;</span>, age=<span class="number">37</span>, birthday=<span class="string">&#x27;1995-01-01&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种方法是使用for循环遍历或者迭代器遍历</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用for循环遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">filterByFor</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">        List&lt;User&gt; newUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User user : userList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(user.getAge() &gt; <span class="number">35</span>) &#123;</span><br><span class="line">                newUserList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUserList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用forEach</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">filterByForEach</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">        List&lt;User&gt; newUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.forEach(user -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(user.getAge() &gt; <span class="number">35</span>) &#123;</span><br><span class="line">                newUserList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> newUserList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用iterator遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">filterByIterator</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">        List&lt;User&gt; newUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Iterator&lt;User&gt; iterator = userList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(user.getAge() &gt; <span class="number">35</span>) &#123;</span><br><span class="line">                newUserList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUserList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合面试题</title>
    <url>/posts/java-collection.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/java-collection-hierarchy.71519bdb-20231217153114487.png" alt=""></p>
<h3 id="😀-List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#😀-List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="😀 List、Map、Set三个接口，存取元素时，各有什么特点？"></a>😀 List、Map、Set三个接口，存取元素时，各有什么特点？</h3><p>首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。</p>
<p>List表示有先后顺序的集合。当我们多次调用add(Obj e)方法时，每次加入的对象按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Obj e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index i)来明确说明取第几个。</p>
<p>Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的集合，还可以获得所有的value的集合，还可以获得key和value组合成的Map.Entry对象的集合。</p>
<h3 id="😀-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别"><a href="#😀-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals-它们有何区别" class="headerlink" title="😀 Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?"></a>😀 Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</h3><p>Set里的元素是不能重复的，元素重复与否是使用equals()方法进行判断的。</p>
<p>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h3 id="😀-你所知道的集合类都有哪些？主要方法？"><a href="#😀-你所知道的集合类都有哪些？主要方法？" class="headerlink" title="😀 你所知道的集合类都有哪些？主要方法？"></a>😀 你所知道的集合类都有哪些？主要方法？</h3><p>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。</p>
<p>Map 集合类用于存储键值对，其中每个键映射到一个值。</p>
<p>List类会有get(int index)这样的方法，因为它可以按顺序取元素，而set类中没有get(int index)这样的方法。List和set都可以迭代出所有元素，迭代时先要得到一个iterator对象，所以，set和list类都有一个iterator方法，用于返回那个iterator对象。map可以返回三个集合，一个是返回所有的key的集合，另外一个返回的是所有value的集合，再一个返回的key和value组合成的EntrySet对象的集合，map也有get方法，参数是key，返回值是key对应的value。</p>
<h3 id="😀-说说-List-Set-Queue-Map-四者的区别？"><a href="#😀-说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="😀 说说 List, Set, Queue, Map 四者的区别？"></a>😀 说说 List, Set, Queue, Map 四者的区别？</h3><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p>
<p><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</p>
<p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p>
<p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
<h3 id="😀-ArrayList-Vector-LinkedList的存储性能和特性"><a href="#😀-ArrayList-Vector-LinkedList的存储性能和特性" class="headerlink" title="😀 ArrayList,Vector, LinkedList的存储性能和特性"></a>😀 ArrayList,Vector, LinkedList的存储性能和特性</h3><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。</p>
<h3 id="😀-ArrayList和Vector的区别"><a href="#😀-ArrayList和Vector的区别" class="headerlink" title="😀 ArrayList和Vector的区别"></a>😀 ArrayList和Vector的区别</h3><p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList与Vector的区别，这主要包括两个方面：</p>
<p>（1）同步性：</p>
<p>Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
<p>（2）数据增长：</p>
<p>ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。</p>
<p>总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</p>
<h3 id="😀-ArrayList的继承结构分析？"><a href="#😀-ArrayList的继承结构分析？" class="headerlink" title="😀 ArrayList的继承结构分析？"></a>😀 ArrayList的继承结构分析？</h3><p>动态数组，它提供了动态的增加和减少元素，实现了Collection和List接口，灵活的设置数组的大小等好处。</p>
<p>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也<strong>自动增长</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1460000039061646.png" alt="img"></p>
<p><strong>AbstractList<E></strong>：</p>
<blockquote>
<p>抽象接口类，目的是使用抽象类中已经实现的方法。</p>
<p>我们点开AbstractList<E>源码，会看到其实AbstractList<E>已经也实现了List<E>接口，为什么要先继承AbstractList<E>，而让AbstractList先实现List<E>？而不是让ArrayList直接实现List<E>？</p>
<p>这里是有一个思想，接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，让AbstractList<E>实现接口中一些通用的方法，而如ArrayList就继承这个AbstractList类，拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来，先一起实现了，减少重复代码。所以一般看到一个类上面还有一个抽象类，应该就是这个作用。</p>
</blockquote>
<p><strong>List<E></strong>：</p>
<blockquote>
<p>使用List的接口规范</p>
</blockquote>
<p><strong>RandomAccess</strong>：</p>
<blockquote>
<p>这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取，有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如arrayList。而没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了让我们知道我们用什么样的方式去获取数据性能更好。</p>
</blockquote>
<p><strong>Cloneable</strong>：</p>
<blockquote>
<p>目的是使用clone方法。<a href="https://link.segmentfault.com/?enc=TS3SthtM1gwt%2Fu6XVYl0SA%3D%3D.JzGMle0MaL%2BdGAAKBExqazZiXAwMDnJCJlxCRV75vFDyNsgWUHSONJrCUBWy9GKb">想具体了解此方法的，点击这里，这篇文章写的还是不错的Cloneable~~</a></p>
</blockquote>
<p><strong>Serializable</strong>：</p>
<blockquote>
<p>实现该序列化接口，表明该类可以被序列化，什么是序列化？简单的说，就是能够从类变成字节流传输，然后还能从字节流变成原来的类。</p>
</blockquote>
<h3 id="😀-ArrayList类分析"><a href="#😀-ArrayList类分析" class="headerlink" title="😀 ArrayList类分析"></a>😀 ArrayList类分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缺省容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造缺省空数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造缺省空数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组元素（实际操作的数组，新增，删除等方法都是在此数组发生操作）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际数组的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>; </span><br></pre></td></tr></table></figure>
<p>（1）为什么数组最大容量是<strong>Integer.MAX_VALUE - 8</strong>，而不是<strong>Integer.MAX_VALUE</strong>？</p>
<p>其实源码中给了备注：意思应该是有些虚拟机在数组中保留了一些头信息。避免内存溢出！</p>
<p>（2）为什么定义了<strong>两个空数组</strong>？</p>
<p>首先定义空数组的根本原因是<strong>优化处理</strong>，如果一个应用中有很多这样ArrayList空实例的话，就会有很多的空数组，无疑是为了优化性能，所有ArrayList空实例都指向同一个空数组。两者都是用来减少空数组的创建，所有空ArrayList都共享空数组。两者的区别主要是用来起区分作用，针对有参无参的构造在扩容时做区分走不同的扩容逻辑，优化性能。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>（1）无参构造方法 <strong>ArrayList()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将空数组初始化大小为10(将空数组初始化大小为10，具体在什么时候初始化大小为10，待会儿会说到)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 将elementData元素数组初始化为空数组</span></span><br><span class="line">       <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>无参构造方法中，将元素数组elementData初始化为空数组。</p>
<p>（2）有参构造方法 <strong>ArrayList(int)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个具有指定初始容量的列表</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity: 初始化数组的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="comment">//如果初始化的值大于0，则给定elementData一个长度为initialCapacity的数组</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123; </span><br><span class="line">           <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123; <span class="comment">// 如果初始化的值等于0，则初始化为空数组</span></span><br><span class="line">           <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则（小于0的情况）抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>（3）有参构造方法 <strong>ArrayList(Collection&lt;? extends E&gt; c)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个指定元素的集合(此方法不太常用)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> c </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">       <span class="comment">// 将集合转换为数组并赋值给elementData</span></span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       <span class="comment">// 如果集合的大小不为0</span></span><br><span class="line">       <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果转换后的数组不是泛型(object)，则需要用Arrays的工具转换一下为object数组(这里不再对Arrays.copyOf展开论述)</span></span><br><span class="line">           <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则初始化elementData为一个空数组</span></span><br><span class="line">           <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="😀-ArrayList常用方法源码分析"><a href="#😀-ArrayList常用方法源码分析" class="headerlink" title="😀 ArrayList常用方法源码分析"></a>😀 ArrayList常用方法源码分析</h3><h4 id="boolean-add-E-e"><a href="#boolean-add-E-e" class="headerlink" title="boolean add(E e)"></a>boolean add(E e)</h4><ol>
<li>确定内部容量是否够用，size是元素数组中数据的个数，因为要添加一个元素，所以size+1，先判断size+1的这个个数数组能否放得下，就在这个<code>ensureCapacityInternal</code>方法中去判断是否数组.length是否够用了，size + 1 作为<code>ensureCapacityInternal</code>方法的入参。然后将元素e赋值到elementData末尾<code>elementData[size++] = e;</code>。</li>
<li><code>ensureCapacityInternal</code>方法可以理解为一个中转方法，它里面又有一个ensureExplicitCapacity方法，然后这个方法里面又包了一个calculateCapacity(Object[] elementData, int minCapacity)方法。这个方法首先判断数组是不是空数组,如果是空数组(此时minCapacity = 0 + 1 = 1)，就将minCapacity初始化为10，但此时仅仅是返回要初始化数组的大小，并没有真正初始化数组为10。如果不是空数组，则返回元素数组的size + 1。</li>
<li>现在ensureExplicitCapacity方法获得了minCapacity的值作为它的入参，方法首先将结构变化记录+1 在父类AbstractList中定义了一个int型的属性：modCount，记录了ArrayList结构性变化的次数。然后判断数组是否够用，如果不够用，就自动扩容。当初始化的集合为空数组时，此时minCapacity是10，而elementData的长度为0，所以需要扩容；当初始化的集合不为空是，也就是给定了大小，或已经初始化了元素，此时的minCapacity = 实际数组个数+1，此时判断集合不够用，也需要进行扩容，否则元素会溢出。</li>
<li>在扩容方法grow(int minCapacity)中，首先会获得元素数组的实际长度oldCapacity(也就是扩容前的数组大小)，然后oldCapacity 扩容1.5倍赋值给newCapacity( &gt;&gt;为右移运算符，相当于除以2 即oldCapacity/2 )，<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>。如果之前是个空数组的情况，则将数组扩容为10，此时才是真正初始化元素数组elementData大小为10，<code>if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity;</code>。如果1.5倍的数组大小超过了集合的最大长度，则调用hugeCapacity方法，重新计算，也就是给定最大的集合长度。最后已经确定了大小，就将元素copy到elementData元素数组中<code>elementData = Arrays.copyOf(elementData, newCapacity);</code>。</li>
</ol>
<h4 id="void-add-int-index-E-element"><a href="#void-add-int-index-E-element" class="headerlink" title="void add(int index, E element)"></a>void add(int index, E element)</h4><p>首先进行参数校验，判断index是否大于size或者小于size,之后执行<code>ensureCapacityInternal(size + 1);</code>，然后执行<code>System.arraycopy(elementData, index, elementData, index + 1,size - index);</code>方法，这个方法就是将原数组中从index位置开始的元素复制到从index+1开始，也就是将index及其之后的元素向后移动一位。然后将指定元素覆盖到指定下标index。最后size + 1。</p>
<h4 id="boolean-remove-Object-o"><a href="#boolean-remove-Object-o" class="headerlink" title="boolean remove(Object o)"></a>boolean remove(Object o)</h4><p>首先校验要删除的元素下标是否有越界，然后将结构变化记录+1，然后获得旧数据，返回给开发人员，目的是让开发人员知道删除了哪个数据，之后计算需要元素需要移动的次数，然后使用System.arrayCopy进行元素移动。最后将最后一个元素置为空(元素前移，最后一位置为空)<code>elementData[--size] = null;</code>，让GC回收。</p>
<h4 id="void-clear"><a href="#void-clear" class="headerlink" title="void clear()"></a>void clear()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清空集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将数组置为空，促使GC回收</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-get-int-index"><a href="#E-get-int-index" class="headerlink" title="E get(int index)"></a>E get(int index)</h4><p>返回此列表中指定位置上的元素,检查给定的索引是否在范围内。 如果没有，则抛出一个适当的运行时异常。之后返回元素数组中指定index位置的数据</p>
<h4 id="E-set-int-index-E-element"><a href="#E-set-int-index-E-element" class="headerlink" title="E set(int index,E element)"></a>E set(int index,E element)</h4><p>覆盖相应下标的数据，检查给定的索引是否在范围内。 如果没有，则抛出一个适当的运行时异常。获取到旧数据，这里将旧数据返回出去，为了让开发者知道替换的是哪个值<code>E oldValue = elementData(index);</code>，将指定下标覆盖为新元素<code>elementData[index] = element;</code></p>
<h3 id="😀-ArrayList是线程安全的么？"><a href="#😀-ArrayList是线程安全的么？" class="headerlink" title="😀 ArrayList是线程安全的么？"></a>😀 ArrayList是线程安全的么？</h3><p>当然不是，线程安全版本的数组容器是Vector。Vector的实现很简单，就是把所有的方法统统加上synchronized就完事了。你也可以不使用Vector，用Collections.synchronizedList把一个普通ArrayList包装成一个线程安全版本的数组容器也可以，原理同Vector是一样的，就是给所有的方法套上一层synchronized。</p>
<h3 id="😀-Arraylist-与-LinkedList-区别"><a href="#😀-Arraylist-与-LinkedList-区别" class="headerlink" title="😀 Arraylist 与 LinkedList 区别?"></a>😀 Arraylist 与 LinkedList 区别?</h3><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>遍历性能：</strong>论遍历ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</p>
<p><strong>内存空间占用：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而且需要连续的内存空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="😀-ArrayList和LinkedList的使用选择"><a href="#😀-ArrayList和LinkedList的使用选择" class="headerlink" title="😀 ArrayList和LinkedList的使用选择"></a>😀 ArrayList和LinkedList的使用选择</h3><p>多数情况下，当你遇到访问元素比插入或者是删除元素更加频繁的时候，你应该使用ArrayList。<br>另外一方面，当你在某个特别的索引中，插入或者是删除元素更加频繁，或者你压根就不需要访问元素的时候，你会选择LinkedList。<br>这里的主要原因是，在ArrayList中访问元素的最糟糕的时间复杂度是”1″，而在LinkedList中可能就是”n”了。在ArrayList中增加或者删除某个元素，通常会调用<strong>System.arraycopy</strong>方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。</p>
<p>如果我们要展示的数据不需要进行排序，也基本不涉及到添加删除操作时，我们可以考虑使用ArrayList。</p>
<p>如果要展示的数据需要排序，那就不要用ArrayList了。直播时的评论展示，如果只考虑显示数据，不会有从中间的插入和删除操作，则用ArrayList是可以的。但是如果是qq的好友列表，使用ArrayList就不合适了。因为好友列表的排序是会随时变化的，一但有好友给你发消息，这位好友的位置就会跑到顶部去。</p>
<h3 id="😀-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#😀-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="😀 如何复制某个ArrayList到另一个ArrayList中去？"></a>😀 如何复制某个ArrayList到另一个ArrayList中去？</h3><ol>
<li>使用clone()方法，比如ArrayList newArray = oldArray<strong>.clone()</strong>;</li>
<li>使用ArrayList构造方法，比如：ArrayList myObject = <strong>new ArrayList</strong>(myTempObject);</li>
<li>使用Collection的copy方法。</li>
</ol>
<p>注意1和2是浅拷贝(shallow copy)。</p>
<h3 id="😀-Arrays-asList返回的List与new-ArrayList的区别"><a href="#😀-Arrays-asList返回的List与new-ArrayList的区别" class="headerlink" title="😀 Arrays.asList返回的List与new ArrayList的区别"></a>😀 Arrays.asList返回的List与new ArrayList的区别</h3><p>Arrays.asList返回的List是个固定大小的List，这个ArrayList不是util包中的ArrayList，而只是Arrays类的一个继承了AbstractList的内部类。这个类确实没有覆盖父类的实现。在AbstractList中，明确提到了不覆盖就会抛UnsupportedOperationException异常的方法有3个：add(int index, E element),set(int index, E element)，remove(int index)。而上面的代码中只覆盖了set方法，可能会调用这几个方法的add(E element),clear(),addAll(int index, Collection&lt;? extends E&gt; c),甚至iterator()方法都没有覆盖，也就是说上面的几个方法都可能在调用中报错。由此可见JDK设计的这个返回List，只支持遍历和取值，不能做任何修改，只能作为传递值的桥梁。</p>
<h3 id="😀-无序性和不可重复性的含义是什么"><a href="#😀-无序性和不可重复性的含义是什么" class="headerlink" title="😀 无序性和不可重复性的含义是什么"></a>😀 无序性和不可重复性的含义是什么</h3><p>什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="😀-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#😀-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="😀 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>😀 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p>
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
<p>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</p>
<h3 id="😀-ArrayDeque-与-LinkedList-的区别"><a href="#😀-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="😀 ArrayDeque 与 LinkedList 的区别"></a>😀 ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h3 id="😀-说一说-PriorityQueue"><a href="#😀-说一说-PriorityQueue" class="headerlink" title="😀 说一说 PriorityQueue"></a>😀 说一说 PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<h3 id="😀-HashSet-如何检查重复"><a href="#😀-HashSet-如何检查重复" class="headerlink" title="😀 HashSet 如何检查重复"></a>😀 HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h3 id="😀-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#😀-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="😀 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?"></a>😀 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?</h3><p>对。</p>
<p>如果对象要保存在HashSet或HashMap中，它们的equals相等，那么，它们的hashcode值就必须相等。</p>
<p>如果不是要保存在HashSet或HashMap，则与hashcode没有什么关系了，这时候hashcode不等是可以的，例如arrayList存储的对象就不用实现hashcode，当然，我们没有理由不实现，通常都会去实现的。</p>
<h3 id="😀-Map有哪些常用的实现类及其作用？"><a href="#😀-Map有哪些常用的实现类及其作用？" class="headerlink" title="😀 Map有哪些常用的实现类及其作用？"></a>😀 <strong>Map有哪些常用的实现类及其作用？</strong></h3><p><strong>HashMap:</strong>上面也说了，<strong>HashMap的底层实现是数组+链表+红黑树的形式的，</strong>同时它的<strong>数组的默认初始容量是16、扩容因子为0.75，每次采用2倍的扩容。</strong>也就是说，每当我们数组中的存储容量达到75%的时候，就需要对数组容量进行2倍的扩容。</p>
<p><strong>HashTable:</strong>HashTable接口是线程安全，但是很早之前有使用，现在几乎属于一个遗留类了，<strong>在开发中不建议使用。</strong></p>
<p><strong>ConcurrentHashMap:</strong>这是现阶段使用使用比较多的一种线程安全的Map实现类。<strong>在1.7以前使用的是分段锁机制实现的线程安全的。但是在1.8以后使用synchronized关键字实现的线程安全。</strong></p>
<h3 id="😀-HashMap和Hashtable的区别"><a href="#😀-HashMap和Hashtable的区别" class="headerlink" title="😀 HashMap和Hashtable的区别"></a>😀 HashMap和Hashtable的区别</h3><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
<p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
<p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
<p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小.</p>
<p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
<h3 id="😀-HashMap和TreeMap区别"><a href="#😀-HashMap和TreeMap区别" class="headerlink" title="😀 HashMap和TreeMap区别"></a>😀 HashMap和TreeMap区别</h3><ul>
<li><strong>从类的定义来看</strong>，HashMap和TreeMap都继承自AbstractMap，不同的是HashMap实现的是Map接口，而TreeMap实现的是NavigableMap接口。NavigableMap是SortedMap的一种，实现了对Map中key的排序。这样两者的第一个区别就出来了，TreeMap是排序的而HashMap不是。</li>
<li><strong>再看看HashMap和TreeMap的构造函数的区别。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221017120506992-20231217153114911.png" alt="image-20221017120506992"></p>
<p>HashMap除了默认的无参构造函数之外，还可以接受两个参数initialCapacity和loadFactor。</p>
<p>HashMap的底层结构是Node的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">transient <span class="title class_">Node</span>&lt;K,V&gt;[] table</span><br></pre></td></tr></table></figure>
<p>initialCapacity就是这个table的初始容量。如果大家不传initialCapacity，HashMap提供了一个默认的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> final int <span class="variable constant_">DEFAULT_INITIAL_CAPACITY</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>
<p>当HashMap中存储的数据过多的时候，table数组就会被装满，这时候就需要扩容，HashMap的扩容是以2的倍数来进行的。而loadFactor就指定了什么时候需要进行扩容操作。默认的loadFactor是0.75。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> final float <span class="variable constant_">DEFAULT_LOAD_FACTOR</span> = <span class="number">0.</span>75f;</span><br></pre></td></tr></table></figure>
<p>再来看几个非常有趣的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> final int <span class="variable constant_">TREEIFY_THRESHOLD</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> final int <span class="variable constant_">UNTREEIFY_THRESHOLD</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> final int <span class="variable constant_">MIN_TREEIFY_CAPACITY</span> = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>上面的三个变量有什么用呢？在java 8之前，HashMap解决hashcode冲突的方法是采用链表的形式，为了提升效率，java 8将其转成了TreeNode。什么时候会发生这个转换呢？</p>
<p>这时候就要看这两个变量TREEIFY_THRESHOLD和UNTREEIFY_THRESHOLD。</p>
<p>有的同学可能发现了，TREEIFY_THRESHOLD为什么比UNTREEIFY_THRESHOLD大2呢？其实这个问题我也不知道，但是你看源代码的话，用到UNTREEIFY_THRESHOLD时候，都用的是&lt;=,而用到TREEIFY_THRESHOLD的时候，都用的是&gt;= TREEIFY_THRESHOLD – 1，所以这两个变量在本质上是一样的。</p>
<p>MIN_TREEIFY_CAPACITY表示的是如果table转换TreeNode的最小容量，只有capacity &gt;= MIN_TREEIFY_CAPACITY的时候才允许TreeNode的转换。</p>
<p>TreeMap和HashMap不同的是，TreeMap的底层是一个Entry：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private transient <span class="title class_">Entry</span>&lt;K,V&gt; root</span><br></pre></td></tr></table></figure>
<p>他的实现是一个红黑树，方便用来遍历和搜索。</p>
<p>TreeMap的构造函数可以传入一个Comparator，实现自定义的比较方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="title class_">TreeMap</span>(<span class="title class_">Comparator</span>&lt;? <span class="variable language_">super</span> K&gt; comparator) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">comparator</span> = comparator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果不提供自定义的比较方法，则使用的是key的natural order。</p>
<ul>
<li><strong>排序区别</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221017121053967.png" alt="image-20221017121053967"></p>
<p>同样的代码，一个使用了HashMap，一个使用了TreeMap，我们会发现TreeMap输出的结果是排好序的，而HashMap的输出结果是不定的。</p>
<ul>
<li><strong>Null值的区别</strong></li>
</ul>
<p>HashMap可以允许一个null key和多个null value。而TreeMap不允许null key，但是可以允许多个null value。</p>
<ul>
<li><strong>性能区别</strong></li>
</ul>
<p>HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。</p>
<p>另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。</p>
<p>HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。</p>
<p>TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。</p>
<ul>
<li><strong>共同点</strong></li>
</ul>
<p>两者都不允许有重复的 key,两者都不是线程安全的。</p>
<h3 id="😀-HashMap-1-7和1-8有哪些区别"><a href="#😀-HashMap-1-7和1-8有哪些区别" class="headerlink" title="😀 HashMap 1.7和1.8有哪些区别"></a>😀 HashMap 1.7和1.8有哪些区别</h3><h4 id="结构区别"><a href="#结构区别" class="headerlink" title="结构区别"></a>结构区别</h4><p>HashMap1.8的底层数据结构是数组+链表+红黑树。HashMap 1.7的底层数据结构是数组加链表。</p>
<ul>
<li>一般情况下，以默认容量16为例，阈值等于12就扩容，单条链表能达到长度为8的概率是相当低的，除非Hash攻击或者HashMap容量过大出现某些链表过长导致性能急剧下降的问题，红黑树主要是为了结果这种问题。</li>
<li>在正常情况下，效率相差并不大。</li>
</ul>
<h4 id="节点区别"><a href="#节点区别" class="headerlink" title="节点区别"></a>节点区别</h4><p>HashMap 1.7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Entry&lt;K,V&gt; next;</span><br><span class="line"><span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap 1.8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;  </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash;  </span><br><span class="line"><span class="keyword">final</span> K key;  </span><br><span class="line">V value;  </span><br><span class="line">Node&lt;K,V&gt; next;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links  </span></span><br><span class="line">TreeNode&lt;K,V&gt; left;  </span><br><span class="line">TreeNode&lt;K,V&gt; right;  </span><br><span class="line">TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion  </span></span><br><span class="line"><span class="type">boolean</span> red;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区别：</p>
<p>Jdk1.8</p>
<ul>
<li>hash是final修饰，也就是说hash值一旦确定，就不会再重新计算hash值了。</li>
<li>新增了一个TreeNode节点，为了转换为红黑树。</li>
</ul>
<p>Jdk1.7</p>
<ul>
<li>hash是可变的，因为有rehash的操作。</li>
</ul>
<h4 id="Hash算法区别"><a href="#Hash算法区别" class="headerlink" title="Hash算法区别"></a>Hash算法区别</h4><p>1.7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;  </span><br><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;  </span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line"><span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">h ^= k.hashCode();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// This function ensures that hashCodes that differ only by  </span></span><br><span class="line"><span class="comment">// constant multiples at each bit position have a bounded  </span></span><br><span class="line"><span class="comment">// number of collisions (approximately 8 at default load factor).  </span></span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);  </span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;  </span><br><span class="line"><span class="type">int</span> h;  </span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>1.8计算出来的结果只可能是一个，所以hash值设置为final修饰,并且计算出来的hashcode值右移16位之后和原来的hashcode值做抑或。</li>
<li>1.7会先判断这Object是否是String，如果是，则不采用String复写的hashcode方法，处于一个Hash碰撞安全问题的考虑</li>
</ul>
<h4 id="对Null的处理"><a href="#对Null的处理" class="headerlink" title="对Null的处理"></a>对Null的处理</h4><p>Jdk1.7中，对null值做了单独的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;  </span><br><span class="line"><span class="comment">//判断是否是空值  </span></span><br><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span>)  </span><br><span class="line"><span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的说，HashMap会遍历数组的下标为0的链表，循环找key=null的键，如果找到则替换。</p>
<p>如果当前数组下标为0的位置为空，即e==null，那么直接执行添加操作，key=null，插入位置为0。</p>
<p>1.8</p>
<p>而1.8中，由于Hash算法中会将null的hash值计算为0，插入时0&amp;任何数都是0，插入位置为数组的下标为0的位置，所以我们可以认为，1.8中null为键和其他非null是一样的，也有hash值，也能别替换。只是计算结果为0而已。</p>
<p><strong>区别</strong></p>
<ul>
<li>Jdk1.7中，null是一个特殊的值，单独处理</li>
<li>Jdk1.8中，null的hash值计算结果为0，其他地方和普通的key没区别。</li>
</ul>
<h4 id="扩容区别"><a href="#扩容区别" class="headerlink" title="扩容区别"></a>扩容区别</h4><p>扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小</p>
<h4 id="插入区别"><a href="#插入区别" class="headerlink" title="插入区别"></a>插入区别</h4><p>在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；</p>
<h3 id="😀-HashMap中的Hash方法为什么要右移16位异或？"><a href="#😀-HashMap中的Hash方法为什么要右移16位异或？" class="headerlink" title="😀 HashMap中的Hash方法为什么要右移16位异或？"></a>😀 HashMap中的Hash方法为什么要右移16位异或？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">  <span class="comment">// ^ ：按位异或	 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐	  return (key == null) ? 0 : (h = 		key.hashCode()) ^ (h &gt;&gt;&gt; 16);	</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p> HashMap 将key通过hash方法处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>首先这个方法的返回值还是一个哈希值。为什么不直接返回<code>key.hashCode()</code>呢？还要与 (h &gt;&gt;&gt; 16)异或。</p>
<p>先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h = key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1111</span><br><span class="line">^</span><br><span class="line">h &gt;&gt;&gt; 16           0000 0000 0000 0000 1111 1101 1101 1111</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">h ^ (h &gt;&gt;&gt; 16)     1111 1101 1101 1111 1010 0000 1111 0000</span><br><span class="line">h = key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1111  </span><br></pre></td></tr></table></figure>
<p>对比<code>h = key.hashcode()</code> 与 <code>h ^ (h &gt;&gt;&gt; 16)</code> 发现，将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原<code>hashcode</code>做异或运算，<strong>可以将高低位二进制特征混合起来</strong>。例子中可以看出高区的16位并没有变化。低区的16位发 生了较大的变化。这样做的目的是什么呢？</p>
<p>我们计算出的hash值在后面会参与到元素index的计算中。计算公式为 hash &amp; (length - 1)。</p>
<p>仔细观察上文不难发现，高区的16位很有可能会被数组长度的二进制码所屏蔽，<strong>如果我们不做刚才移位异或运算，那么在计算index时将丢失高区特征。如果</strong>没有上面这个异或操作，假设里两个hash值只有高位一点点的差异，然后在计算index过程中还丢失了高位的信息，那么就计算出同一个index。</p>
<h3 id="😀-HashMap中的hash方法使用异或运算的原因？"><a href="#😀-HashMap中的hash方法使用异或运算的原因？" class="headerlink" title="😀 HashMap中的hash方法使用异或运算的原因？"></a>😀 HashMap中的hash方法使用异或运算的原因？</h3><p><strong>异或运算能更平均的保留各部分的特征</strong>，如果采用<strong>&amp;</strong>运算计算出来的值会向1靠拢，采用<strong>|</strong>运算计算出来的值会向0靠拢</p>
<h3 id="😀-为什么HashMap的数组长度必须使用2-n？"><a href="#😀-为什么HashMap的数组长度必须使用2-n？" class="headerlink" title="😀 为什么HashMap的数组长度必须使用2^n？"></a>😀 为什么HashMap的数组长度必须使用2^n？</h3><p>首先我们计算key的hash值之后还要先做对数组的长度取模运算，得到的余数才能用来作为存放的位置也就是对应的数组下标。这个数组下标的计算方法是<code>(n - 1) &amp; hash</code>。<strong>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</strong>，<strong>也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；</strong>并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率</strong>。</p>
<p>其次是为了让计算得到的元素索引更加均匀，如果 length = 17 那么 hash &amp; (17 - 1) 。16转化为二进制包含更多的0，这样一来计算会被更多的0屏蔽。</p>
<p>最后是为了便于扩容后的重新计算元素index。</p>
<h3 id="😀-为什么HashMap扩容时总是把capacity扩大为原来的2倍？"><a href="#😀-为什么HashMap扩容时总是把capacity扩大为原来的2倍？" class="headerlink" title="😀 为什么HashMap扩容时总是把capacity扩大为原来的2倍？"></a>😀 为什么HashMap扩容时总是把capacity扩大为原来的2倍？</h3><p>由于我们要维护hashmap的大小为2^n，这样就使得len-1的二进制中全部都是1。进行位运算时可以降低hash碰撞的出现。</p>
<h3 id="😀-HashMap的负载因子为什么是0-75？"><a href="#😀-HashMap的负载因子为什么是0-75？" class="headerlink" title="😀 HashMap的负载因子为什么是0.75？"></a>😀 HashMap的负载因子为什么是0.75？</h3><p>负载因子主要与扩容有关，如果将负载因子设置为1，空间利用的就更加充分了，但是这样一来<strong>会增大hash碰撞</strong>的出现，有些位置的链表会过长，不利于查找。如果设置的过小的话虽然降低了hash碰撞的发生，但是会频繁触发扩容机制，也会导致数组的利用率较低。</p>
<p>所以为了折中，将负载因子设置为0.75是对空间与时间的取舍。</p>
<h3 id="😀-请阐述HashMap的put过程？"><a href="#😀-请阐述HashMap的put过程？" class="headerlink" title="😀  请阐述HashMap的put过程？"></a>😀  请阐述HashMap的put过程？</h3><p>在HashMap中使用的是数组+链表的实现方式，<strong>在HashMap的上层使用数组的形式对“相同”的key进行存储，下层对相应的key和value使用链表的形式进行链接和存储。</strong></p>
<p>HashMap将要存储的值按照key计算其对应的数组下标，如果对应的数组下标的位置上是没有元素的，那么就将存储的元素存放上去，但是如果该位置上已经存在元素了，那么这就需要用到我们上面所说的链表存储了，将数据按照链表的存储顺序依次向下存储就可以了（在JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的）。这就是put的简单过程，存储结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20210606155342841-20231217153115288.jpg" alt=""></p>
<p>但是我们有时候存储的数据会很多，那么如果一直使用链表的形式进行数据的存储的话就或造成我们的链表的长度非常大，这样无论在进行删除还是在进行插入操作都是十分麻烦的，<strong>这里就涉及到了一个链表中数据存储时，进行“树化”和“链化”的一个过程</strong>。当我们在对键值对进行存储的时候，如果我们在同一个数组下标下存储的数据过多的话，就会造成我们的链表长度过长，导致进行删除和插入操作比较麻烦，所以在java中规定，<strong>当链表长度大于8时，我们会对链表进行“树化”操作，</strong>将其转换成一颗红黑树（一种二叉树，左边节点的值小于根节点，右边节点的值大于根节点），这样我们在对元素进行查找时，就类似于进行二分查找了，这样的查找效率就会大大增加。但是当我们进行删除操作，将其中的某些节点删除了之后，链表的长度不再大于8了，<strong>当链表的长度小于6的时候，我们会将红黑树重新转化为链表，这个过程就叫做“链化”。</strong>最后判断元素个数是否超过默认的⻓度(16)*负载因子(0.75)，也就是12，超过则进行扩容。</p>
<p><strong>那么为什么要在长度8的时候进行“树化”，而在长度小于6的时候才进行“链化”呢？为什么不直接在长度小于8的时候就进行“链化”？</strong></p>
<p><strong>主要原因是因为：</strong>当删除一个元素，链表长度小于8的时候直接进行“链化”，而再增加一个元素，长度又等于8的时候，又要进行“树化”，这样反复的进行“链化”和“树化”操作特别的消耗时间，而且也比较麻烦。所以程序就规定，只有当当链表长度大于等于8的时候才进行“树化”，而长度小于6的时候才进行“链化”，<strong>其中关于8树化、6链化这两个阈值希望大家牢记！</strong></p>
<h3 id="😀-HashMap的扩容机制"><a href="#😀-HashMap的扩容机制" class="headerlink" title="😀 HashMap的扩容机制"></a>😀 HashMap的扩容机制</h3><h4 id="1-7版本"><a href="#1-7版本" class="headerlink" title="1.7版本"></a>1.7版本</h4><p>1.先生成新数组，链表不需要进行扩容<br>2.遍历老数组中的每个位置上的链表上的每个元素<br>3.取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标<br>4.将元素添加到新数组中去<br>5.所有元素转移完之后，将新数组赋值给HashMap对象的table属性。</p>
<h4 id="1-8版本"><a href="#1-8版本" class="headerlink" title="1.8版本"></a>1.8版本</h4><p>1.先生成新数组，链表不需要进行扩容<br>2.遍历老数组中的每个位置上的链表或红黑树<br>3.如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去。<br>4.如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置</p>
<p>  a.统计每个下标位置的元素个数<br>  b.如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置。<br>  c.如果该问之下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置。<br>5.所有元素转移完成后，将新数组赋值给HashMap对象的table属性。</p>
<h3 id="😀-头插法为什么改成尾插法"><a href="#😀-头插法为什么改成尾插法" class="headerlink" title="😀 头插法为什么改成尾插法"></a>😀 头插法为什么改成尾插法</h3><p>链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后；</p>
<p>因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；<br>A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221017122133625-20231217153115534.png" alt="image-20221017122133625"></p>
<h3 id="😀-HashMap是如何扩容的？"><a href="#😀-HashMap是如何扩容的？" class="headerlink" title="😀  HashMap是如何扩容的？"></a>😀  HashMap是如何扩容的？</h3><p><a href="http://javaguide.cn/java/collection/hashmap-source-code.html#resize-方法">resize方法</a></p>
<p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p>
<p>HashMap的数组的初始容量是16，但是很显然16个存储位是显然不够的，<strong>在这里需要用到一个参数叫“扩容因子”，在HashMap中“扩容因子”的大小是0.75，</strong> <strong>对于初始长度为16的数组，当其中存储的数据长度等于16*0.75=12时。就会对数组元素进行扩容，扩容量是原来数组容量的2倍。</strong></p>
<h3 id="😀-HashMap扩容后元素怎么存放的？"><a href="#😀-HashMap扩容后元素怎么存放的？" class="headerlink" title="😀 HashMap扩容后元素怎么存放的？"></a>😀 HashMap扩容后元素怎么存放的？</h3><p>我们知道HashMap的数组在进行扩容之后，数组长度是增加的，那么这个时候，后面新扩容的部分就是空的。这样会造成内存的很大浪费。<strong>因此在HashMap的数组扩容之后，原先HashMap数组中存放的数据元素会进行重新的位置分配，重新将元素在新数组中进行存储。以充分利用数组空间。</strong></p>
<h3 id="😀-HashMap的线程安全问题？"><a href="#😀-HashMap的线程安全问题？" class="headerlink" title="😀 HashMap的线程安全问题？"></a>😀 HashMap的线程安全问题？</h3><p>1.多线程的put操作可能导致元素丢失</p>
<p>2.put和get并发时可能导致get为null</p>
<ul>
<li>线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。</li>
</ul>
<p>3.jdk 1.7 中并发put导致的循环链表导致get出现死循环</p>
<ul>
<li>发生在多线程并发resize的情况下可能会导致环形链表的出现。</li>
</ul>
<h3 id="😀-解决hash冲突的方法？"><a href="#😀-解决hash冲突的方法？" class="headerlink" title="😀 解决hash冲突的方法？"></a>😀 解决hash冲突的方法？</h3><p><strong>1.拉链法（链地址）：</strong></p>
<p><strong>2.线性探测法：</strong>冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p><strong>3.二次探测法：</strong>冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<h3 id="😀-ConcurrentHashMap-和-Hashtable-的区别"><a href="#😀-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="😀 ConcurrentHashMap 和 Hashtable 的区别"></a>😀 ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashTable的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。② </strong><code>Hashtable</code>(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h3 id="😀-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#😀-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="😀 ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>😀 ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/ConcurrentHashMap分段锁.jpg" alt=""></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。<code>HashEntry</code> 用于存储键值对数据，其中，用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下数据获取时的<strong>可见性</strong>。</p>
<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。 </p>
<h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220209165135940-20231217153115897.png" alt="image-20220209165135940"></p>
<p>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的Node数组+链表+红黑树结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加细粒度的锁。</p>
<p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p>
<p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h3 id="😀-JDK1-8-中ConCurrentHashMap为什么使用内置锁-synchronized替换可重入锁-ReentrantLock？"><a href="#😀-JDK1-8-中ConCurrentHashMap为什么使用内置锁-synchronized替换可重入锁-ReentrantLock？" class="headerlink" title="😀 JDK1.8 中ConCurrentHashMap为什么使用内置锁 synchronized替换可重入锁 ReentrantLock？"></a>😀 JDK1.8 中ConCurrentHashMap为什么使用内置锁 synchronized替换可重入锁 ReentrantLock？</h3><p>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步升级。</p>
<p>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p>
<h3 id="😀-ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#😀-ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="😀 ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a>😀 ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><p>整体流程跟HashMap比较类似，大致是以下几步：</p>
<p>（1）如果桶数组未初始化，则初始化；</p>
<p>（2）如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</p>
<p>（3）如果正在扩容，则当前线程一起加入到扩容的过程中；</p>
<p>（4）如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）；</p>
<p>（5）如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</p>
<p>（6）如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</p>
<p>（7）如果元素存在，则返回旧值；</p>
<p>（8）如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容；</p>
<p>添加元素操作中使用的锁主要有（自旋锁 + CAS + synchronized + 分段锁）。</p>
<h3 id="😀-ConcurrentHashMap-的-get-方法是否要加锁，为什么？"><a href="#😀-ConcurrentHashMap-的-get-方法是否要加锁，为什么？" class="headerlink" title="😀 ConcurrentHashMap 的 get 方法是否要加锁，为什么？"></a>😀 ConcurrentHashMap 的 get 方法是否要加锁，为什么？</h3><p>get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。</p>
<h3 id="😀-ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？"><a href="#😀-ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？" class="headerlink" title="😀 ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？"></a>😀 ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h3><p>我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</p>
<p>而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。</p>
<p>我们用反证法来推理：</p>
<p>假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用ConcurrentHashMap.get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。</p>
<p>假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 ConcurrentHashMap.containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回 false 。</p>
<p>但是在我们调用 ConcurrentHashMap.get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap.put(key, null)的操作。那么我们调用containsKey方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。</p>
<h3 id="😀-ConcurrentHashMap-的并发度是什么？"><a href="#😀-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="😀 ConcurrentHashMap 的并发度是什么？"></a>😀 ConcurrentHashMap 的并发度是什么？</h3><p>并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。在JDK1.7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数中设置。</p>
<p>如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p>
<p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</p>
<p>在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。</p>
<h3 id="😀-ConcurrentHashMap-迭代器是强一致性还是弱一致性？"><a href="#😀-ConcurrentHashMap-迭代器是强一致性还是弱一致性？" class="headerlink" title="😀 ConcurrentHashMap 迭代器是强一致性还是弱一致性？"></a>😀 ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h3><p>与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。</p>
<p>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>
<p>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</p>
<h3 id="😀-数组和链表的区别-、使用场景"><a href="#😀-数组和链表的区别-、使用场景" class="headerlink" title="😀 数组和链表的区别 、使用场景"></a>😀 数组和链表的区别 、使用场景</h3><p><strong>数组和链表的区别</strong><br><strong>数组</strong>是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效<br>率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大<br>小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现<br>越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低<br><strong>链表</strong>是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需<br>要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任<br>意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）<br><strong>链表和数组使用场景</strong><br>数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建<br>的线性表较稳定。<br>链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>List集合中排序的几种方法</title>
    <url>/posts/51bbb0f6.html</url>
    <content><![CDATA[<p>本文简单介绍下List集合中的几种排序方法。首先定义一个UserBean对象，包含id，name，age，birthday等属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBean</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserBean</span><span class="params">(<span class="type">long</span> id, String name, Integer age, String birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(String birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserBean&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, birthday=&#x27;&quot;</span> + birthday + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后构造一个userBeanList以及多个userBean对象，将userBean对象添加到userBeanList中，然后需要按照一定的规则排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造userBeanList</span></span><br><span class="line">        List&lt;UserBean&gt; userBeanList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">UserBean</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBean</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">17</span>, <span class="string">&quot;2005-11-02&quot;</span>);</span><br><span class="line">        <span class="type">UserBean</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBean</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="string">&quot;2006-11-02&quot;</span>);</span><br><span class="line">        <span class="type">UserBean</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBean</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">19</span>, <span class="string">&quot;2007-11-02&quot;</span>);</span><br><span class="line">        <span class="type">UserBean</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBean</span>(<span class="number">4</span>, <span class="string">&quot;马六&quot;</span>, <span class="number">20</span>, <span class="string">&quot;2008-11-02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        userBeanList.add(user4);</span><br><span class="line">        userBeanList.add(user3);</span><br><span class="line">        userBeanList.add(user2);</span><br><span class="line">        userBeanList.add(user1);</span><br><span class="line"></span><br><span class="line">        <span class="type">SortList</span> <span class="variable">sortList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortList</span>();</span><br><span class="line">        sortList.sortByComparator(userBeanList);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>首先使用Comparator进行排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Comparator进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userBeanList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortByComparator</span><span class="params">(List&lt;UserBean&gt; userBeanList)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserBean user : userBeanList) &#123;</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序工具类</span></span><br><span class="line">        Collections.sort(userBeanList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;UserBean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(UserBean o1, UserBean o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 按照age从小到大正序排序</span></span><br><span class="line">                <span class="keyword">if</span> (o1.getAge() &gt; o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getAge() &lt; o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//或者简写为 return o1.getAge() - o2.getAge();</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserBean user : userBeanList) &#123;</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">UserBean&#123;id=<span class="number">4</span>, name=<span class="string">&#x27;马六&#x27;</span>, age=<span class="number">20</span>, birthday=<span class="string">&#x27;2008-11-02&#x27;</span>&#125;</span><br><span class="line">UserBean&#123;id=<span class="number">3</span>, name=<span class="string">&#x27;王五&#x27;</span>, age=<span class="number">19</span>, birthday=<span class="string">&#x27;2007-11-02&#x27;</span>&#125;</span><br><span class="line">UserBean&#123;id=<span class="number">2</span>, name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">18</span>, birthday=<span class="string">&#x27;2006-11-02&#x27;</span>&#125;</span><br><span class="line">UserBean&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">17</span>, birthday=<span class="string">&#x27;2005-11-02&#x27;</span>&#125;</span><br><span class="line">排序后</span><br><span class="line">UserBean&#123;id=<span class="number">1</span>, name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">17</span>, birthday=<span class="string">&#x27;2005-11-02&#x27;</span>&#125;</span><br><span class="line">UserBean&#123;id=<span class="number">2</span>, name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">18</span>, birthday=<span class="string">&#x27;2006-11-02&#x27;</span>&#125;</span><br><span class="line">UserBean&#123;id=<span class="number">3</span>, name=<span class="string">&#x27;王五&#x27;</span>, age=<span class="number">19</span>, birthday=<span class="string">&#x27;2007-11-02&#x27;</span>&#125;</span><br><span class="line">UserBean&#123;id=<span class="number">4</span>, name=<span class="string">&#x27;马六&#x27;</span>, age=<span class="number">20</span>, birthday=<span class="string">&#x27;2008-11-02&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种排序方法是Java8中提供的Stream流的方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortByStream</span><span class="params">(List&lt;UserBean&gt; userBeanList)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserBean user : userBeanList) &#123;</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        userBeanList = userBeanList.stream().sorted(Comparator.comparing(UserBean::getAge)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span>);</span><br><span class="line">    <span class="comment">// 按照age倒序排序</span></span><br><span class="line">    <span class="comment">// userBeanList.stream().sorted(Comparator.comparing(UserBean::getAge).reversed()).collect(Collectors.toList())</span></span><br><span class="line">        <span class="keyword">for</span> (UserBean user : userBeanList) &#123;</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三种方式是使用Comparable</strong>，前提是List集合中的对象需要实现Comparable接口，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBean</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;UserBean&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserBean</span><span class="params">(<span class="type">long</span> id, String name, Integer age, String birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(String birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserBean&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, birthday=&#x27;&quot;</span> + birthday + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(UserBean o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.getAge() &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.getAge() &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在类的最后定义了排序规则，按照年龄正序排序，之后排序时只需要使用Collections.Sort方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortByComparable</span><span class="params">(List&lt;UserBean&gt; userBeanList)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserBean user : userBeanList) &#123;</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Collections.sort(userBeanList);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (UserBean user : userBeanList) &#123;</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的高阶函数</title>
    <url>/posts/57202.html</url>
    <content><![CDATA[<p>把函数作为参数传入，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。</p>
<span id="more"></span>
<h2 id="体验高阶函数"><a href="#体验高阶函数" class="headerlink" title="体验高阶函数"></a>体验高阶函数</h2><p>在Python中，<code>abs()</code>函数可以完成对数字求绝对值计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(-<span class="number">10</span>)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p><code>round()</code>函数可以完成对数字的四舍五入计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">round</span>(<span class="number">1.2</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">round</span>(<span class="number">1.9</span>)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>需求：任意两个数字，按照指定要求整理数字后再进行求和计算。</p>
<ul>
<li>方法1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_num</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) + <span class="built_in">abs</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = add_num(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_num</span>(<span class="params">a, b, f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(a) + f(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = sum_num(-<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">abs</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。</p>
</blockquote>
<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
<h2 id="内置高阶函数"><a href="#内置高阶函数" class="headerlink" title="内置高阶函数"></a>内置高阶函数</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。</p>
<p>需求：计算<code>list1</code>序列中各个数字的2次方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">map</span>(func, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># &lt;map object at 0x0000013769653198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。</p>
<blockquote>
<p>注意：reduce()传入的参数func必须接收2个参数。</p>
</blockquote>
<p>需求：计算<code>list1</code>序列中各个数字的累加和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = functools.reduce(func, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个 filter 对象。如果要转换为列表, 可以使用 list() 来转换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = <span class="built_in">filter</span>(func, list1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># &lt;filter object at 0x0000017AF9DC3198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现RSA算法</title>
    <url>/posts/49034.html</url>
    <content><![CDATA[<p>1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人的名字命名，叫做 RSA 算法。直到现在，RSA 算法仍是最广泛使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。<br><span id="more"></span></p>
<h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><ul>
<li>选取大素数$p,q$;计算$n=pq$以及n的欧拉函数$φ(n) = φ(p) φ(q)=(p-1)(q-1)$。</li>
<li>选择一个$e(1&lt;e&lt;φ (n))$,使得$e$和$φ (n)$互素</li>
<li>计算$d$,使得$ed≡1(modφ(n))$，继而$(n,e)$为公钥发送到公钥空间，$(n,d)$为私钥，自己妥善保存。  </li>
</ul>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>假设明文为$m$ ,则密文为$c$, 加密公式为$c = m^e mod n$  </p>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>通过对明文$m$加密得密文为$c$,解密公式为$m=c^d mod n$  </p>
<h3 id="python代码如下"><a href="#python代码如下" class="headerlink" title="python代码如下:"></a>python代码如下:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ex_gcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;扩展欧几里德算法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        q = a // b</span><br><span class="line">        r = a % b</span><br><span class="line">        s, t = ex_gcd(b, r)</span><br><span class="line">        s, t = t, s-q*t</span><br><span class="line">    <span class="keyword">return</span> [s, t]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速幂算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fast_expmod</span>(<span class="params">a,e,n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速幂&quot;&quot;&quot;</span></span><br><span class="line">    d = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> e != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span>(e &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            d = (d * a) % n</span><br><span class="line">        e &gt;&gt;= <span class="number">1</span></span><br><span class="line">        a = a * a % n</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_key</span>(<span class="params">p, q, e</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成公私钥</span></span><br><span class="line"><span class="string">    参数1：大素数p</span></span><br><span class="line"><span class="string">    参数2：大素数q</span></span><br><span class="line"><span class="string">    参数3：随机生成e，满足 gcd(e,fin)</span></span><br><span class="line"><span class="string">    返回值：[公钥,私钥]-------[[n,e],[n,d]]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = p * q</span><br><span class="line">    fin = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">    d = ex_gcd(e, fin)[<span class="number">0</span>]      <span class="comment"># 辗转相除法求逆(广义欧几里得)</span></span><br><span class="line">    <span class="keyword">while</span> d &lt; <span class="number">0</span>:</span><br><span class="line">        d = (d+fin) % fin</span><br><span class="line">    <span class="keyword">return</span> [[n, e], [n, d]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encryption</span>(<span class="params">key, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加密</span></span><br><span class="line"><span class="string">    参数1：列表[n,e]----公钥</span></span><br><span class="line"><span class="string">    参数2：待价密数据</span></span><br><span class="line"><span class="string">    返回值：密文</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n, e = key</span><br><span class="line">    plaintext = <span class="built_in">list</span>(data)</span><br><span class="line">    ciphertext = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> plaintext:</span><br><span class="line">        ciphertext.append(fast_expmod(<span class="built_in">ord</span>(item), e, n))</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">key, ciphertext</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解密</span></span><br><span class="line"><span class="string">    参数1：key为私钥</span></span><br><span class="line"><span class="string">    参数2：密文数据</span></span><br><span class="line"><span class="string">    返回值：明文</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n, d = key</span><br><span class="line">    plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ciphertext:</span><br><span class="line">        plaintext += (<span class="built_in">chr</span>(fast_expmod(item, d, n)))</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_p_q_e</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回值：[p,q,e]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p = <span class="number">33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489</span></span><br><span class="line">    q = <span class="number">36746043666799590428244633799627952632279158164343087642676032283815739666511279233373417143396810270092798736308917</span></span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    <span class="keyword">return</span> [p, q, e]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    p, q, e = make_p_q_e()</span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    plaintext = <span class="built_in">input</span>(<span class="string">&quot;待加密数据：&quot;</span>)</span><br><span class="line">    <span class="comment"># 公钥、私钥</span></span><br><span class="line">    public_key, private_key = make_key(p, q, e)</span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    ciphertext = encryption(public_key, plaintext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加密后的数据：&quot;</span>, ciphertext)</span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = decrypt(private_key, ciphertext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密后的数据：&quot;</span>, plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架核心技术</title>
    <url>/posts/RPC_Core.html</url>
    <content><![CDATA[<p>一个较为完善的RPC框架的实现会涉及到众多的技术点，但是最核心的技术点大体上包含：服务注册与发现、网络通信协议、序列化与反序列化、RPC调用方式、线程模型、动态代理、负载均衡等。接下来，就对这些核心技术点进行简单的介绍。</p>
<h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>在分布式或微服务环境中，不同服务之间如何进行通信，这是个值得思考的问题。在早期的分布式系统中，一般是通过在服务消费者一端手动配置服务提供者的地址列表，如果服务提供者的地址列表发生变化之后，还要手动修改服务消费者中配置的服务提供者的地址，之后要重启服务消费者才能使配置生效。</p>
<p>后来可以通过服务消费者HTTP请求调用、保存服务提供者的地址列表，由程序开发人员在服务消费者中主动感知服务提供者暴露的服务信息，这就造成了服务消费者与服务提供者之间严重的耦合问题。</p>
<p>正式由于分布式系统中存在着这些问题，注册中心诞生了。在RPC框架中，主要使用注册中心实现服务的注册与发现。服务提供者上线后将自身的服务列表注册到注册中心，当服务提供者下线时，从注册中心中移除自身的服务列表。服务消费者上线后，向注册中心订阅服务提供和的服务列表，然后通过负载均衡算法选择其中一个服务节点进行调用。</p>
<p>为防止由于断网、系统宕机、程序崩溃等问题造成的注册中心一直残留无效服务列表的问题，在引入注册中心时，要采取 <strong>主动通知+心跳检测</strong> 的方案。</p>
<p><strong>具体实现的方案就是</strong> ：当服务提供者上线时，主动将自身提供的服务列表注册到注册中心；当服务提供者下线时，主动移除自身注册到注册中心的服务列表。除此之外，需要实现心跳检测的方案，心跳检测可以在服务提供者实现，也可以由注册中心实现。例如，注册中心可以每隔30秒向服务提供者发送一次心跳检测，如果连续3次未收到服务提供者的响应，则认为该服务提供者已经下线，将其注册到注册中心的服务列表移除，并通知服务消费者服务列表发生了变化。</p>
<p>采用主动通知+心跳检测的方案，当服务提供者或者服务消费者发生变化时，无需重启任何服务即可快速实现服务的注册与发现功能。</p>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p>RPC框架最主要的功能就是实现RPC远程过程调用，涉及到远程过程调用，那就一定是通过网络进行的，此时就必须通过某种网络通信协议进行数据交互，需要考虑采用哪些方式实现数据的编解码。</p>
<p>由于在分布式系统中，对RPC框架有着极高的性能要求，所以，在RPC框架中，网络通信协议的实现越简单越好，尽可能减少数据编解码和在网络传输过程中的性能损耗。</p>
<p>通用的网络协议有HTTP、TPC、UDP等，RPC框架可以基于这些通用的网络通信协议实现，也可以根据实际需求，实现自定义的网路通信协议。</p>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>数据在网路上进行传输时，需要将原始数据采用某种编码方式序列化成二进制字节流在网络上传输，不管是服务提供者还是服务消费者接收到数据后，都需要将二进制字节流数据反序列化成原始数据。为了尽可能降低序列化和反序列化带来的性能问题，一般在RPC框架中会选择比较高效的序列化算法。</p>
<p>常用的序列化框架有：<strong>FastJson、Kryo、Hessian、Protobuf等。</strong></p>
<h2 id="RPC调用方式"><a href="#RPC调用方式" class="headerlink" title="RPC调用方式"></a>RPC调用方式</h2><p>说到RPC的调用方式，可能很多小伙伴不是很了解，RPC不就是远程过程调用吗？还能有什么调用方式啊？其实一个成熟的RPC框架，例如Dubbo等会提供四种不同的调用方式，分别为：同步调用（Sync）、异步调用（Future）、回调（Callback）、单向调用（Oneway）。</p>
<h3 id="同步调用（Sync）"><a href="#同步调用（Sync）" class="headerlink" title="同步调用（Sync）"></a>同步调用（Sync）</h3><p>同步调用（Sync）：服务消费者发起RPC调用后，线程会一直阻塞，直到服务提供者返回结果或者超时异常。在RPC框架中，一般会采用同步调用的方式，但是在RPC框架内部的实现中，本质上还是采用的是异步处理。例如，Dubbo中就存在着经典的异步转同步的逻辑。另外，当采用同步调用方式时，要设置超时时间。如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/RPC%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="RPC同步调用"></p>
<h3 id="异步调用（Future）"><a href="#异步调用（Future）" class="headerlink" title="异步调用（Future）"></a>异步调用（Future）</h3><p>异步调用（Future）：服务消费者发起RPC调用后，线程不会阻塞，获取到RPC框架返回的Future对象。RPC调用的结果数据会被服务提供者缓存起来，服务消费者根据自身实际情况决定获取结果数据。当服务消费者主动获取异步结果数据时是阻塞的。如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/RPC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="RPC异步调用"></p>
<h3 id="回调（Callback）"><a href="#回调（Callback）" class="headerlink" title="回调（Callback）"></a>回调（Callback）</h3><p>服务消费者发起RPC调用后，会将回调接口Callback对象发送给RPC框架。此时也不需要同步等待RPC框架的返回结果，直接返回。当RPC框架接收到服务提供者处理的结果数据或者超时异常后，会执行Callback回调。一般在定义和实现Callback接口时，都要实现处理成功的方法和异常方法。例如 success(Object result) 方法和 fail(Exception e) 方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/RPC%E5%9B%9E%E8%B0%83.png" alt="RPC回调"></p>
<h3 id="单向调用（Oneway）"><a href="#单向调用（Oneway）" class="headerlink" title="单向调用（Oneway）"></a>单向调用（Oneway）</h3><p>服务消费者发送RPC调用后，直接返回，忽略返回结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/RPC%E5%8D%95%E5%90%91%E8%B0%83%E7%94%A8.png" alt="RPC单向调用"></p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>对于一个成熟并且完善的RPC框架来说，线程模型是其必须要关注的。一般情况下，在RPC框架中，线程模型会分为IO线程和业务线程。例如，大名鼎鼎的Dubbo底层使用的是Netty进行网络通信，并且在使用Netty时，采用了Reactor线程模型。使用Netty时创建的Boss线程池和Worker线程池就可以看作是IO线程。</p>
<h3 id="如何选择执行线程"><a href="#如何选择执行线程" class="headerlink" title="如何选择执行线程"></a>如何选择执行线程</h3><p>IO线程主要用来负责事件轮询、数据的编解码，数据传输等功能。如果在整个数据处理或者业务处理的过程中，不涉及复杂的逻辑计算、数据库查询等操作，并且整个处理过程可以立即完成，则可以将整个处理过程放在IO线程中完成。否则，就需要将数据的处理或者业务处理放在业务线程中执行，以免阻塞IO线程。</p>
<h3 id="Dubbo线程模型的分发策略"><a href="#Dubbo线程模型的分发策略" class="headerlink" title="Dubbo线程模型的分发策略"></a>Dubbo线程模型的分发策略</h3><p>Dubbo提供了五种可配置的线程分发策略，也就是利用这五种策略分别确定了哪些逻辑在IO线程中执行，哪些逻辑在业务线程中执行。这里，我将Dubbo中提供的五种线程分发策略总结如下所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/Dubbo%E7%BA%BF%E7%A8%8B%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png" alt="Dubbo线程分发策略"></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>RPC框架能够使得开发人员像调用本地服务一样调用远程服务，这得益于动态代理技术。可以这么说，几乎每一款成熟并且完善的RPC框架都离不开动态代理技术。</p>
<p>利用动态代理技术创建一个代理对象，在代理对象中完成数据的编码操作，发起远程调用，将数据发送给服务提供者，接收从服务提供者返回的数据，进行解码等操作。代理对象屏蔽了RPC框架底层的调用细节。</p>
<p>RPC框架离不开动态代理技术，并且代理对象是在程序运行时动态生成的，所以生成代理类的速度和字节码大小都会影响到RPC框架的整体性能以及对系统资源的消耗程度，所以，选择动态代理技术时需要综合考虑生成代理类的速度和生成的字节码大小。</p>
<p>目前常用的动态代理技术有：<strong>JDK 动态代理、Cglib、Javassist、ASM、Byte Buddy</strong>。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理在运行时可以动态生成代理对象，但是使用JDK动态代理时，代理对象必须实现一个接口，这是因为生成的代理对象继承了Proxy类，并且生成的代理对象不能代理接口中未定义的方法。另外，JDK动态代理通过反射代理类中的方法，比直接调用方法的性能要低。</p>
<h3 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h3><p>Cglib动态代理是通过ASM字节码生成框架实现的，通过ASM字节码技术生成代理类，并且生成的代理类会继承被代理类，所以，代理类的类型不受限制。因为生成的代理类会继承被代理类，这就要求被代理类不能使用final关键字修饰。Cglib动态代理是通过FastClass利用index索引直接定位要调用的方法进行直接调用，在性能上比JDK动态代理高。</p>
<h3 id="Javassist和ASM"><a href="#Javassist和ASM" class="headerlink" title="Javassist和ASM"></a>Javassist和ASM</h3><p>Javassist和ASM都是操作Java字节码的框架，使用这两个框架时，需要开发人员对Class文件的结构以及一些JVM的知识有所了解。但是这两种框架生成的代理对象的执行性能都比反射要高。</p>
<h3 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte Buddy"></a>Byte Buddy</h3><p>Byte Buddy也是一个操作字节码的类库，Byte Buddy的功能强大，相比Javassist和ASM来说，Byte Buddy提供了更加方便的API来创建和修改Java的字节码，并且使用Byte Buddy时，不需要理解字节码的格式，性能也更加优越。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>在分布式系统中，往往服务提供者和服务消费者都不会存在单点的情况，二者在实现上都会存在多个节点，那服务消费者如何从多个服务提供者节点中选择一个进行远程调用呢？这就要求RPC框架在实现上支持负载均衡。</p>
<p>在RPC框架的实现中，负载均衡策略和算法也是影响RPC框架吞吐量的一个重要因素。常用的负载均衡算法包括：轮询（Round-Robin）、加权轮询（Weighted Round-Robin）、最少连接数（Least Connections）、一致性Hash（Consistent Hash）。</p>
<h3 id="轮询（Round-Robin）"><a href="#轮询（Round-Robin）" class="headerlink" title="轮询（Round-Robin）"></a>轮询（Round-Robin）</h3><p>轮询（Round-Robin）负载均衡算法是依次轮询服务提供者节点，并且不会考虑服务提供者节点的实际负载情况。</p>
<h3 id="加权轮询（Weighted-Round-Robin）"><a href="#加权轮询（Weighted-Round-Robin）" class="headerlink" title="加权轮询（Weighted Round-Robin）"></a>加权轮询（Weighted Round-Robin）</h3><p>加权轮询（Weighted Round-Robin）负载均衡算法在轮询（Round-Robin）算法的基础上，为每个服务提供者节点增加了权重系数，根据权重系数来为每个服务提供者节点分配不同比例的流量。并且权重系数可以根据服务提供者节点的实时负载情况进行调整，使集群节点的负载相对来说比较均衡。</p>
<h3 id="最少连接数（Least-Connections）"><a href="#最少连接数（Least-Connections）" class="headerlink" title="最少连接数（Least Connections）"></a>最少连接数（Least Connections）</h3><p>最少连接数（Least Connections）负载均衡算法是服务消费者根据服务提供者节点当前的连接数进行负载均衡，服务消费者会选择连接数最少的一个服务提供者节点进行调用。</p>
<h3 id="一致性Hash（Consistent-Hash）"><a href="#一致性Hash（Consistent-Hash）" class="headerlink" title="一致性Hash（Consistent Hash）"></a>一致性Hash（Consistent Hash）</h3><p>一致性Hash（Consistent Hash）负载均衡算法是一种特殊的Hash算法，它在逻辑上采用Hash环实现，通过Hash算法将对象和服务提供者节点放在Hash环上，为对象选择对应的服务提供者节点，例如，在Hash环上按照顺时针查找距离对象的Hash值最近的服务提供者节点。使用一致性Hash算法使得当服务提供者上线或下线时，不会造成Hash环上对象的大规模移动。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/posts/java-basic.html</url>
    <content><![CDATA[<h3 id="😀-JDK和JRE有什么区别"><a href="#😀-JDK和JRE有什么区别" class="headerlink" title="😀 JDK和JRE有什么区别"></a>😀 JDK和JRE有什么区别</h3><ul>
<li>JDK:Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE:Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提 供了所需环境。</li>
</ul>
<h3 id="😀-Java8的新特性"><a href="#😀-Java8的新特性" class="headerlink" title="😀 Java8的新特性"></a>😀 Java8的新特性</h3><ul>
<li>Lambda 表达式:Lambda 允许把函数作为一个方法的参数</li>
<li>Stream API : 新添加的 Stream API(java.util.stream) 把真正的函数式编程风格引入到 Java 中</li>
<li>方法引用: 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象 (实例)的方法或构造器。</li>
<li>默认方法: 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>Optional 类 :Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Date Time API :加强对日期与时间的处理。</li>
</ul>
<h3 id="😀-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#😀-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="😀 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>😀 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p>
<h3 id="😀-说说-amp-和-amp-amp-的区别"><a href="#😀-说说-amp-和-amp-amp-的区别" class="headerlink" title="😀 说说&amp;和&amp;&amp;的区别"></a>😀 说说&amp;和&amp;&amp;的区别</h3><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，a&amp;b 表示把 a 和 b 都转换成二进制数，再进行与的运算;</p>
<h3 id="😀-在JAVA中如何跳出当前的多重嵌套循环？"><a href="#😀-在JAVA中如何跳出当前的多重嵌套循环？" class="headerlink" title="😀 在JAVA中如何跳出当前的多重嵌套循环？"></a>😀 在JAVA中如何跳出当前的多重嵌套循环？</h3><p>让外层的循环条件表达式的结果可以受到内层循环体代码的控制，例如，要在二维数组中查找到某个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length &amp;&amp; !found; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] == <span class="number">5</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="😀-switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#😀-switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="😀 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>😀 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h3><p>在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。</p>
<p>switch 不可作用于 long double float boolean，以及他们的包装类；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖,内部实现在 switch 中使用字符串的 hashcode。</p>
<h3 id="😀-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#😀-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="😀 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>😀 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h3><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。</p>
<p>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<h3 id="😀-char型变量中能不能存贮一个中文汉字-为什么"><a href="#😀-char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="😀 char型变量中能不能存贮一个中文汉字?为什么?"></a>😀 char型变量中能不能存贮一个中文汉字?为什么?</h3><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h3 id="😁-用最有效率的方法算出2乘以8等于几"><a href="#😁-用最有效率的方法算出2乘以8等于几" class="headerlink" title="😁 用最有效率的方法算出2乘以8等于几?"></a>😁 用最有效率的方法算出2乘以8等于几?</h3><p>2 &lt;&lt; 3。因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算是cpu直接支持的，效率最高，所以，2乘以8等于几的最高效的方法是2 &lt;&lt; 3。</p>
<h3 id="😀-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#😀-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="😀 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>😀 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><p><strong>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。</strong>例如，对于如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuffer a=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;immutable&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>执行如下语句将报告编译期错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是，执行如下语句则可以通过编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.append(<span class="string">&quot; broken!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="keyword">final</span> StringBuffer param)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">param.append(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="😀-“-”和equals方法究竟有什么区别？"><a href="#😀-“-”和equals方法究竟有什么区别？" class="headerlink" title="😀 “==”和equals方法究竟有什么区别？"></a>😀 “==”和equals方法究竟有什么区别？</h3><p><code>==</code>对于基本数据类型和引用数据类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p>因为 Java 只有值传递，所以，对于 <code>==</code> 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>==o;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals()</code>方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的内容是否相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<h3 id="😀-什么是值传递和引用传递？"><a href="#😀-什么是值传递和引用传递？" class="headerlink" title="😀 什么是值传递和引用传递？"></a>😀 什么是值传递和引用传递？</h3><ul>
<li>值传递是对基本型变量而言的,传递的是该变量的一个副本，改变副本不影响原变量.</li>
<li>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.</li>
</ul>
<h3 id="😀-静态变量和成员变量的区别？"><a href="#😀-静态变量和成员变量的区别？" class="headerlink" title="😀 静态变量和成员变量的区别？"></a>😀 静态变量和成员变量的区别？</h3><p>在语法定义上的区别：静态变量前要加static关键字，而成员变量前则不加。</p>
<p>在程序运行时的区别：成员变量是属于某个对象的属性，必须创建了实例对象，其中的成员变量才会被分配空间，才能使用这个成员变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，成员变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<h3 id="😀-是否可以从一个static方法内部发出对非static方法的调用？"><a href="#😀-是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="😀 是否可以从一个static方法内部发出对非static方法的调用？"></a>😀 是否可以从一个static方法内部发出对非static方法的调用？</h3><p>不可以。</p>
<p>因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不可以发出对非static方法的调用。</p>
<h3 id="😀-可以在-static-环境中访问非-static-变量吗"><a href="#😀-可以在-static-环境中访问非-static-变量吗" class="headerlink" title="😀 可以在 static 环境中访问非 static 变量吗?"></a>😀 可以在 static 环境中访问非 static 变量吗?</h3><p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。因为静态的成员属于类， 随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建， 没有实例，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态!</p>
<h3 id="😀-Integer与int的区别"><a href="#😀-Integer与int的区别" class="headerlink" title="😀 Integer与int的区别"></a>😀 Integer与int的区别</h3><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，Integer使用需要判空处理。例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<p>Integer 的缓存机制:为了节省内存和提高性能，Integer 类在内部通过使用相同的对象引用实现缓存和重用，Integer 类默认在-128 ~ 127 之间，可以通过 - XX:AutoBoxCacheMax 进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建 Integer 对象时无用。</p>
<h3 id="😀-Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#😀-Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="😀 Math.round(11.5)等于多少? Math.round(-11.5)等于多少?"></a>😀 Math.round(11.5)等于多少? Math.round(-11.5)等于多少?</h3><p>Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；<strong>最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</strong></p>
<h3 id="😀-请说出作用域public，private，protected，以及不写时的区别。"><a href="#😀-请说出作用域public，private，protected，以及不写时的区别。" class="headerlink" title="😀 请说出作用域public，private，protected，以及不写时的区别。"></a>😀 请说出作用域public，private，protected，以及不写时的区别。</h3><p>这四个作用域的可见范围如下表所示</p>
<p>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">作用域</th>
<th style="text-align:left">当前类</th>
<th style="text-align:left">同一package</th>
<th style="text-align:left">子孙类</th>
<th style="text-align:left">其他package</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
</tr>
<tr>
<td style="text-align:left">friendly</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p>
</li>
<li><p>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用。</p>
</li>
<li><p>protected：protected对于子类、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。</p>
</li>
</ul>
<h3 id="😀-Overload-重载-和Override-重写-的区别。Overloaded的方法是否可以改变返回值的类型"><a href="#😀-Overload-重载-和Override-重写-的区别。Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="😀 Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?"></a>😀 Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?</h3><p>重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
<p>重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。<strong>如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</strong></p>
<p>如果几个Overloaded的方法的参数列表不一样，它们的返回者类型也可以不一样。</p>
<p>如果两个方法的参数列表完全一样，则不可以让它们的返回值不同来实现重载Overload。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候<strong>假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，Java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</strong></p>
<p>override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：</p>
<p>1）覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
<p>2）覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
<p>3）覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
<p>4）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<h3 id="😀-构造方法是否可以被重写"><a href="#😀-构造方法是否可以被重写" class="headerlink" title="😀 构造方法是否可以被重写?"></a>😀 构造方法是否可以被重写?</h3><p>构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以谈不上继承。 又由于构造器不能被继承，所以相应的就不能被重写了。但可以被重载Overload。</p>
<h3 id="😀-接口是否可继承接口-抽象类是否可实现接口-抽象类是否可继承具体类-抽象类中是否可以有静态的main方法？"><a href="#😀-接口是否可继承接口-抽象类是否可实现接口-抽象类是否可继承具体类-抽象类中是否可以有静态的main方法？" class="headerlink" title="😀 接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承具体类? 抽象类中是否可以有静态的main方法？"></a>😀 接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承具体类? 抽象类中是否可以有静态的main方法？</h3><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。</p>
<p>抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。</p>
<h3 id="😀-如何实现对象的克隆"><a href="#😀-如何实现对象的克隆" class="headerlink" title="😀 如何实现对象的克隆"></a>😀 如何实现对象的克隆</h3><ul>
<li>实现 Cloneable 接口，重写 clone() 方法。</li>
<li>Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。</li>
<li>对象的属性的 Class 也实现 Cloneable 接口，在克隆对象时也手动克隆属性，完成深拷贝</li>
<li>结合序列化(JDK java.io.Serializable 接口、JSON 格式、XML 格式等)，完成深拷贝</li>
</ul>
<h3 id="😀-写clone-方法时，通常都有一行代码，是什么？"><a href="#😀-写clone-方法时，通常都有一行代码，是什么？" class="headerlink" title="😀 写clone()方法时，通常都有一行代码，是什么？"></a>😀 写clone()方法时，通常都有一行代码，是什么？</h3><p>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。</p>
<h3 id="😀-面向对象的”六原则一法则”"><a href="#😀-面向对象的”六原则一法则”" class="headerlink" title="😀 面向对象的”六原则一法则”"></a>😀 面向对象的”六原则一法则”</h3><ul>
<li><strong>单一职责原则:</strong> 一个类只做它该做的事情。</li>
<li><strong>开闭原则:</strong> 软件实体应当对扩展开放，对修改关闭。</li>
<li><strong>依赖倒转原则:</strong> 面向接口编程。</li>
<li><strong>接口隔离原则:</strong> 接口要小而专，绝不能大而全。</li>
<li><strong>合成聚合复用原则:</strong> 优先使用聚合或合成关系复用代码。</li>
<li><strong>迪米特法则:</strong> 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li>
</ul>
<h3 id="😀-面向对象的特征有哪些方面"><a href="#😀-面向对象的特征有哪些方面" class="headerlink" title="😀 面向对象的特征有哪些方面"></a>😀 面向对象的特征有哪些方面</h3><p>面向对象的编程语言有<strong>封装、继承 、抽象、多态</strong>等4个主要的特征。</p>
<p><strong>1）封装：</strong></p>
<p>面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了。</p>
<p>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。</p>
<p>优点:</p>
<ul>
<li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p><strong>说到封装，为什么有了私有属性，还要提供对外访问的公有方法，这样属性私有有什么意义</strong>？</p>
<p>其实这里体现的就是封装的思想: <strong>将数据与行为进行分离。</strong></p>
<p>试想， 如果外面的程序可以随意修改一个类的成员变量，会造成不可预料的程序错误， 就象一个人的名字，<br>不能被外部随意修改，只能通过各种给定的方法去修改这个属性。<br>所以我们将成员变量声明为private，再通过 public的方法来对这个变量进行访问。</p>
<p>对一个变量的操作，一般都有读取和赋值操作，我们分别定义两个方法来实现这两种操作：<br>一个是getXxx()（Xxx 表示要访问的成员变量的名字），用来获取这个成员变量；<br>另外一个是 setXxx()用来对这个成员变量修改。<strong>我们可以在set方法里做变量赋值逻辑判断，如果外部类赋的值不符合规则的话，就赋值失败。</strong></p>
<p><strong>2）继承：</strong></p>
<p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p>
<p><strong>3）抽象：</strong></p>
<p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：</p>
<p>class Person{</p>
<p>String name;</p>
<p>int age;</p>
<p>}</p>
<p>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。</p>
<p><strong>4）多态：</strong></p>
<p>多态分为编译时多态和运行时多态:</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件:</p>
<ul>
<li>继承</li>
<li>覆盖(重写)</li>
<li>向上转型</li>
</ul>
<p><strong>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定</strong>，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。</p>
<h3 id="😀-Java中实现多态的机制是什么？"><a href="#😀-Java中实现多态的机制是什么？" class="headerlink" title="😀 Java中实现多态的机制是什么？"></a>😀 Java中实现多态的机制是什么？</h3><ul>
<li>多态机制包括静态多态(编译时多态)和动态多态(运行时多态)</li>
<li>静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法。</li>
<li>我们通常所说的多态一般指运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直等到运行时才能确定。</li>
<li>多态实现方式:子类继承父类(extends)和类实现接口(implements)</li>
<li>多态核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果</li>
<li>Java 里对象方法的调用是依靠类信息里的方法表实现的，对象方法引用调用和接口方法引用调用的大致思想是一样的。当调用对象的某个方法时，JVM 查找该对象 类的方法表以确定该方法的直接引用地址，有了地址后才真正调用该方法。</li>
</ul>
<h3 id="😀-Java为什么不支持多继承"><a href="#😀-Java为什么不支持多继承" class="headerlink" title="😀 Java为什么不支持多继承"></a>😀 Java为什么不支持多继承</h3><ul>
<li>安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</li>
<li>Java 提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li>
</ul>
<h3 id="😀-abstract-class-抽象类-和interface-接口-有什么区别"><a href="#😀-abstract-class-抽象类-和interface-接口-有什么区别" class="headerlink" title="😀 abstract class(抽象类)和interface(接口)有什么区别?"></a>😀 abstract class(抽象类)和interface(接口)有什么区别?</h3><p>含有abstract修饰符的class即为抽象类，<strong>abstract 类不能创建实例对象。</strong>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p>
<p>下面比较一下两者的语法区别：</p>
<p>1）抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>2）抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>3）抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>4） 抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p>
<p>5）抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>6）抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
<p>7）一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p><strong>接口的变量为什么是static和final的？</strong></p>
<p>static：必须。因为接口是可以多继承的。如果一个类实现了两个接口，且两个接口都具有相同名字的变量，此时这个变量可以被实现类使用，那么如果不是static的，这个变量来自哪一个接口就会产生歧义，所以实现类使用接口中的变量必须通过接口名指定，也就只能定为static的。</p>
<p>final：我认为因为必须是<a href="https://so.csdn.net/so/search?q=static&amp;spm=1001.2101.3001.7020">static</a>的，那么所有子类共享，而接口是一种抽象， 所以一个子类修改了值会影响到其他所有子类，因此就不应该允许子类修改这个值，所以定义为final。</p>
<p><strong>下面接着再说说两者在应用上的区别：</strong></p>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 记录访问日志, 进行权限判断</span></span><br><span class="line">        <span class="keyword">if</span> (具有权限) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doService(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// todo：记录异常信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet1</span> <span class="keyword">extends</span> <span class="title class_">BaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion, ServletException &#123;</span><br><span class="line">        <span class="comment">// 本Servlet只处理的具体业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。</p>
<h3 id="😀-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized"><a href="#😀-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized" class="headerlink" title="😀 abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?"></a>😀 abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</h3><p>abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</p>
<p>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputStream类要和硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下：</p>
<p>private native void open(String name) throws FileNotFoundException;</p>
<p>如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。</p>
<p>关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。</p>
<h3 id="😀-什么是内部类？静态内部类和内部类的不同"><a href="#😀-什么是内部类？静态内部类和内部类的不同" class="headerlink" title="😀 什么是内部类？静态内部类和内部类的不同"></a>😀 什么是内部类？静态内部类和内部类的不同</h3><p><strong>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</strong>（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），<strong>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out_x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在方法体内部定义的内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner2</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                out_x = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner2</span> <span class="variable">inner2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在方法体外面定义的内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法体外面定义的内部类的访问类型可以是public,protected,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner1</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Innner1</span>();</span><br></pre></td></tr></table></figure>
<p><strong>在方法内部定义的内部类前面不能有访问类型修饰符</strong>，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>
<p>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class不能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。</p>
<p>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>备注：首先根据印象说出自己对内部类的总体方面的特点。例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</p>
<h3 id="😀-内部类可以引用它的包含类的成员吗？有没有什么限制？"><a href="#😀-内部类可以引用它的包含类的成员吗？有没有什么限制？" class="headerlink" title="😀 内部类可以引用它的包含类的成员吗？有没有什么限制？"></a>😀 内部类可以引用它的包含类的成员吗？有没有什么限制？</h3><p>完全可以。如果不是静态内部类，那没有什么限制！</p>
<p>如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            syso(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="😀-匿名内部类是否可以继承其它类，是否可以实现接口？"><a href="#😀-匿名内部类是否可以继承其它类，是否可以实现接口？" class="headerlink" title="😀 匿名内部类是否可以继承其它类，是否可以实现接口？"></a>😀 匿名内部类是否可以继承其它类，是否可以实现接口？</h3><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<p><strong>可以继承其他类或实现其他接口。不仅是可以，而是必须!</strong></p>
<h3 id="😀-匿名内部类的特点"><a href="#😀-匿名内部类的特点" class="headerlink" title="😀 匿名内部类的特点"></a>😀 匿名内部类的特点</h3><ul>
<li><p>没有名字</p>
</li>
<li><p>匿名内部类必须继承一个抽象类或者实现一个接口。</p>
</li>
<li><p>匿名内部类不能定义任何静态成员和静态方法。</p>
</li>
<li><p>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220909154956592-20231217153340288.png" alt="image-20220909154956592" style="zoom:33%;" /></p>
</li>
<li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
</li>
<li><p>匿名内部类不能访问外部类方法中的局部变量，除非该变量被声明为 final 类型</p>
</li>
</ul>
<h3 id="😀-静态内部类与非静态内部类有什么区别"><a href="#😀-静态内部类与非静态内部类有什么区别" class="headerlink" title="😀 静态内部类与非静态内部类有什么区别"></a>😀 静态内部类与非静态内部类有什么区别</h3><ul>
<li>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员和静态方法,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</li>
<li>实例化静态内部类与非静态内部类的方式不同</li>
<li>调用内部静态类的方法或静态变量,可以通过类名直接调用</li>
</ul>
<h3 id="😀-super-getClass-方法调用"><a href="#😀-super-getClass-方法调用" class="headerlink" title="😀 super.getClass()方法调用"></a>😀 super.getClass()方法调用</h3><p>下面程序的输出结果是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Test</span>().test();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">super</span>.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很奇怪，结果是Test。</p>
<p>在test方法中，直接调用getClass().getName()方法，返回的是Test类名。由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。</p>
<p>如果想得到父类的名称，应该用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getClass().getSuperClass().getName();</span><br></pre></td></tr></table></figure>
<h3 id="😀-String-为什么是不可变的"><a href="#😀-String-为什么是不可变的" class="headerlink" title="😀 String 为什么是不可变的?"></a>😀 String 为什么是不可变的?</h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="😀-String类的常用方法都有哪些"><a href="#😀-String类的常用方法都有哪些" class="headerlink" title="😀 String类的常用方法都有哪些?"></a>😀 String类的常用方法都有哪些?</h3><ul>
<li><p>indexOf():返回指定字符的索引。</p>
</li>
<li><p>charAt():返回指定索引处的字符。</p>
</li>
<li>replace():字符串替换。</li>
<li>trim():去除字符串两端空白。</li>
<li>split():分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes():返回字符串的 byte 类型数组。</li>
<li>length():返回字符串长度。</li>
<li>toLowerCase():将字符串转成小写字母。</li>
<li>toUpperCase():将字符串转成大写字符。</li>
<li>substring():截取字符串。</li>
<li>equals():字符串比较。</li>
</ul>
<h3 id="😀-object中定义了哪些方法？"><a href="#😀-object中定义了哪些方法？" class="headerlink" title="😀 object中定义了哪些方法？"></a>😀 object中定义了哪些方法？</h3><ul>
<li>getClass(); 获取类结构信息</li>
<li>hashCode() 获取哈希码</li>
<li>equals(Object) 默认比较对象的地址值是否相等，子类可以重写比较规则</li>
<li>clone() 用于对象克隆</li>
<li>toString() 把对象转变成字符串</li>
<li>notify() 多线程中唤醒功能</li>
<li>notifyAll() 多线程中唤醒所有等待线程的功能</li>
<li>wait() 让持有对象锁的线程进入等待</li>
<li>wait(long timeout) 让持有对象锁的线程进入等待，设置超时毫秒数时间</li>
<li>wait(long timeout, int nanos) 让持有对象锁的线程进入等待，设置超时纳秒数时间</li>
<li>finalize() 垃圾回收前执行的方法</li>
</ul>
<h3 id="😀-String、StringBuffer、StringBuilder-的区别？"><a href="#😀-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="😀 String、StringBuffer、StringBuilder 的区别？"></a>😀 String、StringBuffer、StringBuilder 的区别？</h3><ul>
<li><p><strong>可变性</strong>：String是不可变的，<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
</li>
<li><p><strong>线程安全性</strong>:<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。 </p>
</li>
<li><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p>
</li>
</ul>
<h3 id="😀-如何将String字符串反转？"><a href="#😀-如何将String字符串反转？" class="headerlink" title="😀 如何将String字符串反转？"></a>😀 如何将String字符串反转？</h3><ul>
<li>使用 StringBuilder 或 StringBuffer 的 reverse 方法，本质都调用了它们的父类 AbstractStringBuilder 的 reverse 方法实现。(JDK1.8)</li>
<li>使用 chatAt 函数，倒过来输出;</li>
</ul>
<h3 id="😀-String-s-“Hello”-s-s-“-world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？"><a href="#😀-String-s-“Hello”-s-s-“-world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？" class="headerlink" title="😀 String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？"></a>😀 String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</h3><p>没有。</p>
<p>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。</p>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> Demo &#123;</span><br><span class="line">	s = <span class="string">&quot;Initial Value&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Initial Value&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。</p>
<p>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。</p>
<p>至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。</p>
<h3 id="😀-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？"><a href="#😀-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？" class="headerlink" title="😀 String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？"></a>😀 String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</h3><p>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代码就不会创建”xyz”自己了，直接从缓冲区拿。</p>
<h3 id="😀-String-s-与-new-String-与有什么区别"><a href="#😀-String-s-与-new-String-与有什么区别" class="headerlink" title="😀 String s 与 new String 与有什么区别"></a>😀 String s 与 new String 与有什么区别</h3><p>String str =”abc”;</p>
<p>String newStr =new String (“abc”); </p>
<p>String str =”abc”, 先在常量池中查找有没有”abc” 这个对象,如果有，就让 str 指向那个”abc”.如 果没有，在常量池中新建一个“abc”对象，并让 str 指向在常量池中新建的对象”abc”。</p>
<p>String newStr =new String (“abc”); 是在堆中建立的对象”abc” ,在栈中创建堆中”abc” 对象的内存地址。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220908150355631-20231217153340551.png" alt="image-20220908150355631"></p>
<h3 id="😀-String-和StringBuffer的区别"><a href="#😀-String-和StringBuffer的区别" class="headerlink" title="😀 String 和StringBuffer的区别"></a>😀 String 和StringBuffer的区别</h3><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串可以进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffer来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p>
<p>接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	sbf.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	str = str + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。</p>
<h3 id="😀-在自己的代码中，如果创建一个-java-lang-String-类，-这个类是否可以被类加载器加载-为什么。"><a href="#😀-在自己的代码中，如果创建一个-java-lang-String-类，-这个类是否可以被类加载器加载-为什么。" class="headerlink" title="😀 在自己的代码中，如果创建一个 java.lang.String 类， 这个类是否可以被类加载器加载?为什么。"></a>😀 在自己的代码中，如果创建一个 java.lang.String 类， 这个类是否可以被类加载器加载?为什么。</h3><p>不可以。因为 JDK 处于安全性的考虑，基于双亲委派模型，优先加载 JDK 的 String 类，如果 java.lang.String 已经加载，便不会再次被加载。</p>
<h3 id="😀-下面这条语句一共创建了多少个对象-String-s-”a”-”b”-”c”-”d”"><a href="#😀-下面这条语句一共创建了多少个对象-String-s-”a”-”b”-”c”-”d”" class="headerlink" title="😀 下面这条语句一共创建了多少个对象? String s=”a”+”b”+”c”+”d”;"></a>😀 下面这条语句一共创建了多少个对象? String s=”a”+”b”+”c”+”d”;</h3><p>对于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">System.out.println(s3 == <span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。</p>
<p><code>String s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;</code>相当于直接定义了一个”abcd”的字符串，写如下两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(s == <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Java 编译器对字符串常量直接相加的表达式进行优化，不等到运行期去进行加 法运算，在编译时就去掉了加号，直接将其编译成一个这些常量相连的结果。 所以 “a”+”b”+”c”+”d” 相当于直接定义一个 “abcd” 的字符串。</p>
<p>最终打印的结果应该为true。</p>
<h3 id="😀-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#😀-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="😀 try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>😀 try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</h3><p>也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ++x;</span><br><span class="line">           <span class="comment">// return x;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————-执行结果 ————-</p>
<p>1</p>
<p>运行结果是1，为什么呢？如果在try中return的情况下，先把try中将要return的值先存到一个本地变量中，即本例中的x=1将会被保存下来。接下来去执行finally语句，最后返回的是存在本地变量中的值，即返回x=1.</p>
<p>还有一点要注意的，如果你在finally里也用了return语句，比如return ++x。那么程序返回值会是2。因为JVM规范规定了，当try和finally里都有return时，会忽略try的return，而使用finally的return。</p>
<h3 id="😀-try-catch-finally-return-执行顺序"><a href="#😀-try-catch-finally-return-执行顺序" class="headerlink" title="😀 try-catch-finally-return 执行顺序"></a>😀 try-catch-finally-return 执行顺序</h3><ul>
<li>如果不发生异常，不会执行 catch 部分。</li>
<li>不管有没有发生异常，finally 都会执行到。</li>
<li>即使 try 和 catch 中有 return 时，finally 仍然会执行</li>
<li>finally 是在 return 后面的表达式运算完后再执行的。(此时并没有返回运算后的值，而是先把要返回的值保存起来，若 finally 中无 return，则不管 finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，该情况下函数返回值是在 finally 执行前确定的)</li>
<li>finally 部分就不要 return 了，要不然，就回不去 try 或者 catch 的 return 了。</li>
</ul>
<h3 id="😀-final-finally-finalize的区别"><a href="#😀-final-finally-finalize的区别" class="headerlink" title="😀 final, finally, finalize的区别"></a>😀 final, finally, finalize的区别</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可重写，类不可继承。</p>
<p>内部类要访问局部变量，局部变量必须定义成final类型。</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用</p>
<h3 id="😀-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#😀-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="😀 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>😀 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h3><p>字节流，字符流。</p>
<p>字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<h3 id="😀-Java-中-IO-流分为几种"><a href="#😀-Java-中-IO-流分为几种" class="headerlink" title="😀 Java 中 IO 流分为几种?"></a>😀 Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="😀-字节流与字符流的区别"><a href="#😀-字节流与字符流的区别" class="headerlink" title="😀 字节流与字符流的区别"></a>😀 字节流与字符流的区别</h3><p>要把一片二进制数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>在应用中，经常要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</p>
<p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。</p>
<p>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p>
<p><strong>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</strong></p>
<h3 id="😀-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用"><a href="#😀-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用" class="headerlink" title="😀 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用"></a>😀 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用</h3><p><strong>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象</strong>，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。</p>
<p>例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过RPC等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。</p>
<h3 id="😀-Java源码的编译过程？"><a href="#😀-Java源码的编译过程？" class="headerlink" title="😀 Java源码的编译过程？"></a>😀 Java源码的编译过程？</h3><p>Java源码是由Javac编译器编译的，流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20170205113216819.jpg" alt=""></p>
<p>Javac的任务就是将Java源代码编译成Java字节码，总结过程如下：</p>
<p>源代码-&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器</p>
<p><strong>词法分析就是将关键词组织成token流即检查源码中的的关键词是否正确并组织成token流，而语法分析就是检查源码是否符合java语法规范并将词组成语句。语义分析就是简化复杂的添加缺少的，检查变量类型是否合法。字节码生成器就是遍历这棵树生成符合JVM规范的字节码。</strong></p>
<p> 1）<strong>词法分析</strong>：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程。</p>
<p>词法分析的结果：就是从源代码中找出了一些规范化的token流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。</p>
<p>2）<strong>语法分析</strong>：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。</p>
<p>语法分析的结果：就是形成一个符合Java语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。</p>
<p>3）<strong>语义分析</strong>：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。</p>
<p>语义分析结果：就是将复杂的语法转化为简单的语法，对应到Java就是将foreach转化为for循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。</p>
<p>4）<strong>字节码生成</strong>：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装文英文语句。代码生成器的结果就是生成符合java虚拟机规范的字节码。</p>
<h3 id="😀-一个Object占多少字节？"><a href="#😀-一个Object占多少字节？" class="headerlink" title="😀 一个Object占多少字节？"></a>😀 一个Object占多少字节？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// o普通对象指针（Oops）4 字节（开启压缩占 4 字节，没开启占 8 字节），object对象占 16 字节 </span></span><br></pre></td></tr></table></figure>
<h3 id="😀-什么是字节码-采用字节码的好处是什么"><a href="#😀-什么是字节码-采用字节码的好处是什么" class="headerlink" title="😀 什么是字节码?采用字节码的好处是什么?"></a>😀 什么是字节码?采用字节码的好处是什么?</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<h3 id="😀-Java-程序从源代码到运行的过程"><a href="#😀-Java-程序从源代码到运行的过程" class="headerlink" title="😀 Java 程序从源代码到运行的过程"></a>😀 Java 程序从源代码到运行的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220209132736220.png" alt="image-20220209132736220"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。 </p>
<h3 id="😀-静态方法为什么不能调用非静态成员"><a href="#😀-静态方法为什么不能调用非静态成员" class="headerlink" title="😀 静态方法为什么不能调用非静态成员?"></a>😀 静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="😀-静态方法和实例方法有何不同？"><a href="#😀-静态方法和实例方法有何不同？" class="headerlink" title="😀 静态方法和实例方法有何不同？"></a>😀 静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h3 id="😀-HashCode的作用是什么"><a href="#😀-HashCode的作用是什么" class="headerlink" title="😀 HashCode的作用是什么?"></a>😀 HashCode的作用是什么?</h3><ul>
<li><p>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等， hashCode 是用来在散列存储结构中确定对象的存储地址的;</p>
</li>
<li><p>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同;</p>
</li>
<li>如果对象的 equals 方法被重写，那么对象的 hashCode 也尽量重写，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，否则就会违反上面提到的第 2 点;</li>
<li>两个对象的 hashCode 相同，并不一定表示两个对象就相同，也就是不一定适用于 equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中.</li>
</ul>
<h3 id="😀-为什么要有-hashCode？"><a href="#😀-为什么要有-hashCode？" class="headerlink" title="😀 为什么要有 hashCode？"></a>😀 为什么要有 hashCode？</h3><p>我们以<code>HashSet</code> 如何检查重复为例子来说明为什么要有 <code>hashCode</code>？</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HastSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="😀-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#😀-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="😀 为什么重写 equals() 时必须重写 hashCode() 方法？"></a>😀 为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而 是一种业务上的对象相等。在这种情况下，原生的 equals 方法就不能满足我 们的需求了，所以这个时候我们需要重写 equals 方法，来满足我们的业务系 统上的需求。</p>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h3 id="😀-包装类型的常量池技术了解么？"><a href="#😀-包装类型的常量池技术了解么？" class="headerlink" title="😀 包装类型的常量池技术了解么？"></a>😀 包装类型的常量池技术了解么？</h3><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<h3 id="😀-自动装箱与拆箱了解吗？原理是什么？"><a href="#😀-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="😀 自动装箱与拆箱了解吗？原理是什么？"></a>😀 自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h3 id="😀-面向对象和面向过程的区别"><a href="#😀-面向对象和面向过程的区别" class="headerlink" title="😀 面向对象和面向过程的区别"></a>😀 面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="😀-成员变量与局部变量的区别有哪些？"><a href="#😀-成员变量与局部变量的区别有哪些？" class="headerlink" title="😀 成员变量与局部变量的区别有哪些？"></a>😀 成员变量与局部变量的区别有哪些？</h3><p><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
<p><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h3 id="😀-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#😀-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="😀 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>😀 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p>
<h3 id="😀-字符串常量池的作用了解吗？"><a href="#😀-字符串常量池的作用了解吗？" class="headerlink" title="😀 字符串常量池的作用了解吗？"></a>😀 字符串常量池的作用了解吗？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗专为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
<h3 id="😀-Java-泛型了解么？什么是类型擦除？"><a href="#😀-Java-泛型了解么？什么是类型擦除？" class="headerlink" title="😀 Java 泛型了解么？什么是类型擦除？"></a>😀 Java 泛型了解么？什么是类型擦除？</h3><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。比如我们向一个整型list集合里面添加一个字符，直接调用add方法的话，会报错，但是可以通过反射的方法添加，这就说明在运行期间所有的泛型信息都会被擦掉。</p>
<p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h4 id="泛型的上限和下限？"><a href="#泛型的上限和下限？" class="headerlink" title="泛型的上限和下限？"></a>泛型的上限和下限？</h4><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h3 id="😀-常用的通配符有哪些？"><a href="#😀-常用的通配符有哪些？" class="headerlink" title="😀 常用的通配符有哪些？"></a>😀 常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h3 id="😀-何为反射？"><a href="#😀-何为反射？" class="headerlink" title="😀 何为反射？"></a>😀 何为反射？</h3><p>Java 的<strong>反射机制</strong>是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p>
<p><strong>每个类都有一个Class对象</strong>，每当编译一个新类就产生一个Class对象（更恰当地说，是被保存在一个同名的.class文件中）。比如创建一个Student类，那么，JVM就会创建一个Student对应Class类的Class对象，该Class对象保存了Student类相关的类型信息。<strong>Class类的对象作用</strong>是运行时提供或获得某个对象的类型信息。</p>
<p><strong>反射机制优缺点</strong></p>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>
</ul>
<h4 id="😀-获取Class对象的三种方法"><a href="#😀-获取Class对象的三种方法" class="headerlink" title="😀 获取Class对象的三种方法"></a>😀 获取Class对象的三种方法</h4><p><strong>第一种，使用 Class.forName 静态方法。</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Class <span class="attr">class1</span> = Class.forName(<span class="string">&quot;reflection.TestReflection&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种，使用类的.class 方法</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Class <span class="attr">class2</span> = TestReflection.class<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>第三种，使用实例对象的 getClass() 方法。</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">TestReflection <span class="attr">testReflection</span> = new TestReflection()<span class="comment">;</span></span><br><span class="line">Class <span class="attr">class3</span> = testReflection.getClass()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="😀-如何通过反射创建对象"><a href="#😀-如何通过反射创建对象" class="headerlink" title="😀 如何通过反射创建对象"></a>😀 如何通过反射创建对象</h4><p>通过反射创建类对象主要有两种方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f1b85fc34ce537~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217134322196-20231217153341216.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906191818636-20231217153341423.png" alt="image-20220906191818636"></p>
<h4 id="😀-反射获取类的构造器"><a href="#😀-反射获取类的构造器" class="headerlink" title="😀 反射获取类的构造器"></a>😀 反射获取类的构造器</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f1662225a43b9e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153341589.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906192253508.png" alt="image-20220906192253508"></p>
<h4 id="😀-反射获取类的成员变量"><a href="#😀-反射获取类的成员变量" class="headerlink" title="😀 反射获取类的成员变量"></a>😀 反射获取类的成员变量</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f19b116e71c366~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153341953.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906192603253-20231217153342255.png" alt="image-20220906192603253"></p>
<p>即<code>getField(String name)</code> 根据参数变量名，返回一个具体的具有public属性的成员变量，如果该变量<strong>不是public属性</strong>，则报异常。</p>
<h4 id="😀-反射获取类的方法"><a href="#😀-反射获取类的方法" class="headerlink" title="😀 反射获取类的方法"></a>😀 反射获取类的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f19c250c645069~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153342413.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f19c70f7446654~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="😀-反射的实现原理"><a href="#😀-反射的实现原理" class="headerlink" title="😀 反射的实现原理"></a>😀 反射的实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906195319527.png" alt="image-20220906195319527"></p>
<p><strong>invoke方法执行时序图</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f27996f9e5ed0f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153342987.awebp" alt="img"></p>
<p><strong>我们跟着反射链路去看一下源码，先看Method的invoke方法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906195551641-20231217153343236.png" alt="image-20220906195551641"></p>
<p>由上可知道，Method 的 invoke 方法，其实是返回接口MethodAccessor的invoke方法。MethodAccessor接口有三个实现类，到底调用的是哪个类的 invoke 方法呢？进入acquireMethodAccessor方法，可以看到MethodAccessor由ReflectionFactory 的 newMethodAccessor方法决定。再进ReflectionFactory的newMethodAccessor方法，我们可以看到返回的是DelegatingMethodAccessorImpl对象，也就是说调用的是它的invoke方法。再看DelegatingMethodAccessorImpl的invoke方法，DelegatingMethodAccessorImpl的invoke方法返回的是MethodAccessorImpl的invoke方法，而MethodAccessorImpl的invoke方法，由它的子类NativeMethodAccessorImpl重写，这时候返回的是本地方法invoke0。因此，Method的invoke方法，是由本地方法invoke0决定的，再底层就是c++相关了。</p>
<h3 id="😀-反射应用"><a href="#😀-反射应用" class="headerlink" title="😀 反射应用"></a>😀 反射应用</h3><p>反射是Java框架的灵魂技术，很多框架都使用了反射技术，如spring，Mybatis，Hibernate等。</p>
<h4 id="JDBC-的数据库的连接"><a href="#JDBC-的数据库的连接" class="headerlink" title="JDBC 的数据库的连接"></a>JDBC 的数据库的连接</h4><p>在JDBC连接数据库中，一般包括<strong>加载驱动，获得数据库连接</strong>等步骤。而加载驱动，就是引入相关Jar包后，通过<strong>Class.forName()</strong> 即反射技术，加载数据库的驱动程序。</p>
<h4 id="Spring-框架的使用"><a href="#Spring-框架的使用" class="headerlink" title="Spring 框架的使用"></a>Spring 框架的使用</h4><p>Spring 通过 XML 配置模式装载 Bean，也是反射的一个典型例子。</p>
<p><strong>装载过程：</strong></p>
<ul>
<li>将程序内XML 配置文件加载入内存中</li>
<li>Java类解析xml里面的内容，得到相关字节码信息</li>
<li>使用反射机制，得到Class实例</li>
<li>动态配置实例的属性，使用</li>
</ul>
<p><strong>这样做当然是有好处的：</strong></p>
<p>不用每次都去new实例了，并且可以修改配置文件，比较灵活。</p>
<h3 id="😀-反射存在的问题"><a href="#😀-反射存在的问题" class="headerlink" title="😀 反射存在的问题"></a>😀 反射存在的问题</h3><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>java反射的性能并不好，原因主要是编译器没法对反射相关的代码做优化。</p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>我们知道单例模式的设计过程中，会强调<strong>将构造器设计为私有</strong>，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，<strong>修改访问权限</strong>。所以这样并不一定是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906211523209-20231217153343510.png" alt="image-20220906211523209"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906211542614-20231217153343791.png" alt="image-20220906211542614"></p>
<p>显然，反射不管你是不是私有，一样可以调用。 所以，使用反射通常需要程序的运行没有<strong>安全限制</strong>。如果一个程序对安全性有强制要求，最好不要使用反射啦。</p>
<h3 id="😀-反射中，Class-forName和ClassLoader的区别"><a href="#😀-反射中，Class-forName和ClassLoader的区别" class="headerlink" title="😀 反射中，Class.forName和ClassLoader的区别"></a>😀 反射中，Class.forName和ClassLoader的区别</h3><p>Class.forName 和 ClassLoader 都可以对类进行加载。它们区别在哪里呢? ClassLoader 负责加载 Java 类的字节代码到 Java 虚拟机中。 Class.forName 其实是调用了 ClassLoader，如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220908150722829-20231217153343977.png" alt="image-20220908150722829"></p>
<p>这里面，forName0 的第二个参数为 true，表示对加载的类进行初始化。其 实还可以调用 <code>Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>方法实现一样的功能，它的源码如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220908150908273.png" alt="image-20220908150908273"></p>
<p>所以，Class.forName 和 ClassLoader 的区别，就是在类加载的时候， class.forName 有参数控制是否对类进行初始化。</p>
<h3 id="😀-JDK动态代理和cglib实现的区别"><a href="#😀-JDK动态代理和cglib实现的区别" class="headerlink" title="😀 JDK动态代理和cglib实现的区别"></a>😀 JDK动态代理和cglib实现的区别</h3><ul>
<li>java 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。</li>
<li>cglib 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>JDK 动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>cglib 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成 final</li>
</ul>
<h3 id="😀-Java和C语言的区别是什么"><a href="#😀-Java和C语言的区别是什么" class="headerlink" title="😀 Java和C语言的区别是什么"></a>😀 Java和C语言的区别是什么</h3><p>相同的地方：</p>
<p>　　1、语法类似：</p>
<p>　　由于Java可以算是从C++发展而来的，因此Java与C语言的语法比较类似</p>
<p>　　2、编程的熟练程度就是对语言程序库的掌握程度：</p>
<p>　　从某种程度上来说，编程语言都是由语法和相应的程序库所构成，Java有自身的类库，C语言则有标准库。所谓的编程，就是使用与语法来调用和组合程序库中的函数。</p>
<p>　　不同的地方：</p>
<p>　　1、内存管理</p>
<p>　　在Java中，基本不用考虑内存的问题，如果想用一个对象，new一个就可以，这个过程的背后则是JRE为对象分类的一定内存，当JRE发现你不再使用这个对象的时候，他就会自动回收内存，也就是说你只管借东西，不用管归还，因为与有人当你的跟班，在你不使用的时候就把东西归还了，不过这个过程还是有的，只不过是JRE作的而已。</p>
<p>　　但是C则不同，如果你想用，你可以用malloc之类的方法申请内存，当你使用完了，因为没有跟班的，你需要自己把这块内存归还回去，也就是调用free方法来完成这个任务。由于需要显式的归还内存，因此当一个函数需要将一块内存返回给调用者的时候，问题就比较复杂了，不如面向对象和具有内存回收功能的Java那么直观了。对于这个问题，在C语言中，有几种解决方案：</p>
<p>　　（1） 在调用者中先分配好内存，作为参数传入到被调用的函数中</p>
<p>　　（2） 在被调用的函数中分配，使用完后在调用者中释放</p>
<p>　　（3） 在被调用函数中使用static变量，可以将该变量返回</p>
<p>　　2、面向对象</p>
<p>　　Java的面向对象的特点很明显，而C则是一个地道的结构化语言。 Java中有一个字符串类String， 通过调用 String.length（）就可以知道字符串的长度，但是在C语言中，则需要调用函数strlen（str）来得到字符串（字符数组）的长度。由于C不是面向对象的语言，也就没有this的概念，因此当使用一个与某个“东西”相关的函数时，就需要不厌其烦的将代表这个“东西”的变量作为参数传递进去。</p>
<p>　　3、名称空间</p>
<p>　　Java通过包（package）来实现名称空间，在C语言中，所有的函数都处于同一名称空间，也就是没有名称空间，因此就会很多程序提供的api接口函数都有一个前缀，例如MYSQL的mysql<em>init（）， mysql_real_connect（）， mysql_real_query（）等函数名称前面的mysql</em>。</p>
<h3 id="😀-int类型和long类型相加，结果是什么类型"><a href="#😀-int类型和long类型相加，结果是什么类型" class="headerlink" title="😀 int类型和long类型相加，结果是什么类型"></a>😀 int类型和long类型相加，结果是什么类型</h3><p>结果是long类型，int类型会自动进行类型提升</p>
<p><a href="https://segmentfault.com/a/1190000020905371">https://segmentfault.com/a/1190000020905371</a></p>
<h3 id="😀-int强制转换成byte类型的变量"><a href="#😀-int强制转换成byte类型的变量" class="headerlink" title="😀 int强制转换成byte类型的变量"></a>😀 int强制转换成byte类型的变量</h3><p>我们可以做强制转换，但是在 Java 中，int 是 32 位，byte 是 8 位，如 果强制做转化，int 类型的高 24 位将会被丢弃。</p>
<h3 id="😀-static-关键字有什么作用"><a href="#😀-static-关键字有什么作用" class="headerlink" title="😀 static 关键字有什么作用"></a>😀 static 关键字有什么作用</h3><p>static关键字可以用来修饰代码块表示静态代码块，修饰成员变量表示全局静态成员变量，修饰方法表示静态方法。(注意：不能修饰普通类，除了内部类）</p>
<p>静态是相对于动态的，动态是指Java程序在JVM上运行时，JVM会根据程序的需要动态创建对象并存储对象(分配内存)，对象使命结束后，对象会被垃圾回收器销毁，即内存回收由JVM统一管理并分配给其他新创建的对象；静态是指Java程序还没有运行时，JVM就会为加载的类分配空间存储被static关键字修饰的内容；如静态成员变量，Java类加载到JVM中，JVM会把类以及类的静态成员变量存储在方法区，我们知道方法区是线程共享且很少发生GC的区域，所以被static关键字修饰的内容都是全局共享的，且只会为其分配一次存储空间。</p>
<p>所以当类的某些内容不属于对象，而由对象共享即属于类的时候，就可以考虑是否用static关键字进行修饰。</p>
<p><strong>static关键字的的作用</strong></p>
<p><strong>1 修饰代码块</strong></p>
<p>类中用static关键字修饰的代码块称为静态代码，反之没有用static关键字修饰的代码块称为实例代码块。</p>
<p>实例代码块会随着对象的创建而执行，即每个对象都会有自己的实例代码块，表现出来就是实例代码块的运行结果会影响当前对象的内容，并随着对象的销毁而消失(内存回收)；而静态代码块是当Java类加载到JVM内存中而执行的代码块，由于类的加载在JVM运行期间只会发生一次，所以静态代码块也只会执行一次。</p>
<p>因为静态代码块的主要作用是用来进行一些复杂的初始化工作，所以静态代码块跟随类存储在方法区的表现形式是静态代码块执行的结果存储在方法区，即初始化量存储在方法区并被线程共享。</p>
<p><strong>2 修饰成员变量</strong></p>
<p>类中用static关键字修饰的成员变量称为静态成员变量，因为static不能修饰局部变量(为什么？)，因此静态成员变量也能称为静态变量。静态变量跟代码块类似，在类加载到JVM内存中，JVM会把静态变量放入方法区并分配内存，也由线程共享。访问形式是：类名.静态成员名。</p>
<p>一个类的静态变量和该类的静态代码块的加载顺序。类会优先加载静态变量，然后加载静态代码块，但有多个静态变量和多个代码块时，会按照编写的顺序进行加载。</p>
<p><strong>static关键不能修饰局部变量，包括实例方法和静态方法，不然就会与static关键字的初衷-共享相违背。</strong></p>
<p><strong>3 修饰方法</strong></p>
<p>用static关键字修饰的方法称为静态方法，否则称为实例方法。通过类名.方法名调用，但需要注意静态方法可以直接调用类的静态变量和其他静态方法，不能直接调用成员变量和实例方法(除非通过对象调用)。</p>
<p><strong>注意</strong>：既然类的实例方法需要对象调用才能访问，而静态方法直接通过类名就能访问，那么在不考虑部署服务器的情况下，一个类是如何开始执行的呢？最大的可能就是通过“类名.静态方法”启动Java，而我定义那么多静态方法，JVM又是如何知道主入口呢？</p>
<p>或许，你想到了main方法。</p>
<p>没错，就是main方法被Java规范定义成Java类的主入口。Java类的运行都由main方法开启</p>
<p><strong>static关键字的缺点</strong></p>
<p>封装是Java类的三大特性之一，也是面向对象的主要特性。因为不需要通过对象，而直接通过类就能访问类的属性和方法，这有点破坏类的封装性；所以除了Utils类，代码中应该尽量少用static关键字修饰变量和方法。</p>
<h3 id="😀-Tomcat处理HTTP请求过程分析"><a href="#😀-Tomcat处理HTTP请求过程分析" class="headerlink" title="😀 Tomcat处理HTTP请求过程分析"></a>😀 Tomcat处理HTTP请求过程分析</h3><p>Tomcat是一个web应用服务器，是一个Servlet/Jsp容器，主要负责将客户端请求传递给对应的Servlet，并且将Servlet的响应数据返回给客户端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20181214143933248.jpg" alt=""></p>
<p>Tomcat的心脏是两个核心组件：Connector（连接器）和Container（容器）。其中一个Container可以选择多个Connector。</p>
<p>redirectPort字面意思是重定向端口。当用户用http请求某个资源，而该资源本身又被设置了必须要https方式访问，此时Tomcat会自动重定向到这个redirectPort设置的https端口。</p>
<h4 id="1、Connector组件"><a href="#1、Connector组件" class="headerlink" title="1、Connector组件"></a><strong>1、Connector组件</strong></h4><p>Connector 最重要的功能就是接收连接请求然后分配线程让 Container来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。Connector监听指定端口上请求，当请求到来时创建一个request和response对象交换数据，然后新建一个线程来处理请求并把request和response传递给Engine组件，最后从Engine获取一个响应并返回给客户端。</p>
<p>Connector组件常用属性说明：</p>
<p>（1） address：指定连接器监听的地址，默认为所有地址，即0.0.0.0，可以自己指定地。（2） maxThreads：支持的最大并发连接数，默认为200；</p>
<p>（3） port：监听的端口；</p>
<p>（4） protocol：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3；</p>
<p>（5） redirectPort：如果某连接器支持的协议是HTTP，当接收客户端发来的HTTPS请求时，则转发至此属性定义的端口；</p>
<p>（6） connectionTimeout：等待客户端发送请求的超时时间，单位为毫秒，默认为60000，即1分钟；</p>
<p>（7） enableLookups：是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名；默认为true； 进行反解的，可以设置为false。</p>
<p>（8） acceptCount：设置等待队列的最大长度；通常在tomcat所有处理线程均处于繁忙状态时，新发来的请求将被放置于等待队列中；</p>
<h4 id="2-container组件"><a href="#2-container组件" class="headerlink" title="2.container组件"></a><strong>2.container组件</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20181214144120710.jpg" alt=""></p>
<p>Container是容器的父接口，该容器的设计用的是典型的责任链的设计模式，它由四个自容器组件构成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。通常一个Servlet class对应一个Wrapper，如果有多个Servlet则定义多个Wrapper，如果有多个Wrapper就要定义一个更高的Container，如Context。 Context定义在父容器 Host 中，其中Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。</p>
<p>2.1、Engine<br>Engine是Servlet处理器的一个实例，即servlet引擎，默认为定义在server.xml中的Catalina。Engine需要defaultHost属性来为其定义一个接收所有请求的虚拟主机host组件。</p>
<p>2.2、Host<br>Host是Engine的子容器。一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用、接收并处理请求、保存一个主机应该有的信息。</p>
<p>常用属性说明：</p>
<p>（1）appBase：此Host的webapps目录，项目存放路径，可以使用绝对路径；</p>
<p>（2）autoDeploy：在Tomcat处于运行状态时放置于appBase目录中的应用程序文件是否自动进行deploy；默认为true；</p>
<p>（3）unpackWars：在启用此webapps时是否对WAR格式的归档文件先进行展开；默认为true；</p>
<p>2.3、Context<br>Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的</p>
<p>常用属性定义：</p>
<p>（1） docBase：相应的Web应用程序的存放位置；也可以使用相对路径，起始路径为此Context所属Host中appBase定义的路径；切记，docBase的路径名不能与相应的Host中appBase中定义的路径名有包含关系，比如，如果appBase为deploy，而docBase绝不能为deploy-bbs类的名字；</p>
<p>（2）path：相对于Web服务器根路径而言的URI；如果为空“”，则表示为此webapp的根路径；如果context定义在一个单独的xml文件中，此属性不需要定义，有可能是别名；</p>
<p>（3） reloadable：是否允许重新加载此context相关的Web应用程序的类；默认为false；</p>
<p>2.4、Wrapper<br>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>2.5、Realm<br>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>2.6、Value<br>Valve类似于过滤器，它可以工作于Engine和Host/Context之间、Host和Context之间以及Context和Web应用程序的某资源之间。一个容器内可以建立多个Valve，而且Valve定义的次序也决定了它们生效的次序。</p>
<h4 id="😀-Tomcat处理一个HTTP请求的过程"><a href="#😀-Tomcat处理一个HTTP请求的过程" class="headerlink" title="😀 Tomcat处理一个HTTP请求的过程"></a>😀 Tomcat处理一个HTTP请求的过程</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20181214144140580-20231217153344781.jpg" alt=""></p>
<p>1.用户在浏览器中输入网址localhost:8080/test/index.jsp，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得；</p>
<p>2.Connector把该请求交给它所在的Service的Engine（Container）来处理，并等待Engine的回应；</p>
<p>3.Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；</p>
<p>4.Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）。名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）；</p>
<p>5.path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL Pattern为*.jsp的Servlet，对应于JspServlet类；</p>
<p>6.构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost(),执行业务逻辑、数据存储等；</p>
<p>7.Context把执行完之后的HttpServletResponse对象返回给Host；</p>
<p>8.Host把HttpServletResponse对象返回给Engine；</p>
<p>9.Engine把HttpServletResponse对象返回Connector；</p>
<p>10.Connector把HttpServletResponse对象返回给客户Browser。</p>
<h3 id="😀-a-a-b-与-a-b-的区别"><a href="#😀-a-a-b-与-a-b-的区别" class="headerlink" title="😀 a = a + b 与 a += b 的区别"></a>😀 a = a + b 与 a += b 的区别</h3><p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)</p>
<h3 id="😀-3-0-1-0-3-将会返回什么-true-还是-false"><a href="#😀-3-0-1-0-3-将会返回什么-true-还是-false" class="headerlink" title="😀 3*0.1 == 0.3 将会返回什么? true 还是 false?"></a>😀 3*0.1 == 0.3 将会返回什么? true 还是 false?</h3><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h3 id="😀-this和super关键字的作用"><a href="#😀-this和super关键字的作用" class="headerlink" title="😀 this和super关键字的作用"></a>😀 this和super关键字的作用</h3><p><strong>this:</strong></p>
<ul>
<li>对象内部指代自身的引用</li>
<li>解决成员变量和局部变量同名问题</li>
<li>可以调用成员变量，不能调用局部变量</li>
<li>可以调用成员方法</li>
<li>在普通方法中可以省略 this</li>
<li>在静态方法当中不允许出现 this 关键字</li>
</ul>
<p><strong>super:</strong></p>
<ul>
<li>调用父类的成员或者方法 </li>
<li>调用父类的构造函数</li>
</ul>
<h3 id="😀-this-amp-super-在构造方法中的区别？"><a href="#😀-this-amp-super-在构造方法中的区别？" class="headerlink" title="😀 this() &amp; super()在构造方法中的区别？"></a>😀 this() &amp; super()在构造方法中的区别？</h3><ul>
<li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li>
<li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li>
<li>尽管可以用this调用一个构造器, 却不能调用2个</li>
<li>this和super不能出现在同一个构造器中, 否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ul>
<h3 id="😀-Java移位运算符？"><a href="#😀-Java移位运算符？" class="headerlink" title="😀 Java移位运算符？"></a>😀 Java移位运算符？</h3><p>java中有三种移位运算符</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li>
</ul>
<h3 id="😀-Comparator-与-Comparable-有什么区别"><a href="#😀-Comparator-与-Comparable-有什么区别" class="headerlink" title="😀 Comparator 与 Comparable 有什么区别?"></a>😀 Comparator 与 Comparable 有什么区别?</h3><ul>
<li>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</li>
<li>Comparator 位于包 java.util 下，而 Comparable 位于包 java.lang 下。</li>
<li>Comparable 是一个对象本身就已经支持自比较所需要实现的接口(如String、Integer 自己就可以完成比较大小操作，已经实现了 Comparable 接 口) 自定义的类要在加入 list 容器中后能够排序，可以实现 Comparable 接 口，在用 Collections 类的 sort 方法排序时，如果不指定 Comparator，那么 就以自然顺序排序， 这里的自然顺序就是实现 Comparable 接口设定的排序方式。</li>
<li>而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。</li>
<li>可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。 用 Comparator 是策略模式(strategy design pattern)，就是不改变对象自身，而用一个策略对象(strategy object)来改变它的行为。 比如:你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类(实际上你也不能这么做)去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</li>
</ul>
<h3 id="😀-类的实例化顺序"><a href="#😀-类的实例化顺序" class="headerlink" title="😀 类的实例化顺序"></a>😀 类的实例化顺序</h3><p>父类静态代码块/静态域-&gt;子类静态代码块/静态域 - &gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类非静态代码块 -&gt; 子类构造器</p>
<h3 id="😀-Java创建对象有几种方式"><a href="#😀-Java创建对象有几种方式" class="headerlink" title="😀 Java创建对象有几种方式"></a>😀 Java创建对象有几种方式</h3><p>Java 创建对象有 5 种方式</p>
<ul>
<li>用 new 语句创建对象。</li>
<li>使用反射，使用 Class.newInstance()创建对象/调用类对象的构造方法——Constructor</li>
<li>调用对象的 clone()方法。</li>
<li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject()方法.</li>
<li>使用 Unsafe</li>
</ul>
<h3 id="😀-守护线程是什么？如何实现守护线程"><a href="#😀-守护线程是什么？如何实现守护线程" class="headerlink" title="😀 守护线程是什么？如何实现守护线程"></a>😀 守护线程是什么？如何实现守护线程</h3><ul>
<li>守护线程是运行在后台的一种特殊进程。</li>
<li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li>
<li>在 Java 中垃圾回收线程就是特殊的守护线程。</li>
</ul>
<h3 id="😀-for-each-与常规-for-循环的效率对比"><a href="#😀-for-each-与常规-for-循环的效率对比" class="headerlink" title="😀 for-each 与常规 for 循环的效率对比"></a>😀 for-each 与常规 for 循环的效率对比</h3><p>关于这个问题,《Effective Java》给我们做的解答:</p>
<blockquote>
<p>for-each 能够让代码更加清晰，并且减少了出错的机会。 下面的惯用代码适用于集合与数组类型:</p>
<p>for (Element e : elements) { doSomething(e);</p>
<p>}</p>
<p>使用 for-each 循环与常规的 for 循环相比，并不存在性能损失，即使对数组进 行迭代也是如此。实际上，在有些场合下它还能带来微小的性能提升，因为它 只计算一次数组索引的上限。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用命令</title>
    <url>/posts/commandsForRedis.html</url>
    <content><![CDATA[<p>Redis 所有的 key（键）都是字符串。在谈基础数据结构时，我们讨论的是存储值的数据类型，主要包括常见的 5 种数据类型，分别是：String、List、Set、Zset、Hash。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Redis 是一个 key-value 的数据库，key 是一般的 String，不过 value 却是多种多样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1658728198413-20231217153652947.png" alt="1658728198413"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>String字符串</td>
<td>可以是字符、整数或浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td>List列表</td>
<td>一个链表，链表上的每个节点都包含一个字符串</td>
<td>对链表的两端进行 push 和 pop 操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td>Set集合</td>
<td>包含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有：看是否存在添加、获取、删除；还包含计算交集、并集、差集等；</td>
</tr>
<tr>
<td>Hash散列</td>
<td>包含键值对的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td>Zset 有序集合</td>
<td>和散列一样，用于存储键值对</td>
<td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素；</td>
</tr>
</tbody>
</table>
</div>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul>
<li><p>KEYS pattern：查看符合模版的所有 keys, 不建议在生产坏境下使用，因为当Redis中的数据量很大时，执行模糊查询会阻塞其他请求。</p>
</li>
<li><p>DEL key：删除一个指定的 key</p>
</li>
<li><p>EXISTS key：判断 key 是否存在</p>
</li>
<li><p>EXPIRE key seconds：给一个 key 设置过期时间，单位是秒，有效期到期时该key会被自动删除</p>
</li>
<li><p>TTL key：查看指定 key 的剩余有效时间 。-1 表示当前 key 没有设置有效时间 ，-2 表示当前 key 不存在</p>
</li>
<li><p>PERSIST key：持久化指定 key</p>
</li>
<li><p>TYPE key：查看指定 key 的类型</p>
</li>
<li><p>MOVE key num：移动指定 key 到指定数据库</p>
</li>
<li><p>RANDOMKEY：随即返回库中的一个 key</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; select <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists <span class="title function_">k2</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire k1 <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; persist <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">k1</span></span><br><span class="line"><span class="params">(integer)</span> -<span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type k1</span><br><span class="line">string</span><br></pre></td></tr></table></figure>
<h3 id="String-字符串命令"><a href="#String-字符串命令" class="headerlink" title="String 字符串命令"></a>String 字符串命令</h3><blockquote>
<p>String类型是Redis基本类型，一个键最大能存储512MB且是二进制安全的。意思是 redis 的 String 类型可以存储任何数据，如数字，字符串，jpg图片或者序列化的对象。</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>redis中的String是动态字符串，内部结构类似ArrayList。采用预分配冗余空间的方式减少内存的频繁分配。</p>
<blockquote>
<p>内部为字符串分配的实际空间一般高于字符串长度，当字符串长度<1MB时，扩容方式是加倍 也就是原来的两倍。当字符串长度>1MB时，一次扩容1MB，直到最大512MB.</p>
</blockquote>
<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增.自减操作</li>
<li>float：浮点类型，可以做自增.自减操作</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1652890121291.png" alt="1652890121291"></p>
<h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p>
<ul>
<li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>MSET和MGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>INCR和INCRBY和DECY</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>SETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SETEX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setex name <span class="number">10</span> jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl <span class="title function_">name</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="Redis命令-Key的层级结构"><a href="#Redis命令-Key的层级结构" class="headerlink" title="Redis命令-Key的层级结构"></a>Redis命令-Key的层级结构</h4><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1652941631682.png" alt="1652941631682"></p>
<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>heima:user:1</td>
<td>{“id”:1, “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1, “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody>
</table>
</div>
<p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1652941883537.png" alt="1652941883537"></p>
<h3 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1652941995945.png" alt="1652941995945"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1652942027719.png" alt="1652942027719"></p>
<p><strong>Hash类型的常见命令</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li>HKEYS：获取一个hash类型的key中的所有的field</li>
<li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li>
</ul>
<ul>
<li>HSET和HGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HMSET和HMGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HGETALL</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HKEYS和HVALS</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HINCRBY</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>HSETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p><strong>List的常见命令有：</strong></p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1652943604992.png" alt="1652943604992"></p>
<ul>
<li>LPUSH和RPUSH</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LPOP和RPOP</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LRANGE</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集.并集.差集等功能</li>
</ul>
<p><strong>Set类型的常见命令</strong></p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
<li>SDIFF key1 key2 … ：求key1与key2的差集</li>
<li>SUNION key1 key2 ..：求key1和key2的并集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221114142002049.png" alt="image-20221114142002049"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221114142018642.png" alt="image-20221114142018642"></p>
<p><strong>具体命令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>案例</strong></p>
<ul>
<li>将下列数据用Redis的Set集合来存储：</li>
<li>张三的好友有：李四.王五.赵六</li>
<li>李四的好友有：王五.麻子.二狗</li>
<li>利用Set的命令实现下列功能：</li>
<li>计算张三的好友有几人</li>
<li>计算张三和李四有哪些共同好友</li>
<li>查询哪些人是张三的好友却不是李四的好友</li>
<li>查询张三和李四的好友总共有哪些人</li>
<li>判断李四是否是张三的好友</li>
<li>判断张三是否是李四的好友</li>
<li>将李四从张三的好友列表中移除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li>
<li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro认证流程源码分析</title>
    <url>/posts/29996.html</url>
    <content><![CDATA[<h2 id="创建认证测试类"><a href="#创建认证测试类" class="headerlink" title="创建认证测试类"></a>创建认证测试类</h2><span id="more"></span>
<p>创建<code>TestAuthenticator</code>类,代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAuthenticator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建安全管理器对象</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.给安全管理器设置realm</span></span><br><span class="line">        securityManager.setRealm(<span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.SecurityUtils 给全局安全工具类设置安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关键对象 subject 主体</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建令牌</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;heling&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            subject.login(token); <span class="comment">//用户认证</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：用户名不存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shiro.ini</code>内容为：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">heling</span>=<span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>运行测试结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">认证状态：false</span><br><span class="line">认证状态：true</span><br></pre></td></tr></table></figure>
<p>以上过程是shiro中最简单的一个认证，其中的权限管理数据是通过<code>IniRealm</code>的形式去读取配置文件<code>shiro.ini</code>来加载数据，但是以后的权限管理数据肯定都是来源于数据库的，所以我们要把数据更改到数据库。<br>Shiro从<code>Realm</code>获取安全数据 (如用户,角色，权限)，就是说<code>SecurityManager</code>要验证用户身份，那么它需要从<code>Realm</code>获取相应的用户进行比较，来确定用户的身份是否合法;也需要从<code>Realm</code>得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把<code>Realm</code>看<code>DataSource</code>;<code>Realm</code>可以决定我们的权限管理数据是来源于ini配置文件还是数据库，也就是数据的调配是由<code>Realm</code>来执行的，为了搞清楚<code>Realm</code>的调配流程，我们简单看一下认证的源码。</p>
<h2 id="认证源码分析"><a href="#认证源码分析" class="headerlink" title="认证源码分析"></a>认证源码分析</h2><h3 id="用户名认证"><a href="#用户名认证" class="headerlink" title="用户名认证"></a>用户名认证</h3><p>首先在<code>subject.login(token);</code>处打上断点，然后Debug运行。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/abb91f97c04344d185c28329c0b6e98b.png" alt="在这里插入图片描述"><br>程序停在断点之后，我们进行login方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/aa6db40626e548e7b84b269c7d89edb5.png" alt="在这里插入图片描述"><br>可以看到虽然是subject调用的login，但是真正去执行的是<code>DelegatingSubject</code>中的login，方法刚开始调用了一个clear方法，然后由安全管理器进行认证，内部的<code>this</code>就是<code>DelegatingSubject</code>类，token就是我们传过来的由身份信息和凭证信息组成的令牌。然后再进入<code>securityManager</code>的<code>login</code>方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/670c5123f30d46bbafbb6ff5e16041bf.png" alt="在这里插入图片描述">我们发现实际上真正去执行的是<code>DefaultSecurityManager</code>中的<code>login</code>方法，方法刚开始就执行一个<code>authenticate</code>方法，传入token，然后继续进入这个方法内部。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/ba35e85f6ad14c9fa897ce20e91398e3.png" alt="在这里插入图片描述"><br>继续调用<code>AuthenticatingSecurityManager</code>类中的<code>authenticate</code>方法，在这个方法中又调用了当前类中的<code>authenticator</code>对象的<code>authenticate</code>方法，继续进入这个方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/9402e1a1f8034893a9e8c5fd6a1bc5e8.png" alt="在这里插入图片描述"><br>发现调用了<code>AbstractAuthenticator</code>中的<code>authenticate</code>方法，在这个方法中由调用了<code>doAuthenticate</code>方法，继续进入<code>doAuthenticate</code>。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/f6ad84a63576444f9d8985ddb898fe17.png" alt="在这里插入图片描述"><br>来到了<code>ModularRealmAuthenticator</code>类中的<code>doAuthenticate</code>方法，方法开始时有一个断言询问是否配置Realm，然后<code>getRealms</code>方法拿到了所有的域，我们只有一个域，所以<code>realms.size() == 1</code>，进入<code>doSingleRealmAuthentication</code>方法。然后进入<code>doSingleRealmAuthentication</code>方法查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/96aad19cbd0546c78be891e7f315ccee.png" alt="在这里插入图片描述"><br><code>doSingleRealmAuthentication</code>方法刚开始询问realm是否支持token，realm肯定支持，所以realm调用<code>getAuthenticationInfo</code>方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/978beb8dbea941a2b5ebdb3d3fca5361.png" alt="在这里插入图片描述"><br>可以发现它是从缓存中拿取认证信息，因为程序第一次运行是没有缓存的，所以这次肯定拿不到信息。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/28c7b736e9c94d62b07ac7f62fc0125f.png" alt="在这里插入图片描述"><br>继续调用<code>doGetAuthenticationInfo</code>方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/685d1c660c3043a28430df813f7cb092.png" alt="在这里插入图片描述"><br>这里可以看到<code>doGetAuthenticationInfo</code>方法将token取出来，然后强转成UsernamePasswordToken，然后通过<code>upToken.getUsername()</code>获得用户名，最后使用<code>getUser</code>方法拿到用户。我们继续进入<code>getUsername</code>方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1cdc7bffae5a4828a4973396fd8c1cbf.png" alt="在这里插入图片描述"><br>可以看到已经拿到用户名<code>heling</code>。然后下一步回去。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/64f805fe727b41d5bf3f4c1342d0cfe1.png" alt="在这里插入图片描述"><br>再进入<code>getUser</code>方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/b699614a96b64ce48aaef3c747fccbc6.png" alt="在这里插入图片描述">username被传进来了，往下走，发现<code>this.users</code>的size=1，因为我们的配置文件<code>shiro.ini</code>中只有一个用户。然后这里根据用户名拿到用户，返回<code>SimpleAccount</code>，继续下一步。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/b94005b97f1842a1b7586e00722b5caa.png" alt="在这里插入图片描述"><br>这时已经拿到account，所以account肯定不为空，而且account也没有上锁，也没有做过验证密码是否过期的处理，所以最终在<code>SimpleAccountRealm</code>类中通过<code>doGetAuthenticationInfo</code>方法完成了一个用户名的认证。</p>
<h3 id="密码认证"><a href="#密码认证" class="headerlink" title="密码认证"></a>密码认证</h3><p>在<code>return acount</code>之后继续下一步，回到了<code>AuthenticatingRealm</code>类，<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/be85d7e965ec4682a6962d7b68bf3397.png" alt="在这里插入图片描述">这里拿到的info肯定不为空了，继续下一步，因为<code>token != null &amp;&amp; info != null</code>，所以增加了缓存（<code>this.cacheAuthenticationInfoIfPossible(token, info);</code>）。继续往下走。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/7a552b8a204045b6b64fb7eb59e6a684.png" alt="在这里插入图片描述"><br>如果info不为空的话，就进入一个断言，判断token中的密码和info中的密码是否相等。进入<code>assertCredentialsMatch</code>方法查看。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1e0e04f22c8c46f5941a22a359aa21a1.png" alt="在这里插入图片描述"><br>进入方法，拿到了一个密码匹配器，如果密码匹配器不为空的话，就调用<code>doCredentialsMatch</code>方法对token中的密码和info中的密码进行比对，如果密码不正确就抛出<code>IncorrectCredentialsException</code>异常。所以最终密码的校验是在<code>AuthenticatingRealm</code>类中的<code>assertCredentialsMatch</code>方法中完成的。<br>如果以后我们要把数据换成数据库的实现，那么我们只需把<code>SimpleAccountRealm</code>类中<code>doGetAuthenticationInfo</code>方法的实现换成读取数据库，因为<code>SimpleAccountRealm</code>继承自<code>AuthorizingRealm</code>类，所以如果我们要自定义Realm，我们也应该自己写一个类去继承<code>AuthorizingRealm</code>并重写<code>doGetAuthenticationInfo</code>方法。密码校验是不需要我们自己处理的，因为我们在用户名认证之后返回info信息，<code>AuthenticatingRealm</code>类中的<code>assertCredentialsMatch</code>方法会自动帮我们校验。</p>
]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 必知必会</title>
    <url>/posts/5427.html</url>
    <content><![CDATA[<h2 id="一、是什么？能做什么？"><a href="#一、是什么？能做什么？" class="headerlink" title="一、是什么？能做什么？"></a>一、是什么？能做什么？</h2><ul>
<li><p>是一个快速开发的脚手架</p>
</li>
<li><p>作用：快速创建独立的、生产级的基于Spring的应用程序</p>
<p>SpringBoot是基于Spring的用来提升效率的框架，可以让编码更加简单，配置管理也更加简单，部署也更方</p>
<span id="more"></span></li>
<li><p>特性</p>
<ul>
<li>无需部署WAR文件</li>
<li>提供starter简化配置</li>
<li>尽可能自动配置Spring以及第三方库</li>
<li>提供“生产就绪”功能，例如指标、健康检查、外部配置等</li>
<li>无代码生成&amp;无XML</li>
</ul>
</li>
</ul>
<h2 id="二、编写第一个SpringBoot应用"><a href="#二、编写第一个SpringBoot应用" class="headerlink" title="二、编写第一个SpringBoot应用"></a>二、编写第一个SpringBoot应用</h2><ul>
<li>需求<ul>
<li>整合Spring MVC</li>
<li>/test路径（端点）</li>
</ul>
</li>
<li>使用Spring Initializr快速创建Spring Boot应用</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929122815096.png" alt="image-20210929122815096"  /></p>
<p>左侧选择Spring Initializr，SDK选择JDK1.8，Custom使用<a href="http://start.aliyun.com">http://start.aliyun.com</a>可以加快下载速度，然后点击Next创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929131811905.png" alt="image-20210929131811905"></p>
<p>填写Group和项目唯一标识Artifact，打包方式选择Jar，这也是Sprint官方推荐的打包方式，Java版本选择8，点击Next。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929132216076.png" alt="image-20210929132216076"></p>
<p>选择最新版本的Spring Boot，添加Spring Web来整合Spring MVC。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929132409252.png" alt="image-20210929132409252"></p>
<p>填写项目名称以及项目地址，完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929132612574.png" alt="image-20210929132612574"></p>
<p>生成的项目其实已经整合了MVC。</p>
<p>下面写Test端点，在cn.cstube包下创建类TestController。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cstube;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> heling</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目启动之前，使用<code>mvn clean install</code>确保能够构建成功再去启动，主要是为了防止有Jar包没有下载完整，导致启动失败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929140808446.png" alt="image-20210929140808446"></p>
<p>最后启动SpringBootDemoApplication类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929141034166.png" alt="image-20210929141034166"></p>
<p>在浏览器访问<a href="localhost:8080/test">localhost:8080/test</a>，可以看到可以返回test。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929141226978.png" alt="image-20210929141226978"></p>
<p>以上是在Idea中的启动，在实际的项目部署中我们需要进到<code>target</code>目录，找到可以执行的jar包，然后执行<code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar</code>，同样在浏览器中也可以返回正常结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929141503364.png" alt="image-20210929141503364"></p>
<h2 id="三、Spring-Boot的应用组成分析"><a href="#三、Spring-Boot的应用组成分析" class="headerlink" title="三、Spring Boot的应用组成分析"></a>三、Spring Boot的应用组成分析</h2><ul>
<li>依赖：<code>pom.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springmvc整合--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单元测试支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动类：注解</li>
</ul>
<p><code>@SpringBootApplication</code>代表这个类为启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line">    <span class="comment">//启动类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置：application.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">spring-boot-demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure>
<ul>
<li>static目录：静态文件</li>
</ul>
<p>主要用于存放静态文件，比如html，css文件。</p>
<ul>
<li>templates目录：模板文件</li>
</ul>
<p>用于存放模板文件，因为Spring MVC支持多种视图格式，比如jsp,freemarker等模板引擎，但是现在的应用大多基于前后端分离开发，以后基本用不到模板引擎。</p>
<h2 id="四、Spring-Boot开发三板斧"><a href="#四、Spring-Boot开发三板斧" class="headerlink" title="四、Spring Boot开发三板斧"></a>四、Spring Boot开发三板斧</h2><ul>
<li>加依赖</li>
</ul>
<p>如果你想在Spring Boot整合xxx，那么只需要在<code>pom.xml</code>中上xxx的依赖即可。例如整合JPA和Mybatis。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        boot官方提供：spring-boot-starter-xxx--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        mybatis 非官方提供starter:xxx-spring-boot-starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>写注解</li>
</ul>
<p>在启动类中会添加各种各样的注解</p>
<ul>
<li>写配置</li>
</ul>
<p>在<code>application.properties</code>中添加各种配置</p>
<h2 id="五、Spring-Boot-Actuator"><a href="#五、Spring-Boot-Actuator" class="headerlink" title="五、Spring Boot Actuator"></a>五、Spring Boot Actuator</h2><ul>
<li>是什么？</li>
</ul>
<p>Spring Boot Actuator是Spring Boot中非常重要的组件，它为我们的应用提供了强大的监控能力。如今的应用越来越复杂，我们需要一些监控工具来帮助我们记录问题。</p>
<ul>
<li>如何整合?</li>
</ul>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动应用，可以看到actuator暴露了两个端点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929145625923.png" alt="image-20210929145625923"></p>
<p>打开<a href="localhost:8080/actuator">localhost:8080/actuator</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929145852358.png" alt="image-20210929145852358" style="zoom:50%;" /></p>
<p>点击<a href="http://localhost:8080/actuator/health">http://localhost:8080/actuator/health</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929150133024.png" alt="image-20210929150133024" style="zoom:50%;" /></p>
<p>health端点是非常重要的端点，以后会经常用到。作用是健康检查，也就是检查应用的资源。我们需要在配置文件中添加配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">spring-boot-demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management.endpoint.health.show-details</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>启动应用。再次打开<a href="http://localhost:8080/actuator/health">http://localhost:8080/actuator/health</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929150622468.png" alt="image-20210929150622468" style="zoom:50%;" /></p>
<p>可以看到这里检查了磁盘资源，磁盘大小为325G，剩余空间为63.3G，如果剩余空间低于threshold，那么这个磁盘就是不健康的。</p>
<p>status取值：</p>
<ul>
<li>UP：正常</li>
<li>DOWN: 遇到了问题，不正常</li>
<li>OUT_OF_SERVICE: 资源未在使用，或者不该去使用</li>
<li>UNKNOWN: 不知道</li>
</ul>
<p><a href="http://localhost:8080/actuator/info">http://localhost:8080/actuator/info</a>是一个描述端点，主要用来描述应用信息。例如在配置文件中添加配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述应用</span></span><br><span class="line"><span class="attr">info.app-name</span>=<span class="string">spring-boot-demo</span></span><br><span class="line"><span class="attr">info.author</span>=<span class="string">heling</span></span><br><span class="line"><span class="attr">info.email</span>=<span class="string">xxx@email</span></span><br></pre></td></tr></table></figure>
<p>启动应用，然后访问info端点</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929151753941.png" alt="image-20210929151753941" style="zoom:50%;" /></p>
<p>下面是Spring Boot Actuator常见的监控端点</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929151934733.png" alt="image-20210929151934733"></p>
<p>除了health和info，其他的端点都是隐藏的。只需要在配置文件中添加配置即可激活所有端点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 激活所有的actuator端点</span></span><br><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure>
<p>重启应用，刷新<a href="localhost:8080/actuator">localhost:8080/actuator</a>就会发现已激活所有端点，如果只想激活个别端点，那么就更改一下配置，比如只激活metrics和health端点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">metrics,health</span></span><br></pre></td></tr></table></figure>
<h2 id="六、Spring-Boot配置管理"><a href="#六、Spring-Boot配置管理" class="headerlink" title="六、Spring Boot配置管理"></a>六、Spring Boot配置管理</h2><ul>
<li>支持的配置格式</li>
</ul>
<p>Spring Boot除了支持<code>.properties</code>类型的配置文件外，还支持<code>.yml</code>或者<code>.yaml</code>的文件。</p>
<p><strong>Yet Anther Markup Language（.yml/.yaml）</strong>是JSON子集，格式如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app-name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">heling</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">xxx@email</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">metrics,health</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-demo</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>:</code>后的空格一定不能缺少，另外每一行前有严格的缩进。</p>
<p>在实际项目中更推荐使用<code>.yml</code>格式的配置文件，因为其可读性更强，在业界更受欢迎，而且它可以保证配置读取的顺序。</p>
<ul>
<li><p>配置管理常用方式</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>环境变量</p>
<p>例如在将<code>always</code>改为<code>$&#123;SOME_ENV&#125;</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app-name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">heling</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">xxx@email</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">$&#123;SOME_ENV&#125;</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">metrics,health</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-demo</span></span><br></pre></td></tr></table></figure>
<p>然后在应用启动的时候指定环境变量</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929154407814.png" alt="image-20210929154407814"></p>
<p>启动应用发现依然可以展示详情，但是在重新构建应用的时候，会因为单元测试报错，因为单元测试拿不到idea中的配置，这时候可以删除测试类或者在使用<code>mvn clean install -DskipTests</code>跳过单元测试。构建应用之后，使用<code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --SOME_ENV=always</code>启动应用。</p>
</li>
<li><p>外部配置文件</p>
<p>将Jar包和配置文件放在同一目录下，然后使用命令启动应用，Spring Boot会优先读取配置文件中的配置，也就是说外部配置文件的优先级比Jar包的配置文件更高。</p>
</li>
<li><p>命令行参数</p>
<p>比如我希望应用的Tomcat运行端口为8081，但我又不想写在配置文件中，只需要在运行配置里填写<code>--server.port=8081</code>就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929155914558.png" alt="image-20210929155914558"></p>
<p>如果是使用命令的方式启动应用的话，使用<code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --    server.port=8081</code>启动即可。</p>
</li>
</ul>
</li>
</ul>
<h2 id="七、Profile"><a href="#七、Profile" class="headerlink" title="七、Profile"></a>七、Profile</h2><ul>
<li>如何实现不同环境不同配置</li>
</ul>
<p>在实际项目中我们往往需要在不同的环境使用不同的配置，例如开发环境的Tomcat不需要性能调优，但是生产环境的Tomcat往往需要设置一些性能调优参数，比如最大连接数，最大限制数等，这个时候就可以使用Profile。</p>
<ul>
<li>怎么使用</li>
</ul>
<p>如果应用是<code>yml</code>格式配置的，那么在配置文件中使用连字符<code>---</code>将配置文件分成若干段，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有环境公用的配置属性</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app-name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">heling</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">xxx@email</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">$&#123;SOME_ENV&#125;</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">metrics,health</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-demo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># profile=y的专用属性，也就是某个环境下的专用属性</span></span><br><span class="line"><span class="comment"># 生产环境</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>如果应用以<code>dev</code>启动的话就会使用1,2两段，如果以<code>prod</code>启动的话，就会使用1,3两段。例如使用<code>prod</code>启动</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929161705714.png" alt="image-20210929161705714"></p>
<p>如果想在配置文件中指定启动环境，则添加配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20210929162306832.png" alt="image-20210929162306832" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的Next主题实现数学公式渲染</title>
    <url>/posts/54574.html</url>
    <content><![CDATA[<p>在做密码学研究时，经常会使用数学公式进行一系列推导计算，而hexo博客默认使用 hexo-renderer-marked 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线<code>_</code>代表斜体，会被渲染引擎处理为<code>&lt;em&gt;</code>标签。<br><span id="more"></span><br>因为类 Latex 格式书写的数学公式下划线<code>_</code>表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。类似的语义冲突的符号还包括<code>*</code>,<code>&#123;</code>, <code>&#125;</code>, <code>\\</code>等。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。如果你是Windows系统，直接使用Git Bash的命令行在Hexo根目录下使用命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><br>然后，更换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为 hexo-renderer-kramed 引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，做相应的修改：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  // 第2行修改</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  ...</span><br><span class="line">  // 第20行修改</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="在-Next-主题中开启-MathJax-开关"><a href="#在-Next-主题中开启-MathJax-开关" class="headerlink" title="在 Next 主题中开启 MathJax 开关"></a>在 Next 主题中开启 MathJax 开关</h3><p>找到根目录下的/themes/next/_config.yml文件，按下Ctrl+F，在弹出的搜索框中输入mathjax查找匹配项，然后你找到了这样几行字,把 math 默认的 false 修改为true<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Math Formulas Render Support</span><br><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: true</span><br></pre></td></tr></table></figure><br>在需要使用数学公式的文章的Front-matter里打开mathjax开关，考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Python实现RSA算法</span><br><span class="line">categories: 密码学</span><br><span class="line">tags: RSA</span><br><span class="line">abbrlink: 49034</span><br><span class="line">mathjax: true</span><br><span class="line">date: 2020-08-02 09:16:24</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>最后一键三连<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><br>即可生效。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo的Next主题首页文章添加阴影</title>
    <url>/posts/64817.html</url>
    <content><![CDATA[<p>在next主题文件下找到\next\source\css_common\components\post的post.styl文件<br><span id="more"></span><br>在.post_block位置,更改如下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">    .post-block &#123;</span><br><span class="line">     opacity: 0;</span><br><span class="line">     margin-top: 60px;</span><br><span class="line">     margin-bottom: 60px;</span><br><span class="line">     padding: 25px;</span><br><span class="line">     -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">     -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">    &#125;</span><br><span class="line">    .pagination, .comments &#123;</span><br><span class="line">      opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后执行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><br>即可生效</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/42877.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>前提：有已排序数组 A（假设已经做好）</li>
<li>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</li>
<li>获取中间索引 M = Floor((L+R) /2)</li>
</ol>
<span id="more"></span>
<ol>
<li>中间索引的值  A[M] 与待搜索的值 T 进行比较</li>
</ol>
<p>​         ① A[M] == T 表示找到，返回中间索引</p>
<p>​         ② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p>
<p>​         ③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p>
<ol>
<li>当 L &gt; R 时，表示没有找到，应结束循环</li>
</ol>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决整数溢出问题</strong></p>
<p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>还有一种是移位，右移1位，相当<code>l + r</code> 的值除以2取整，且效率相比除法更高：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>其它考法</strong></p>
<ol>
<li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p>
</li>
<li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p>
</li>
<li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p>
</li>
</ol>
<p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20211103205108420.png" alt="image-20211103205108420"></p>
<p>其中 n 为查找次数，N 为元素个数</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/posts/21238.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<span id="more"></span>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li>
<li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li>
</ul>
<p><strong>进一步优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_v2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>刷新JWT令牌应该如何设计</title>
    <url>/posts/663.html</url>
    <content><![CDATA[<h3 id="为什么要刷新Token的过期时间？"><a href="#为什么要刷新Token的过期时间？" class="headerlink" title="为什么要刷新Token的过期时间？"></a>为什么要刷新Token的过期时间？</h3><p>我们在定义JwtUtil工具类的时候，生成的<code>Token</code>都有过期时间。那么问题来了，假设<code>Token</code>过期时间为15天，用户在第14天的时候，还可以免登录正常访问系统。但是到了第15天，用户的Token过期，于是用户需要重新登录系统。</p>
<span id="more"></span>
<p><code>HttpSession</code>的过期时间比较优雅，默认为15分钟。如果用户连续使用系统，只要间隔时间不超过15分钟，系统就不会销毁<code>HttpSession</code>对象。JWT的令牌过期时间能不能做成<code>HttpSession</code>那样超时时间，只要用户间隔操作时间不超过15天，系统就不需要用户重新登录系统。实现这种效果的方案有两种：<code>双Token</code>和<code>Token缓存</code>，这里重点讲一下<code>Token</code>缓存方案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/604388a80995d6ac22960228-20231217152122624.jpg" alt="img"></p>
<p>Token缓存方案是把<code>Token</code>缓存到Redis，然后设置Redis里面缓存的<code>Token</code>过期时间为正常<code>Token</code>的1倍,然后根据情况刷新<code>Token</code>的过期时间。</p>
<p><strong>Token失效，缓存也不存在的情况</strong></p>
<p>当第15天，用户的<code>Token</code>失效以后，我们让Shiro程序到Redis查看是否存在缓存的<code>Token</code>，如果这个<code>Token</code>不存在于Redis里面，就说明用户的操作间隔了15天，需要重新登录。</p>
<p><strong>Token失效，但是缓存还存在的情况</strong></p>
<p>如果Redis中存在缓存的<code>Token</code>，说明当前<code>Token</code>失效后，间隔时间还没有超过15天，不应该让用户重新登录。所以要生成新的<code>Token</code>返回给客户端，并且把这个<code>Token</code>缓存到Redis里面，这种操作成为刷新<code>Token</code>过期时间。</p>
<h3 id="客户端如何更新令牌？"><a href="#客户端如何更新令牌？" class="headerlink" title="客户端如何更新令牌？"></a>客户端如何更新令牌？</h3><p>在我们的方案中，服务端刷新<code>Token</code>过期时间，其实就是生成一个新的<code>Token</code>给客户端。那么客户端怎么知道这次响应带回来的Token是更新过的呢？这个问题很容易解决。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/604388be09c7fd5520570382-20231217152128530.jpg" alt="img"></p>
<p>只要用户成功登陆系统，当后端服务器更新<code>Token</code>的时候，就在响应中添加<code>Token</code>。客户端那边判断每次Ajax响应里面是否包含<code>Token</code>，如果包含，就把<code>Token</code>保存起来就可以了。</p>
<h3 id="如何在响应中添加令牌？"><a href="#如何在响应中添加令牌？" class="headerlink" title="如何在响应中添加令牌？"></a>如何在响应中添加令牌？</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/604388d2095c736a14600633-20231217152133435.jpg" alt="img"></p>
<p>我们定义<code>OAuth2Filter</code>类拦截所有的HTTP请求，一方面它会把请求中的<code>Token</code>字符串提取出来，封装成对象交给Shiro框架；另一方面，它会检查<code>Token</code>的有效性。如果<code>Token</code>过期，那么会生成新的<code>Token</code>，分别存储在<code>ThreadLocalToken</code>和<code>Redis</code>中。</p>
<p>之所以要把<code>新令牌</code>保存到<code>ThreadLocalToken</code>里面，是因为要向<code>AOP切面类</code>传递这个<code>新令牌</code>。虽然<code>OAuth2Filter</code>中有<code>doFilterInternal()</code>方法，我们可以得到响应并且写入<code>新令牌</code>。但是这个做非常麻烦，首先我们要通过IO流读取响应中的数据，然后还要把数据解析成JSON对象，最后再放入这个新令牌。如果我们定义了<code>AOP切面类</code>，拦截所有Web方法返回的<code>R对象</code>，然后在<code>R对象</code>里面添加<code>新令牌</code>，这多简单啊。但是<code>OAuth2Filter</code>和<code>AOP</code>切面类之间没有调用关系，所以我们很难把<code>新令牌</code>传给<code>AOP切面类</code>。</p>
<p>这里我想到了<code>ThreadLocal</code>，只要是同一个线程，往<code>ThreadLocal</code>里面写入数据和读取数据是完全相同的。在Web项目中，从<code>OAuth2Filter</code>到<code>AOP切面类</code>，都是由同一个线程来执行的，中途不会更换线程。所以我们可以放心的把新令牌保存都在<code>ThreadLocal</code>里面，<code>AOP切面类</code>可以成功的取出新令牌，然后往<code>R对象</code>里面添加新令牌即可。</p>
<p><code>ThreadLocalToken</code>是我自定义的类，里面包含了<code>ThreadLocal</code>类型的变量，可以用来保存线程安全的数据，而且避免了使用线程锁。</p>
<h3 id="创建ThreadLocal类"><a href="#创建ThreadLocal类" class="headerlink" title="创建ThreadLocal类"></a>创建ThreadLocal类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; local=<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToken</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        local.set(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> local.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        local.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建OAuth2Filter类"><a href="#创建OAuth2Filter类" class="headerlink" title="创建OAuth2Filter类"></a>创建<code>OAuth2Filter</code>类</h3><p>在创建过滤器的时候，首先应该判断哪些请求应该被<code>Shiro</code>框架处理，如果是<code>options</code>请求则直接放行，其余的所有请求都要被<code>Shiro</code>处理，在客户端提交请求的时候，如果数据是<code>application/json</code>数据，那么这个请求会被分成<code>options</code>和<code>post</code>两次请求，<code>options</code>请求只是一个试探性的请求，试探一下服务器是否支持，请求中不携带数据，如果服务器支持，那么就会继续发送<code>post</code>请求，这时候才会被<code>Shiro</code>处理。然后过滤器会判断一下<code>Token</code>是否过期，是真过期还是假过期，从请求头中提取中<code>Token</code>字符串，如果是真过期，那么就返回提示信息，让用户重新登录；如果是假过期，后端就生成新的令牌，刷新令牌，返回给客户端。最后就是把新令牌保存起来，同时保存到ThreadLocalToken和Reids。</p>
<blockquote>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>因为在<code>OAuth2Filter</code>类中要读写<code>ThreadLocal</code>中的数据，所以<code>OAuth2Filter</code>类必须要设置成多例的，否则<code>ThreadLocal</code>将无法使用。</p>
</blockquote>
<p>在配置文件中，添加JWT需要用到的密钥、过期时间和缓存过期时间。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">emos:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="comment">#密钥</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">abc123456</span></span><br><span class="line">    <span class="comment">#令牌过期时间（天）</span></span><br><span class="line">    <span class="attr">expire:</span>  <span class="number">5</span></span><br><span class="line">    <span class="comment">#令牌缓存时间（天数）</span></span><br><span class="line">    <span class="attr">cache-expire:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>在<code>com.example.emos.wx.config.shiro</code>中创建<code>OAuth2Filter</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.emos.wx.config.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.TokenExpiredException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.filter.authc.AuthenticatingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuth2Filter</span> <span class="keyword">extends</span> <span class="title class_">AuthenticatingFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocalToken threadLocalToken;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;emos.jwt.cache-expire&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cacheExpire;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 拦截请求之后，用于把令牌字符串封装成令牌对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取请求token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getRequestToken((HttpServletRequest) request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OAuth2Token</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 拦截请求，判断请求是否需要被Shiro处理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// Ajax提交application/json数据的时候，会先发出Options请求</span></span><br><span class="line">		<span class="comment">// 这里要放行Options请求，不需要Shiro处理</span></span><br><span class="line">		<span class="keyword">if</span> (req.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 除了Options请求之外，所有请求都要被Shiro处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该方法用于处理所有应该被Shiro处理的请求</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">		resp.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">		<span class="comment">//允许跨域请求</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, req.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line"></span><br><span class="line">		threadLocalToken.clear();</span><br><span class="line">        <span class="comment">//获取请求token，如果token不存在，直接返回401</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getRequestToken((HttpServletRequest) request);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            resp.getWriter().print(<span class="string">&quot;无效的令牌&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jwtUtil.verifierToken(token); <span class="comment">//检查令牌是否过期</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">            <span class="comment">//客户端令牌过期，查询Redis中是否存在令牌，如果存在令牌就重新生成一个令牌给客户端</span></span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.hasKey(token)) &#123;</span><br><span class="line">                redisTemplate.delete(token);<span class="comment">//删除令牌</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> jwtUtil.getUserId(token);</span><br><span class="line">                token = jwtUtil.createToken(userId);  <span class="comment">//生成新的令牌</span></span><br><span class="line">                <span class="comment">//把新的令牌保存到Redis中</span></span><br><span class="line">                redisTemplate.opsForValue().set(token, userId + <span class="string">&quot;&quot;</span>, cacheExpire, TimeUnit.DAYS);</span><br><span class="line">                <span class="comment">//把新令牌绑定到线程</span></span><br><span class="line">                threadLocalToken.setToken(token);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果Redis不存在令牌，让用户重新登录</span></span><br><span class="line">                resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">                resp.getWriter().print(<span class="string">&quot;令牌已经过期&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">            resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            resp.getWriter().print(<span class="string">&quot;无效的令牌&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> executeLogin(request, response);</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginFailure</span><span class="params">(AuthenticationToken token,</span></span><br><span class="line"><span class="params">		AuthenticationException e, ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        resp.setStatus(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, req.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp.getWriter().print(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求头里面的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getRequestToken</span><span class="params">(HttpServletRequest httpRequest)</span> &#123;</span><br><span class="line">        <span class="comment">//从header中获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> httpRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果header中不存在token，则从参数中获取token</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            token = httpRequest.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, </span></span><br><span class="line"><span class="params">		ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doFilterInternal(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>启动SpringBoot项目时报错Error parsing HTTP request header</title>
    <url>/posts/53549.html</url>
    <content><![CDATA[<p>在服务器中使用Docker部署SpringBoot项目时，在启动日志里发现项目报错，报错内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Error parsing HTTP request header</span><br><span class="line"> Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.</span><br><span class="line">java.lang.IllegalArgumentException: Invalid character found in method name [0x040x010x00P0x8e]0x880x8e0...]. HTTP method names must be tokens</span><br><span class="line">        at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:417)</span><br><span class="line">        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:261)</span><br><span class="line">        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)</span><br><span class="line">        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:888)</span><br><span class="line">        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1597)</span><br><span class="line">        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)</span><br><span class="line">        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)</span><br><span class="line">        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">        at java.base/java.lang.Thread.run(Thread.java:832)</span><br></pre></td></tr></table></figure>
<p>可以看到在请求信息中包含了非法字符，所以我们在项目中添加一个Tomcat配置类，使得可以插入\”#&lt;&gt;[\]^`{|}中的任意特殊字符，当然也可以自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Connector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">webServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        factory.addConnectorCustomizers((Connector connector) -&gt; &#123;</span><br><span class="line">                connector.setProperty(<span class="string">&quot;relaxedPathChars&quot;</span>, <span class="string">&quot;\&quot;#&lt;&gt;[\\]^`&#123;|&#125;&quot;</span>);</span><br><span class="line">                connector.setProperty(<span class="string">&quot;relaxedQueryChars&quot;</span>, <span class="string">&quot;\&quot;#&lt;&gt;[\\]^`&#123;|&#125;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新打包项目，并部署在docker中，发现已经没有报错。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>如何迁移Hexo博客到新电脑</title>
    <url>/posts/35875.html</url>
    <content><![CDATA[<p>换了台笔记本，懒得迁移博客，拖了好久还是做了一下迁移，记录一下过程，方便以后查看。<br><span id="more"></span></p>
<h1 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h1><p>安装<code>git</code>,<code>node.js</code></p>
<h1 id="选择文件"><a href="#选择文件" class="headerlink" title="选择文件"></a>选择文件</h1><p>从之前的博客文件夹中选择必须要拷贝的文件，备份起来。首先是之前自己修改的文件，像配置文件<code>_config.yml,theme</code>文件夹，<code>source</code>文件夹自己写的原始文件这些都是必须要拷贝走的。除此之外还有<code>scaffolds</code>文件夹(文件的模板)，<code>package.json</code>(使用哪些包)，<code>.gitignore</code>(提交忽略哪些文件夹)<br>总结：     </p>
<ul>
<li>_config.yml</li>
<li>themes</li>
<li>source</li>
<li>scaffolds</li>
<li>package.json</li>
<li>.gitignore<br>是需要备份的，其他文件不需要管。<h1 id="开始迁移"><a href="#开始迁移" class="headerlink" title="开始迁移"></a>开始迁移</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局安装hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">// 把必须拷贝的文件，拷贝到新建的文件夹内，执行以下命令</span><br><span class="line">// 在新建的文件夹内打开命令行，安装必要的模块，初始化</span><br><span class="line">// 这里不用hexo init初始化，因为配置文件我们已经拷贝过来</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">// 安装其他一些必要的组件</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<h1 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//先本地预览</span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">//此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功</span><br></pre></td></tr></table></figure>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2>在你的博客文件夹中打开git bash,复制一下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
内容换成你自己的Github用户名和邮箱。<br>执行一下两条指令，检查你有没有输入正确。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
<p>然后创建SSH,一路回车<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><br>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。<br>ssh，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p>
<p>而后在GitHub的setting中，找到<code>SSH and GPC keys</code>的设置选项，点击<code>New SSH key</code><br>把你的<code>id_rsa.pub</code>里面的信息复制进去,title随便填写。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正式部署</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私基础</title>
    <url>/posts/9305.html</url>
    <content><![CDATA[<p>数据的隐私保护问题最早由统计学家Dalenius 在20世纪70年代末提出，他认为，保护数据库中的隐私信息，就是要使任何用户（包括合法用户和潜在的攻击者）在访问数据库的过程中无法获取关于任意个体的确切信息 。</p>
<span id="more"></span>
<p>从已有的研究来看，k-anonymity及其扩展模型在隐私保护领域影响深远且被广泛应用。这些模 型的基本思想是将数据集里与攻击者背景知识相关的属性定义为准标识符，通过对记录的准标识符值进行泛化、压缩处理，使得所有记录被划分到若干个等价类（Equivalence Group）,每个等价类中的记录具有相同 的准标识符，从而实现将一个记录隐藏在一组记录中。因此，这类模型也被称为基于分组的隐私保护模型。</p>
<p>差分隐私是Dwork在2006年针对统计数据库的隐私泄露问题提出的一种新的隐私定义。在此定义下，对数据集的计算处理结果对于具体某个记录的变化是不敏感的，单个记录在数据集中或者不在数据集中，对计算结果的影响微乎其微。所以，一 个记录因其加入到数据集中所产生的隐私泄露风险被控制在极小的、可接受的范围内，攻击者无法通过观察计算结果而获取准确的个体信息。</p>
<p>差分隐私保护模型的思想源自于一个很朴素的观察：<strong>当数据集 Ｄ 中包含个体 Alice时，设 对 Ｄ 进行任意查询操作f（例如计数、求和、平均值、中位数 或其它范围查询等）所得到的结果为ｆ(Ｄ），如果将 Alice的信息从 Ｄ 中删除后进行查询得到的结果仍然为ｆ（Ｄ），则可以认为，Alice的信息并没有因为被包含在数据集 Ｄ 中而产生额外的风险。差分隐私保护就是要保证任一个体在数据集中或者不在数据 集中时，对最终发布的查询结果几乎没有影响。具体地说，设有两个几乎完全相同的数据集（两者的区别仅在于一个记录不同），分别对这两个数据集进行查 询访问，同一查询在两个数据集上产生同一结果的概率的比值接近于１。</strong></p>
<h2 id="差分隐私定义"><a href="#差分隐私定义" class="headerlink" title="差分隐私定义"></a>差分隐私定义</h2><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600153e13ffa7d37b34644c5.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600155113ffa7d37b346de19.jpg"  /></p>
<h3 id="隐私保护预算"><a href="#隐私保护预算" class="headerlink" title="隐私保护预算"></a>隐私保护预算</h3><p>隐私保护预算$\epsilon$用来控制算法M在两个相邻数据集上获得相同输出的概率比值，它事实上体现了M所能够提供的隐私保护水平。实际应用中，$\epsilon$的取值很小，例如0.01,0.1，或者ln2,ln3等，$\epsilon$越小，表示隐私保护水平越高。当$\epsilon$为0时，表示对于任意临近数据集，算法都将输出两个概率分布完全相同的结果，这些结果也不能反映出任何关于数据集的有用的信息。因此，$\epsilon$的取值要考虑到安全性和可用性之间的平衡。</p>
<h3 id="敏感度"><a href="#敏感度" class="headerlink" title="敏感度"></a>敏感度</h3><p>敏感度是决定加入噪声大小的关键参数，它指删除数据集中任一记录对查询结果造成的<strong>最大改变</strong>。差分隐私中定义了两种敏感度，即<strong>全局敏感度</strong>和<strong>局部敏感度</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600159893ffa7d37b349a7f5.jpg" alt=""></p>
<p>函数的全局敏感度由函数本身决定，不同的函数会有不同的全局敏感度。一些函数的全局敏感度较小，因此只需要加入少量的噪声即可掩盖因一个记录被删除对查询结果所产生的的影响。但某些函数的全局敏感度较大，必须在函数输出中添加足够大的噪声才能保证隐私安全，导致数据可用性较差。因此提出了<strong>局部敏感度</strong>的概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/60015bc43ffa7d37b34af6b4.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/60015bf33ffa7d37b34b0fa2.jpg" alt=""></p>
<p>但是，局部敏感度在一定程度上体现了数据集的数据分布特征，如果直接应用局部敏感度来计算噪声量则会泄露数据集中的敏感信息，因此局部敏感度的<strong>平滑上界</strong>被用来与局部敏感度一起确定噪声量的大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/6001614c3ffa7d37b34dc624.jpg" alt=""></p>
<p>所有满足这一定义的函数都可被定义为平滑上界，将局部敏感度带入到此函数中可得到<strong>平滑敏感度</strong>，进而用于计算噪声大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600163743ffa7d37b34ed27d.jpg" alt=""></p>
<p>由于绝大部分关于差分隐私保护的研究均针对计数查询、求和查询等敏感度较小的函数，因此，若无特殊说明，本文中敏感度均指全局敏感度。</p>
<h2 id="差分隐私的组合性质"><a href="#差分隐私的组合性质" class="headerlink" title="差分隐私的组合性质"></a>差分隐私的组合性质</h2><p>一个复杂的隐私保护问题通常需要多次应用差分隐私才能解决。在这种情况下，为了保证整个过程的隐私保护水平控制在给定的预算$\epsilon$之内，需要合理地将全部预算分配到整个算法的各个步骤中。这时可以利用隐私保护算法的两个组合性质：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/60023e303ffa7d37b3ac3e30.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/60023e8b3ffa7d37b3ac582b.jpg" style="zoom: 67%;" /></p>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>为了使一个算法满足差分隐私保护的要求，对不同的问题有不同的实现方法，这些实现方法称为“机制”。<strong>拉普拉斯机制</strong>和<strong>指数机制</strong>是两种最基础的差分隐私保护机制。其中，<strong>拉普拉斯机制适用于对数值型结果的保护，指数机制适用于非数值型结果。</strong></p>
<h3 id="Laplace机制"><a href="#Laplace机制" class="headerlink" title="Laplace机制"></a>Laplace机制</h3><p>Laplace机制通过向确切的查询结果中加入服从Laplace分布的随机噪声来实现$\epsilon$-差分隐私保护。记位置参数为0、尺度参数为b的Laplace分布为<strong>Lap(b)</strong>，那么其概率密度函数为</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600240b93ffa7d37b3acfe3f.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600241823ffa7d37b3ad3c91.jpg" style="zoom:67%;" /></p>
<p>噪声（尺度）参数b取决于当我们修改一个人的数据时，查询结果<strong>总会</strong>改变多少。一组查询总共的“最大改变”被称为他们的<strong>敏感度</strong>，取b=敏感度/$\epsilon$即能满足$\epsilon$-差分隐私。</p>
<h3 id="指数机制"><a href="#指数机制" class="headerlink" title="指数机制"></a>指数机制</h3><p>指数机制适用于非数值型的数据，设查询函数的输出域为$Range$,域中的每个值$r\in Range$为一个实体对象，在指数机制下，函数$q(D,r)\rightarrow R$称为输出值$r$的可用性函数，用来评估输出值$r$的优劣程度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600245b43ffa7d37b3aeb3db.jpg" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>差分隐私</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私应用与展望</title>
    <url>/posts/40615.html</url>
    <content><![CDATA[<p>如何设计一个满足差分隐私的算法？</p>
<blockquote>
<p>一般做法：从一个不满足差分隐私的算法出发，往算法里适当地加入一定噪音，以使其输出满足差分隐私的要求。    </p>
</blockquote>
<span id="more"></span>
<h2 id="拉普拉斯机制"><a href="#拉普拉斯机制" class="headerlink" title="拉普拉斯机制"></a>拉普拉斯机制</h2><p>假设我们有一个病患数据集D，考虑以下数据库查询：<img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/6000fe873ffa7d37b316de43.png" alt=""></p>
<p>如果我们要发布这个查询结果，如何才能满足$\epsilon$-差分隐私？</p>
<p>我们首先考虑这个查询结果有多依赖于某个特定病人的信息，如果我们修改D中任意一个病患的数据，上述查询结果最多会改变1，所以我们能用噪声来“掩盖”这种不大于1的改变，就能满足差分隐私。具体来说，我们可以往查询结果中加入一个服从拉普拉斯分布的噪声。<img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/6001001a3ffa7d37b31775db.jpg" alt=""></p>
<p>参数$\lambda$设为$\frac{1}{\epsilon}$，即能满足$\epsilon$-差分隐私。</p>
<p>如果要发布的结果是下面这个查询结果呢？<img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600101213ffa7d37b317f01b.jpg" alt=""></p>
<p>首先，我们修改一个病患的数据，则上述查询结果最多改变3，我们可以对其加入拉普拉斯噪声，并把参数</p>
<p>$\lambda$设为$\frac{3}{\epsilon}$，<img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/6001001a3ffa7d37b31775db-20231217151651065.jpg" alt=""></p>
<blockquote>
<p>一般而言，如果我们要发布一组数值型查询结果，我们可以对每个结果加入独立的拉普拉斯噪声来满足差分隐私。</p>
<p>噪声参数$\lambda$取决于当我们修改一个人的数据时，查询结果<strong>总会</strong>改变多少。一组查询总共的“最大改变”被称为他们的<strong>敏感度</strong>，取$\lambda$=敏感度/$\epsilon$即能满足$\epsilon$-差分隐私。</p>
</blockquote>
<h2 id="随机化回答"><a href="#随机化回答" class="headerlink" title="随机化回答"></a>随机化回答</h2><p>如果我们要发布的数据不是数值型的话，我们可以用其他方法引入噪声，下面介绍一种数据采集的简单机制：随机化回答。</p>
<p>假设我向一组人提问一个敏感的是非题，出于隐私，有的人可能不愿意给真实答案，解决方案是让每个人在他的答案中加入噪声。<img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600104713ffa7d37b319597d-20231217151710239.jpg" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600104903ffa7d37b3196a6c.jpg" alt=""></p>
<p>随机化回答可以满足$\epsilon$-差分隐私，直观原因是：由于其随机性，攻击者不能中随机化的输出反推出输入到底是“yes”还是“no”,只要根据$\epsilon$来调整随机化的概率即可。但是我们依然可以通过随机化回答的输出来回答如下问题：</p>
<p>大概有多少人的真实回答是“yes”?</p>
<p>假设有10000人用随机化回答给了我回复</p>
<ul>
<li>当中有5500个yes和4500个no</li>
</ul>
<p>每个人以80%概率给我假回复</p>
<ul>
<li>所以大致中共有8000个假回复</li>
<li>当中大致上有4000个假yes和4000个假no</li>
</ul>
<p>据此，我可以判断剩下的真实回答里大概有1500个yes和500个no</p>
<ul>
<li>所以大概75%的人的真实回答是yes</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600106bd3ffa7d37b31a7115.jpg" alt=""></p>
<p>总结：</p>
<ul>
<li>通过随机修改回复来满足差分隐私</li>
<li>由于修改时引入的噪声分布已知，因此我们扔可以反推出源数据的大致分布</li>
<li>但无法反推出个体回复</li>
</ul>
<h2 id="差分隐私数据库"><a href="#差分隐私数据库" class="headerlink" title="差分隐私数据库"></a>差分隐私数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600107b13ffa7d37b31ad2c3.jpg" alt=""></p>
<ul>
<li>只回答聚合查询的结果</li>
<li>通过往查询结果中加入噪声来满足差分隐私</li>
<li>例子：微软的PINQ,Uber的Chorus</li>
</ul>
<p>技术难点：</p>
<ul>
<li>如何用尽量少的噪声来达到$\epsilon$-差分隐私<ul>
<li>尤其是在查询需要连接多张数据库表的时候</li>
</ul>
</li>
<li>如何高效地计算查询的敏感度</li>
<li>如何将差分隐私模块整合到现有数据库中</li>
</ul>
<p>展望：</p>
<p>现有算法尚未能在隐私保护、查询准确性及计算效率三者间取得很好的平衡，例如：Uber的Chrous在不少查询中误差可达100%以上</p>
<h2 id="差分隐私机器学习"><a href="#差分隐私机器学习" class="headerlink" title="差分隐私机器学习"></a>差分隐私机器学习</h2><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/600108bc3ffa7d37b31b519f.jpg" alt=""></p>
<ul>
<li><p>在机器学习算法中引入噪声，使得算法生成的模型能满足差分隐私</p>
</li>
<li><p>例子：谷歌的TensorFlow Privacy</p>
<p><a href="https://github.com/tensorflow/privacy">https://github.com/tensorflow/privacy</a></p>
<p>可用于神经网络训练</p>
</li>
</ul>
<h3 id="TensorFlow-Privacy的基本原理"><a href="#TensorFlow-Privacy的基本原理" class="headerlink" title="TensorFlow Privacy的基本原理"></a>TensorFlow Privacy的基本原理</h3><p>神经网络通常是用随机梯度下降来进行训练的：</p>
<ol>
<li>从一组随机的神经网络权重参数出发</li>
<li>拿一组随机选取的元组来计算权重的梯度</li>
<li>用梯度来更新权重参数</li>
<li>重复步骤2-3</li>
</ol>
<p>TensorFlow Privacy对步骤2中的梯度加入噪声，以保证训练过程满足差分隐私。</p>
<p>关于差分隐私机器学习，现有算法的不足：</p>
<ul>
<li>准确性还有待 提高</li>
<li>尚不能很好地处理复杂模型，如GAN</li>
</ul>
<p>另有一些新方向，如：</p>
<ul>
<li>联邦学习</li>
<li>与安全多方计算的结合</li>
</ul>
<h2 id="差分隐私数据采集"><a href="#差分隐私数据采集" class="headerlink" title="差分隐私数据采集"></a>差分隐私数据采集</h2><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/60010a903ffa7d37b31c58e3.jpg" alt=""></p>
<p>场景：从移动设备中采集用户数据，入应用程序的使用时长等</p>
<p>为满足差分隐私，让用户采用类似于随机化回答 的方法来提供数据</p>
<p>例子：谷歌Chrome、苹果iPhone、iPad和Mac、微软Windows10</p>
<p>技术难点：需要采集的数据可能比较复杂，无法用传统随机化回答问题</p>
<ul>
<li>例子：用户输入的新词（字典里面没有的）</li>
</ul>
<p>为此，谷歌，苹果和微软都因其采集需要提出了新的随机化算法</p>
<p>现有不足：</p>
<ul>
<li>现有算法要求每个用户对其数据加入相当程度的噪声</li>
<li>这对后期估计统计数据带来了一些困难</li>
</ul>
<p>近年来大家开始探索的新方向：</p>
<ul>
<li>与安全计算相结合，以减少满足差分隐私所需的噪声</li>
</ul>
<h2 id="差分隐私数据合成"><a href="#差分隐私数据合成" class="headerlink" title="差分隐私数据合成"></a>差分隐私数据合成</h2><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/6001175e3ffa7d37b324e1e1.jpg" alt=""></p>
<p>基本原理：</p>
<ul>
<li>先对源数据进行建模，得到一个统计模型</li>
<li>用统计模型来合成出虚拟产品</li>
</ul>
<p>例子：美国普查局的一些数据产品，如<a href="https://onthemap.ces.census.gov/">https://onthemap.ces.census.gov/</a></p>
<p>技术难点：</p>
<ul>
<li>如何找到一个合适的统计模型？</li>
<li>如何在统计模型中加入噪声，以满足差分隐私？</li>
</ul>
<p>现有不足：</p>
<ul>
<li>目前的算法只能处理关系型数据</li>
<li>对非关系型数据的合成基本上还在摸索阶段，如图数据、文本数据等</li>
</ul>
<h2 id="展望：弥补差分隐私本身的不足"><a href="#展望：弥补差分隐私本身的不足" class="headerlink" title="展望：弥补差分隐私本身的不足"></a>展望：弥补差分隐私本身的不足</h2><ul>
<li>如何设计一个更加贴近实际的隐私模型</li>
<li>现有文献中已有不少改进差分隐私的尝试，但尚未得到广泛应用，原因：改进后的模型往往过于复杂，难以被大众所认同</li>
<li>差分隐私虽然有着优雅的数学表达，但并不直接对应任何法律条文<ul>
<li>满足差分隐私不等于满足隐私保护法律</li>
</ul>
</li>
<li>要解决这一问题，需要计算机界与法律界相互合作</li>
<li>近来已有学者尝试中法律条文出发来设计隐私保护模型，并借鉴差分隐私的思想</li>
</ul>
]]></content>
      <categories>
        <category>差分隐私</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/posts/11306.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>每一轮排序选择一个基准点（pivot）进行分区<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
<li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li>
</ol>
<span id="more"></span>
<p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p>
<ol>
<li><p>选择最右元素作为基准点元素</p>
</li>
<li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p>
</li>
<li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p>
</li>
<li><p>最后基准点与 i 交换，i 即为分区位置</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p>
<ol>
<li>选择最左元素作为基准点元素</li>
<li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li>
<li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li>
</ol>
<p>要点</p>
<ol>
<li><p>基准点在左边，并且要先 j 后 i</p>
</li>
<li><p>while( ==<strong>i</strong> <strong>&lt; j</strong>== &amp;&amp; a[j] &gt; pv ) j— </p>
</li>
<li>while ( ==<strong>i</strong> <strong>&lt; j</strong>== &amp;&amp; a[i] ==<strong>&lt;=</strong>== pv ) i++</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快排特点</strong></p>
<ol>
<li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p>
</li>
<li><p>数据量较大时，优势非常明显</p>
</li>
<li><p>属于不稳定排序</p>
</li>
</ol>
<p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p>
<ul>
<li>霍尔的移动次数平均来讲比洛穆托少3倍</li>
<li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>抵御跨站脚本(XSS)攻击</title>
    <url>/posts/8078.html</url>
    <content><![CDATA[<h2 id="一、XSS攻击的危害"><a href="#一、XSS攻击的危害" class="headerlink" title="一、XSS攻击的危害"></a>一、XSS攻击的危害</h2><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<span id="more"></span>
<p>例如用户在发帖或者注册的时候，在文本框中输入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，这段代码如果不经过转义处理，而直接保存到数据库。将来视图层渲染HTML的时候，把这段代码输出到页面上，那么<code>&lt;script&gt;</code>标签的内容就会被执行。</p>
<p>通常情况下，我们登陆到某个网站。如果网站使用<code>HttpSession</code>保存登陆凭证，那么<code>SessionId</code>会以<code>Cookie</code>的形式保存在浏览器上。如果黑客在这个网页发帖的时候，填写的<code>JavaScript</code>代码是用来获取<code>Cookie</code>内容的，并且把<code>Cookie</code>内容通过Ajax发送给黑客自己的电脑。于是只要有人在这个网站上浏览黑客发的帖子，那么视图层渲染HTML页面，就会执行注入的XSS脚本，于是你的<code>Cookie</code>信息就泄露了。黑客在自己的电脑上构建出<code>Cookie</code>，就可以冒充已经登陆的用户。</p>
<p>即便很多网站使用了JWT，登陆凭证（<code>Token令牌</code>）是存储在浏览器上面的。所以用XSS脚本可以轻松的从Storage中提取出<code>Token</code>，黑客依然可以轻松的冒充已经登陆的用户。</p>
<p>所以避免XSS攻击最有效的办法就是对用户输入的数据进行转义，然后存储到数据库里面。等到视图层渲染HTML页面的时候。转义后的文字是不会被当做JavaScript执行的，这就可以抵御XSS攻击。</p>
<h2 id="二、导入依赖库"><a href="#二、导入依赖库" class="headerlink" title="二、导入依赖库"></a>二、导入依赖库</h2><p>因为<code>Hutool</code>工具包带有XSS转义的工具类，所以我们要导入<code>Hutool</code>，然后利用<code>Servlet</code>规范提供的请求包装类，定义数据转义功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="三、定义请求包装类"><a href="#三、定义请求包装类" class="headerlink" title="三、定义请求包装类"></a>三、定义请求包装类</h2><p>我们平时写Web项目遇到的<code>HttpServletRequest</code>，它其实是个接口。如果我们想要重新定义请求类，扩展这个接口是最不应该的。因为<code>HttpServletRequest</code>接口中抽象方法太多了，我们逐一实现起来太耗费时间。所以我们应该挑选一个简单一点的自定义请求类的方式。那就是继承<code>HttpServletRequestWrapper</code>父类。</p>
<p>JavaEE只是一个标准，具体的实现由各家应用服务器厂商来完成。比如说<code>Tomcat</code>在实现<code>Servlet</code>规范的时候，就自定义了<code>HttpServletRequest</code>接口的实现类。同时JavaEE规范还定义了<code>HttpServletRequestWrapper</code>，这个类是请求类的包装类，用上了装饰器模式。不得不说这里用到的设计模式真的非常棒，无论各家应用服务器厂商怎么去实现<code>HttpServletRequest</code>接口，用户想要自定义请求，只需要继承<code>HttpServletRequestWrapper</code>，对应覆盖某个方法即可，然后把请求传入请求包装类，装饰器模式就会替代请求对象中对应的某个方法。用户的代码和服务器厂商的代码完全解耦，我们不用关心<code>HttpServletRequest</code>接口是怎么实现的，借助于包装类我们可以随意修改请求中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.http.HtmlUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ReadListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XssHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类定义一个构造器接收传入的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XssHttpServletRequestWrapper</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.getParameter(name);</span><br><span class="line">        <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">            <span class="comment">//将数据进行转义</span></span><br><span class="line">            value = HtmlUtil.filter(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        String[] values = <span class="built_in">super</span>.getParameterValues(name);</span><br><span class="line">        <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">                <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">                    value = HtmlUtil.filter(value);</span><br><span class="line">                &#125;</span><br><span class="line">                values[i] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameters = <span class="built_in">super</span>.getParameterMap();</span><br><span class="line">        Map&lt;String, String[]&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String key : parameters.keySet()) &#123;</span><br><span class="line">                String[] values = parameters.get(key);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">                    <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">                        value = HtmlUtil.filter(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                    values[i] = value;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(key, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHeader</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.getHeader(name);</span><br><span class="line">        <span class="keyword">if</span> (!StrUtil.hasEmpty(value)) &#123;</span><br><span class="line">            value = HtmlUtil.filter(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringMVC框架通过这个方法从请求里面提取客户端提交的数据，然后把这些数据封装到form对象里面，</span></span><br><span class="line"><span class="comment">     * 如果不对getInputStream()方法读取的数据做转义，那么后端项目就不具备抵御跨站脚本攻击的能力。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">super</span>.getInputStream();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> buffer.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            body.append(line);</span><br><span class="line">            line = buffer.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = JSONUtil.parseObj(body.toString());</span><br><span class="line">        Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>(map.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (map.get(key) <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                resultMap.put(key, HtmlUtil.filter(val.toString()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultMap.put(key, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSONUtil.toJsonStr(resultMap);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">bain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(str.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> bain.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener listener)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、创建过滤器，把所有请求对象传入包装类"><a href="#四、创建过滤器，把所有请求对象传入包装类" class="headerlink" title="四、创建过滤器，把所有请求对象传入包装类"></a>四、创建过滤器，把所有请求对象传入包装类</h2><p>为了让刚刚定义的包装类生效，我们还要在请求包装类的所在目录下中创建<code>XssFilter</code>过滤器。过滤器拦截所有请求，然后把请求传入包装类，这样包装类就能覆盖所有请求的参数方法，用户从请求中获得数据，全都经过转义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XssFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">XssHttpServletRequestWrapper</span> <span class="variable">xssRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XssHttpServletRequestWrapper</span>(</span><br><span class="line">                (HttpServletRequest) request);</span><br><span class="line">        chain.doFilter(xssRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、给启动类添加注解"><a href="#五、给启动类添加注解" class="headerlink" title="五、给启动类添加注解"></a>五、给启动类添加注解</h2><p>给SpringBoot启动类添加<code>@ServletComponentScan</code>注解。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/posts/50190.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<span id="more"></span>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//退出排序，减少比较次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与选择排序比较</strong></p>
<ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$</p>
</li>
<li><p>大部分情况下，插入都略优于选择</p>
</li>
<li><p>有序集合插入的时间复杂度为 $O(n)$</p>
</li>
<li><p>插入属于稳定排序算法，而选择属于不稳定排序</p>
</li>
</ol>
<p><strong>提示</strong></p>
<blockquote>
<p><em>插入排序通常被轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之双指针法</title>
    <url>/posts/36720.html</url>
    <content><![CDATA[<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。例如<a href="https://leetcode-cn.com/problems/remove-element/">27.移除元素</a></p>
<span id="more"></span>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p>
</blockquote>
<p>这道题目可以使用暴力破解的方法，通过两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组，不过时间复杂度是O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; ++j)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                --length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要降低时间复杂度为O(n),可以使用双指针法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;fastIndex &lt; nums.length; ++fastIndex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex]!=val)&#123;</span><br><span class="line">                nums[lowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存击穿问题及解决方法</title>
    <url>/posts/cachebreakdown.html</url>
    <content><![CDATA[<p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221117180656666.png" alt="image-20221117180656666"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221117180718900.png" alt="image-20221117180718900"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20221117180749105.png" alt="image-20221117180749105"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/1653357522914.png" alt="1653357522914"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/posts/51203.html</url>
    <content><![CDATA[<p><strong>算法描述</strong></p>
<ol>
<li>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</li>
<li>重复以上步骤，直到整个数组有序</li>
</ol>
<span id="more"></span>
<p><strong>算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li>
</ul>
<p><strong>与冒泡排序比较</strong></p>
<ol>
<li><p>二者平均时间复杂度都是 $O(n^2)$ </p>
</li>
<li><p>选择排序一般要快于冒泡，因为其交换次数少</p>
</li>
<li><p>但如果集合有序度高，冒泡优于选择</p>
</li>
<li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p>
<ul>
<li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li>
<li>不稳定排序则反之</li>
</ul>
</li>
</ol>
<p><strong>稳定排序与不稳定排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure>
<p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p>
<ul>
<li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure>
<p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p>
</li>
<li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解@Configuration注解</title>
    <url>/posts/Annotation_Configuration.html</url>
    <content><![CDATA[<p><code>@Configuration</code>注解可以标注到类上，当标注到类上时，启动Spring就会自动扫描<code>@Configuration</code>注解标注的类，将其注册到IOC容器中，并被实例化成Bean对象。如果被<code>@Configuration</code>注解标注的类中存在使用<code>@Bean</code>注解标注的创建某个类对象的方法，那么，Spring也会自动执行使用<code>@Bean</code>注解标注的方法，将对应的Bean定义信息注册到IOC容器，并进行实例化。</p>
<h2 id="注解详解"><a href="#注解详解" class="headerlink" title="注解详解"></a>注解详解</h2><p><code>@Configuration</code>注解是从Spring 3.0版本开始加入的一个使Spring能够支持注解驱动开发的标注型注解，主要用于标注在类上。当某个类标注了<code>@Configuration</code>注解时，表示这个类是Spring的一个配置类。<code>@Configuration</code>注解能够替代Spring的<code>applicationContext.xml</code>文件，并且被<code>@Configuration</code>注解标注的类，能够自动注册到IOC容器并进行实例化。</p>
<h3 id="注解源码"><a href="#注解源码" class="headerlink" title="注解源码"></a>注解源码</h3><p>源码详见：org.springframework.context.annotation.Configuration。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//Since: 5.2</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//Since: 6.0</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">enforceUniqueMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>@Configuration</code>注解中每个属性的含义如下所示。</p>
<ul>
<li>value：存入到Spring IOC容器中的Bean的id。</li>
<li>proxyBeanMethods：从Spring 5.2版本开始加入到<code>@Configuration</code>注解，表示被<code>@Configuration</code>注解标注的配置类是否会被代理，并且在配置类中使用<code>@Bean</code>注解生成的Bean对象在IOC容器中是否是单例对象，取值为true或者false。当取值为true时，表示full（全局）模式，此模式下被<code>@Configuration</code>注解标注的配置类会被代理，在配置类中使用<code>@Bean</code>注解注入到IOC容器中的Bean对象是单例模式，无论调用多少次被<code>@Bean</code>注解标注的方法，返回的都是同一个Bean对象。当取值为false时，表示lite（轻量级）模式，此模式下被<code>@Configuration</code>注解标注的配置类不会被代理，在配置类中使用<code>@Bean</code>注解注入到IOC容器中的Bean对象不是单例模式，每次调用被<code>@Bean</code>注解标注的方法时，都会返回一个新的Bean对象。默认的取值为true。</li>
<li>enforceUniqueMethods：从Spring 6.0开始加入到<code>@Configuration</code>注解，指定使用<code>@Bean</code>注解标注的方法是否需要具有唯一的方法名称，取值为true或者false。当取值为true时，表示使用<code>@Bean</code>注解标注的方法具有唯一的方法名称，并且这些方法名称不会重叠。当取值为false时，表示使用<code>@Bean</code>注解标注的方法名称不唯一，存在被重叠的风险。默认取值为true。</li>
</ul>
<p>从<code>@Configuration</code>注解的源码也可以看出，<code>@Configuration</code>注解本质上是一个<code>@Component</code>注解，所以，被@Configuration注解标注的配置类本身也会被注册到IOC容器中。同时，<code>@Configuration</code>注解也会被<code>@ComponentScan</code>注解扫描到。</p>
<h3 id="注解使用场景"><a href="#注解使用场景" class="headerlink" title="注解使用场景"></a>注解使用场景</h3><p>基于Spring的注解开发应用程序时，可以将<code>@Configuration</code>注解标注到某个类上。当某个类被<code>@Configuration</code>注解标注时，说明这个类是配置类，可以在这个类中使用<code>@Bean</code>注解向IOC容器中注入Bean对象，也可以使用<code>@Autowired</code>、<code>@Inject</code>和<code>@Resource</code>等注解来注入所需的Bean对象。</p>
<p>注意：基于Spring的注解模式开发应用程序时，在使用<code>AnnotationConfigApplicationContext</code>类创建IOC容器时，需要注意如下事项：</p>
<p>（1）如果调用的是<code>AnnotationConfigApplicationContext</code>类中传入Class类型可变参数的构造方法来创建IOC容器，表示传入使用<code>@Configuration</code>注解标注的配置类的Class对象来创建IOC容器，则标注到配置类上的@Configuration注解可以省略。</p>
<p>AnnotationConfigApplicationContext类中传入Class类型可变参数的构造方法源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）如果调用的是AnnotationConfigApplicationContext类中传入String类型可变参数的构造方法来创建IOC容器，表示传入应用程序的包名来创建IOC容器，则标注到配置类上的@Configuration注解不能省略。</p>
<p>AnnotationConfigApplicationContext类中传入String类型可变参数的构造方法源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    scan(basePackages);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>另外，当调用的是AnnotationConfigApplicationContext类中传入Class类型可变参数的构造方法来创建IOC容器时，如果传入的配置类上省略了<code>@Configuration</code>注解，则每次调用配置类中被<code>@Bean</code>注解标注的方法时，都会返回不同的Bean实例对象。</p>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>简单介绍使用@Configuration注解的几个案例程序。</p>
<h3 id="验证proxyBeanMethods属性的作用"><a href="#验证proxyBeanMethods属性的作用" class="headerlink" title="验证proxyBeanMethods属性的作用"></a>验证proxyBeanMethods属性的作用</h3><p>在1.1节已经详细介绍过<code>@Configuration</code>注解中proxyBeanMethods属性的作用，proxyBeanMethods属性可取值为true或者false。取值为true时，无论调用多少次在被<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法，返回的都是同一个Bean对象。取值为false时，每次调用在被<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法，都回返回不同的Bean对象。</p>
<h4 id="验证proxyBeanMethods取值为true的情况"><a href="#验证proxyBeanMethods取值为true的情况" class="headerlink" title="验证proxyBeanMethods取值为true的情况"></a>验证proxyBeanMethods取值为true的情况</h4><p>具体的案例实现步骤如下所示。</p>
<p>（1）创建Person类</p>
<p>Person类主要是用来注册到IOC容器中，并实例化对象，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）创建ConfigurationAnnotationConfig类</p>
<p>ConfigurationAnnotationConfig类的作用就是充当程序启动的配置类，会在ConfigurationAnnotationConfig类上标注<code>@Configuration</code>注解，说明ConfigurationAnnotationConfig类是Spring启动时的配置类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在ConfigurationAnnotationConfig类上标注了<code>@Configuration</code>注解，由于<code>@Configuration</code>注解中的proxyBeanMethods属性默认为true，所以在ConfigurationAnnotationConfig类上的<code>@Configuration</code>注解省略了proxyBeanMethods属性。</p>
<p>（3）创建ConfigurationAnnotationTest类</p>
<p>ConfigurationAnnotationTest类的作用就是整个案例程序的启动类，对整个案例程序进行测试，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(ConfigurationAnnotationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigurationAnnotationConfig.class);</span><br><span class="line">        <span class="type">ConfigurationAnnotationConfig</span> <span class="variable">config</span> <span class="operator">=</span> context.getBean(ConfigurationAnnotationConfig.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> config.person();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> config.person();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;person1 是否等于 person2 ===&gt;&gt; &#123;&#125;&quot;</span>, (person1 == person2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在ConfigurationAnnotationTest类的main()方法中，首先基于AnnotationConfigApplicationContext创建了IOC容器context，从context中获取了ConfigurationAnnotationConfig类的Bean实例对象config，接下来，调用两次config的person()方法分别赋值给Person类型的局部变量person1和person2，最后打印person1是否等于person2的日志。</p>
<p>（4）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>通过输出的结果信息可以看出，person1是否等于person2输出的结果为true。说明当<code>@Configuration</code>注解中的proxyBeanMethods属性为true时，每次调用使用<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法时，都会返回同一个Bean实例对象。</p>
<h4 id="验证proxyBeanMethods取值为false的情况"><a href="#验证proxyBeanMethods取值为false的情况" class="headerlink" title="验证proxyBeanMethods取值为false的情况"></a>验证proxyBeanMethods取值为false的情况</h4><p>验证<code>@Configuration</code>注解中的proxyBeanMethods属性为false的情况，与验证proxyBeanMethods属性为true的情况的案例程序基本一致，只是将ConfigurationAnnotationConfig类上标注的<code>@Configuration</code>注解的proxyBeanMethods属性设置为false，案例实现的具体步骤如下所示。</p>
<p>（1）修改proxyBeanMethods属性的值</p>
<p>修改后的ConfigurationAnnotationConfig类的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此时在ConfigurationAnnotationConfig类上标注的<code>@Configuration</code>注解的proxyBeanMethods属性为false。</p>
<p>（2）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看出，person1是否等于person2输出的结果为false。说明当<code>@Configuration</code>注解中的proxyBeanMethods属性为false时，每次调用使用<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法时，都会返回不同的Bean实例对象。</p>
<h3 id="传入配置类创建IOC容器"><a href="#传入配置类创建IOC容器" class="headerlink" title="传入配置类创建IOC容器"></a>传入配置类创建IOC容器</h3><p>调用AnnotationConfigApplicationContext类的构造方法传入配置类的Class对象创建IOC容器时，可以省略配置类上的<code>@Configuration</code>注解，案例的具体实现步骤如下所示。</p>
<p>（1）删除<code>@Configuration</code>注解</p>
<p>删除ConfigurationAnnotationConfig类上的@Configuration注解，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看到，输出了person1是否等于person2的结果为false。说明调用AnnotationConfigApplicationContext类的构造方法传入配置类的Class对象创建IOC容器时，可以省略配置类上的<code>@Configuration</code>注解，此时每次调用配置类中被<code>@Bean</code>注解标注的方法时，都会返回不同的Bean实例对象。</p>
<h3 id="传入包名创建IOC容器"><a href="#传入包名创建IOC容器" class="headerlink" title="传入包名创建IOC容器"></a>传入包名创建IOC容器</h3><p>调用AnnotationConfigApplicationContext类的构造方法传入包名创建IOC容器时，不能省略配置类上的<code>@Configuration</code>注解，案例的具体实现步骤如下所示。</p>
<p>（1）修改测试类</p>
<p>修改ConfigurationAnnotationTest类的main()方法中，创建AnnotationConfigApplicationContext对象的代码，将调用传入Class对象的构造方法修改为调用传入String对象的方法，修改后的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(ConfigurationAnnotationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;io.binghe.spring.annotation.chapter01.configuration&quot;</span>);</span><br><span class="line">        <span class="type">ConfigurationAnnotationConfig</span> <span class="variable">config</span> <span class="operator">=</span> context.getBean(ConfigurationAnnotationConfig.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> config.person();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> config.person();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;person1 是否等于 person2 ===&gt;&gt; &#123;&#125;&quot;</span>, (person1 == person2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）删除<code>@Configuration</code>注解</p>
<p>删除ConfigurationAnnotationConfig类上的<code>@Configuration</code>注解，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，可以看到程序抛出了异常信息，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of <span class="built_in">type</span> <span class="string">&#x27;io.binghe.spring.annotation.chapter01.configuration.config.ConfigurationAnnotationConfig&#x27;</span> available</span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看出，调用AnnotationConfigApplicationContext类的构造方法传入包名创建IOC容器时，不能省略配置类上的<code>@Configuration</code>注解，否则会抛出NoSuchBeanDefinitionException。</p>
<p>（4）添加<code>@Configuration</code>注解</p>
<p>在ConfigurationAnnotationConfig类上添加<code>@Configuration</code>注解，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）再次测试案例</p>
<p>再次运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看到，输出了person1是否等于person2的结果为true，再次说明调用AnnotationConfigApplicationContext类的构造方法传入包名创建IOC容器时，不能省略配置类上的<code>@Configuration</code>注解。</p>
<h2 id="源码时序图"><a href="#源码时序图" class="headerlink" title="源码时序图"></a>源码时序图</h2><p>就<code>@Configuration</code>注解本身而言，在源码层面的执行流程涉及到注册与实例化两种执行流程，就注册流程而言，会涉及到Spring内部的ConfigurationClassPostProcessor类的Bean定义信息的注册流程，以及案例中标注了<code>@Configuration</code>注解的ConfigurationAnnotationConfig配置类的Bean定义信息注册流程。</p>
<p>本节，就简单介绍下<code>@Configuration</code>注解在源码层面的注册与实例化两种执行时序图。</p>
<p><strong>注意：源码时序图和源码解析均以案例程序作为入口进行分析，并且会在ConfigurationAnnotationConfig类上标注@Configuration注解，同时在ConfigurationAnnotationTest测试类中，调用AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法来创建IOC容器。</strong></p>
<h3 id="注册ConfigurationClassPostProcessor流程源码时序图"><a href="#注册ConfigurationClassPostProcessor流程源码时序图" class="headerlink" title="注册ConfigurationClassPostProcessor流程源码时序图"></a>注册ConfigurationClassPostProcessor流程源码时序图</h3><p>ConfigurationClassPostProcessor后置处理器是解析<code>@Configuration</code>注解的核心类，也是Spring中的一个非常重要的后置处理器类，Spring IOC容器启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息。向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息的时序图如下图1-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/spring-core-2022-12-05-001.png" alt="图1-1"></p>
<p>由图可以看出，Spring IOC容器启动时，向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息时，会涉及到AnnotationConfigApplicationContext类、AnnotatedBeanDefinitionReader类和AnnotationConfigUtils类中方法的调用。具体源码的调用细节见源码解析部分。</p>
<h3 id="注册ConfigurationAnnotationConfig流程源码时序图"><a href="#注册ConfigurationAnnotationConfig流程源码时序图" class="headerlink" title="注册ConfigurationAnnotationConfig流程源码时序图"></a>注册ConfigurationAnnotationConfig流程源码时序图</h3><p>ConfigurationAnnotationConfig类是案例程序的配置类，在ConfigurationAnnotationConfig类上标注了<code>@Configuration</code>注解，当Spring IOC容器启动时，也会将ConfigurationAnnotationConfig类的Bean定义信息注册到Spring IOC容器中，向Spring IOC容器中注册ConfigurationAnnotationConfig类的Bean定义信息的时序图如下图1-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/spring-core-2022-12-05-002.png" alt="图1-2"></p>
<p>由图可以看出，Spring IOC容器启动时，向IOC容器中注册ConfigurationAnnotationConfig类的Bean定义信息时，会涉及到AnnotationConfigApplicationContext类、AnnotatedBeanDefinitionReader类、BeanDefinitionReaderUtils类和DefaultListableBeanFactory类的方法调用，具体的源码调用细节见源码解析部分。</p>
<p><strong>注意：Spring IOC容器在启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的bean定义信息和使用@Configuration注解标注的ConfigurationAnnotationConfig配置类的Bean定义信息。当Spring IOC容器在刷新时，会递归处理所有使用@Configuration注解标注的类，解析@Bean等注解标注的方法，解析成一个个ConfigurationClassBeanDefinition类型的BeanDefinition对象，注册到IOC容器中。</strong></p>
<h3 id="实例化流程源码时序图"><a href="#实例化流程源码时序图" class="headerlink" title="实例化流程源码时序图"></a>实例化流程源码时序图</h3><p>Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了<code>@Configuration</code>注解的配置类进行实例化。本节，就结合案例程序简单分析下刷新IOC容器时，对标注了<code>@Configuration</code>注解的配置类进行实例化的源码时序图，源码时序图如下图1-3-1，1-3-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/spring-core-2022-12-05-003.png" alt="图1-3-1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/spring-core-2022-12-05-004.png" alt="图1-3-2"></p>
<p>由图可以看出，刷新IOC容器时，对标注了<code>@Configuration</code>注解的配置类进行实例化时，会涉及到AnnotationConfigApplicationContext类、AbstractApplicationContext类、PostProcessorRegistrationDelegate类、ConfigurationClassPostProcessor类和ConfigurationClassEnhancer类方法的调用，具体方法调用的细节见源码解析部分。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>本节，同样按照注册流程和实例化流程来深入分析<code>@Configuration</code>注解在Spring源码层面的执行流程。</p>
<h3 id="注册ConfigurationClassPostProcessor流程源码解析"><a href="#注册ConfigurationClassPostProcessor流程源码解析" class="headerlink" title="注册ConfigurationClassPostProcessor流程源码解析"></a>注册ConfigurationClassPostProcessor流程源码解析</h3><p><code>@Configuration</code>注解涉及到ConfigurationClassPostProcessor类的Bean定义信息的注册流程的源码执行过程可结合图1-1进行分析。启动Spring IOC容器时，<code>@Configuration</code>注解涉及到的ConfigurationClassPostProcessor核心类的注册流程的源码执行过程如下所示。</p>
<p>（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigurationAnnotationConfig.class);</span><br><span class="line">	<span class="comment">//#############省略其他代码##################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在main()方法中会调用AnnotationConfigApplicationContext类的构造方法传入配置类ConfigurationAnnotationConfig的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。</p>
<p>（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述构造方法中，会通过this()调用AnnotationConfigApplicationContext类的无参构造方法。</p>
<p>（3）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext()无参构造方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StartupStep</span> <span class="variable">createAnnotatedBeanDefReader</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    createAnnotatedBeanDefReader.end();</span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigApplicationContext类的无参构造方法中，主要的逻辑就是实例化了AnnotatedBeanDefinitionReader类型的reader成员变量和ClassPathBeanDefinitionScanner类型的scanner成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">AnnotationConfigRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">createAnnotatedBeanDefReader</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">        createAnnotatedBeanDefReader.end();</span><br><span class="line">        <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>reader：表示注解类型的Bean定义信息读取器，主要就是读取通过注解方式进行实例化的Bean的定义信息。</li>
<li>scanner：表示类路径下的Bean定义扫描器，主要就是扫描类路径下的Bean定义信息。</li>
</ul>
<p><code>@Configuration</code>注解涉及到的注册流程源码的执行过程，会执行实例化reader成员变量的代码，也就是下面的代码片段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，会调用AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法。</p>
<p>（4）解析AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述构造方法中，通过this调用了AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230416183717528.png" alt="image-20230416183717528"></p>
<p>（5）解析AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述构造方法中，最核心的逻辑就是调用了AnnotationConfigUtils工具类的registerAnnotationConfigProcessors()方法，将BeanDefinitionRegistry类型的registry对象传入方法中。其中，registry对象本质上就是一个AnnotationConfigApplicationContext类对象的实例，这是因为AnnotationConfigApplicationContext类继承了GenericApplicationContext类，而GenericApplicationContext类实现了BeanDefinitionRegistry接口。</p>
<p>（6）解析AnnotationConfigUtils类的<code>registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)方法中调用了AnnotationConfigUtils类中的另外一个registerAnnotationConfigProcessors()方法。</p>
<p>（7）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法</p>
<p>这里，只给出在AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法中，将@Configuration注解涉及到的ConfigurationClassPostProcessor类的Bean定义信息注册到IOC容器中的核心代码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">			BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="comment">//################省略其他代码########################</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//################省略其他代码########################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，会调用registerPostProcessor()方法注册后置处理器。</p>
<p>（8）解析registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title function_">registerPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> &#123;</span><br><span class="line">    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上述代码中，调用了registry参数的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息，definition参数本质上就是一个AnnotationConfigApplicationContext类的实例对象。最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息。</p>
<p>（9）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法</p>
<p>源码详见：org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition(String beanName, BeanDefinition beanDefinition)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">//##################省略其他代码###############</span></span><br><span class="line">	<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="comment">//##################省略其他代码###############</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可知，向Spring的IOC容器中注册类的Bean定义信息，其实就是向beanDefinitionMap对象中添加元素，beanDefinitionMap对象本质上是一个ConcurrentHashMap对象。向beanDefinitionMap对象中添加的元素的Key为Bean的名称，Value为Bean的定义信息。</p>
<p>beanDefinitionMap源码详见：org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
<p>至此，<code>@Configuration</code>注解涉及到的ConfigurationClassPostProcessor类的注册过程分析完毕。</p>
<h3 id="注册ConfigurationAnnotationConfig流程源码解析"><a href="#注册ConfigurationAnnotationConfig流程源码解析" class="headerlink" title="注册ConfigurationAnnotationConfig流程源码解析"></a>注册ConfigurationAnnotationConfig流程源码解析</h3><p>使用<code>@Configuration</code>注解标注的ConfigurationAnnotationConfig类的Bean定义信息的注册流程的源码执行过程可结合图1-2进行分析，启动Spring IOC容器时，向IOC容器中注册ConfigurationAnnotationConfig类的Bean定义信息的源码执行过程如下所示。</p>
<p>（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法，并进入AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法。</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)方法中调用了register()方法，传入componentClasses参数进行注册。</p>
<p>（2）解析AnnotationConfigApplicationContext类的register(Class&lt;?&gt;… componentClasses)方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#register(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">	<span class="comment">//###########省略其他代码##############</span></span><br><span class="line">    <span class="built_in">this</span>.reader.register(componentClasses);</span><br><span class="line">    <span class="comment">//###########省略其他代码##############</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在register(Class&lt;?&gt;… componentClasses)方法中调用了reader的register()方法。</p>
<p>（3）解析AnnotatedBeanDefinitionReader类的register(Class&lt;?&gt;… componentClasses)方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotatedBeanDefinitionReader#register(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在register(Class&lt;?&gt;… componentClasses)方法中，会循环遍历传入的可变参数componentClasses，每次循环时，都会调用registerBean()方法。</p>
<p>（4）解析AnnotatedBeanDefinitionReader类的registerBean(Class&lt;?&gt; beanClass)方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(Class&lt;?&gt; beanClass)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在registerBean(Class&lt;?&gt; beanClass)方法中调用了doRegisterBean()方法。</p>
<p>5）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class beanClass, String name, Class&lt;? extends Annotation&gt;[] qualifiers, Supplier supplier, BeanDefinitionCustomizer[] customizers)方法。</p>
<p>源码详见：org.springframework.context.annotation.AnnotatedBeanDefinitionReader#doRegisterBean(Class beanClass, String name, Class&lt;? extends Annotation&gt;[] qualifiers, Supplier supplier, BeanDefinitionCustomizer[] customizers)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier, <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(beanClass);</span><br><span class="line">    <span class="comment">//###########################省略其他代码#############################</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line">    <span class="comment">//###########################省略其他代码#############################</span></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在doRegisterBean(Class beanClass, String name, Class&lt;? extends Annotation&gt;[] qualifiers, Supplier supplier, BeanDefinitionCustomizer[] customizers)方法中调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法。</p>
<p>（6）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法</p>
<p>源码详见：org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">//###########################省略其他代码#############################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法中通过调用registry的registerBeanDefinition()方法来向IOC容器中注册Bean定义信息。</p>
<p><strong>注意：到目前为止，后续向IOC容器注册Bean定义信息的源码执行流程与向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息的源码执行流程基本相同，这里不再赘述。</strong></p>
<h3 id="实例化流程源码解析"><a href="#实例化流程源码解析" class="headerlink" title="实例化流程源码解析"></a>实例化流程源码解析</h3><p>Spring IOC容器在刷新时，会实例化使用<code>@Configuration</code>注解标注的类，可结合图1-3-1和图1-3-2理解，具体的源码执行流程如下所示。</p>
<p>（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法，并进入AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法。</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法中会调用refresh()方法刷新IOC容器。</p>
<p>（2）解析AbstractApplicationContext类的refresh()方法</p>
<p>源码详见：org.springframework.context.support.AbstractApplicationContext#refresh()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">           <span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在refresh()方法中调用了invokeBeanFactoryPostProcessors()方法。</p>
<p>（3）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">	<span class="comment">//################省略其他代码####################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法中调用了PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors()方法。</p>
<p>（4）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List beanFactoryPostProcessors)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List beanFactoryPostProcessors)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line">	<span class="comment">//#################省略其他代码##################</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">//#################省略其他代码##################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在invokeBeanFactoryPostProcessors()方法中会解析标注了<code>@Configuration</code>注解的类中标注了<code>@Bean</code>等注解的方法，生成相应的Bean定义信息注册到IOC容器中。这里，主要关注的是标注了<code>@Configuration</code>注解的类的实例化过程，所以，只需要关注invokeBeanFactoryPostProcessors()方法中的上述代码片段即可。</p>
<p>可以看到，在invokeBeanFactoryPostProcessors()方法中又调用了PostProcessorRegistrationDelegate类中的另一个invokeBeanFactoryPostProcessors()方法。</p>
<p>（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">postProcessBeanFactory</span> <span class="operator">=</span> beanFactory.getApplicationStartup().start(<span class="string">&quot;spring.context.bean-factory.post-process&quot;</span>)</span><br><span class="line">            .tag(<span class="string">&quot;postProcessor&quot;</span>, postProcessor::toString);</span><br><span class="line">        postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">        postProcessBeanFactory.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，在invokeBeanFactoryPostProcessors()方法中，会循环遍历传递进来的所有postProcessors集合，每次循环时，都会使用一个postProcessor对象来接收postProcessors集合中的每一个元素，调用postProcessor对象的postProcessBeanFactory()方法，并传入beanFactory来实例化对象。</p>
<p>（6）解析ConfigurationClassPostProcessor类中的postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ImportAwareBeanPostProcessor</span>(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法中调用了enhanceConfigurationClasses()方法。</p>
<p>（7）解析ConfigurationClassPostProcessor类的enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//################省略其他代码########################</span></span><br><span class="line">    <span class="type">ConfigurationClassEnhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassEnhancer</span>();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.getBeanClass();</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">            <span class="comment">//################省略其他代码###################</span></span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhanceConfigClasses.tag(<span class="string">&quot;classCount&quot;</span>, () -&gt; String.valueOf(configBeanDefs.keySet().size())).end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法中，主要是使用ConfigurationClassEnhancer对象的enhance()方法生成代理类，也就是使用CGLib生成代理类。</p>
<p>（8）解析ConfigurationClassEnhancer类的enhance(Class&lt;?&gt; configClass, ClassLoader classLoader)方法</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="comment">//###################省略其他代码###############</span></span><br><span class="line">    Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line">    <span class="comment">//###################省略其他代码###############</span></span><br><span class="line">    <span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在enhance(Class&lt;?&gt; configClass, ClassLoader classLoader)方法中调用了createClass()方法创建代理类，在这之前先调用newEnhancer()方法实例化Enhancer对象。</p>
<p>（9）解析ConfigurationClassEnhancer类的newEnhancer(Class&lt;?&gt; configSuperClass, ClassLoader classLoader)方法</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Enhancer <span class="title function_">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    enhancer.setSuperclass(configSuperClass);</span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="literal">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setAttemptLoad(<span class="literal">true</span>);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">BeanFactoryAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，newEnhancer()方法中主要是生成CGLib动态代理的Enhancer对象，后续会使用Enhancer对象生成代理类。</p>
<p>在newEnhancer()方法中为要生成的代理类设置了父类和接口，由于为要生成的代理类设置的接口为EnhancedConfiguration，同时，EnhancedConfiguration接口继承了BeanFactoryAware接口，所以，在后续生成的代理类中可以调用BeanFactoryAware接口的setBeanFactory(BeanFactory beanFactory)方法获取到beanFactory对象。</p>
<p>（10）解析ConfigurationClassEnhancer类的createClass(Enhancer enhancer)方法</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#createClass(Enhancer enhancer)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createClass(Enhancer enhancer) &#123;</span><br><span class="line">    Class&lt;?&gt; subclass = enhancer.createClass();</span><br><span class="line">    Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在createClass(Enhancer enhancer)方法中，主要调用了enhancer对象的createClass()方法来创建代理类，因为使用CGLib创建出来的代理类是目标类的子类，所以，这里创建出来的代理类就是目标类的子类。</p>
<p>最后，再来关注下Enhancer类中传入的CALLBACKS参数。</p>
<p>（11）解析CALLBACKS</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#CALLBACKS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> <span class="title class_">Callback</span>[] &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BeanMethodInterceptor</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BeanFactoryAwareMethodInterceptor</span>(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，CALLBACKS是一个Callback类型的数组，数组中的每个元素都是一个Callback类型的对象。其中，BeanMethodInterceptor类和BeanFactoryAwareMethodInterceptor类也是拦截器类型。接下来，以BeanMethodInterceptor类为例进行介绍。</p>
<p>（12）解析BeanMethodInterceptor类</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor。</p>
<p>BeanMethodInterceptor实现了MethodInterceptor接口和ConditionalCallback接口，主要的作用就是对标注了@Bean的注解的方法进行拦截，执行intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy)方法，生成Bean的实例对象。在方法中有如下一段代码逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span></span><br><span class="line"><span class="params">					MethodProxy cglibMethodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//如果已经创建了Bean的代理实例对象，则调用父类的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">        <span class="comment">//#################省略其他代码###############</span></span><br><span class="line">        <span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码能够保证在类上添加@Configuration注解后，只会为类生成一个代理对象。也就是说，上述代码的逻辑能够保证标注了@Configuration注解的类生成的代理类是单例模式的。</p>
<p>因为使用CGLib创建出来的代理类是目标类的子类，所以第一次执行上述代码片段时，会调用cglibMethodProxy的invokeSuper()方法执行父类的方法，也就是执行目标类的方法。第二次执行上述代码片段时，会调用resolveBeanReference()方法。</p>
<p>（13）解析BeanMethodInterceptor类的resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor#resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveBeanReference</span><span class="params">(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyInCreation</span> <span class="operator">=</span> beanFactory.isCurrentlyInCreation(beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :</span><br><span class="line">                               beanFactory.getBean(beanName));</span><br><span class="line">       <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，从resolveBeanReference()方法中，会通过beanFactory获取已经初始化好的Bean对象，并将这个已经初始化好的bean对象返回。并不会再进行第二次初始化的操作。</p>
<p>所以，在类上添加<code>@Configuration</code>注解后，Spring能够保证为类生成的代理类是单例的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章，主要对<code>@Configuration</code>注解进行了系统性的介绍。首先，对<code>@Configuration</code>注解进行了简单的说明，包括<code>@Configuration</code>注解的源码和使用场景以及注意事项。随后，给出了<code>@Configuration</code>注解的使用案例，本章的案例主要是针对使用<code>@Configuration</code>注解的一些注意事项给出的案例。接下来，详细介绍了<code>@Configuration</code>注解在Spring源码层面执行的时序图和对应的源码流程。其中，对于注册流程，主要介绍了注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息和ConfigurationAnnotationConfig配置类Bean定义信息的注册时序图和源码执行流程。对于实例化流程，主要介绍了在Spring IOC容器刷新时，实例化ConfigurationAnnotationConfig配置类的代理对象的流程。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>Spring为何在创建IOC容器时先注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息，随后才是注册标注了@Configuration注解的ConfigurationAnnotationConfig配置类的Bean定义信息？</li>
</ul>
<blockquote>
<p>在 Spring 中，创建 IOC 容器时需要注册一些后置处理器，以便在 Bean 实例化之前或之后执行一些额外的逻辑。其中一个后置处理器是 ConfigurationClassPostProcessor，它用于处理带有 @Configuration 注解的配置类。</p>
<p>Spring 在创建 IOC 容器时首先注册 ConfigurationClassPostProcessor 后置处理器的 Bean 定义信息，这是因为该后置处理器需要在容器中注册所有使用了 @Configuration 注解的配置类，并且在这些配置类中查找其他 Bean 的定义信息。</p>
<p>只有在 ConfigurationClassPostProcessor 后置处理器被注册之后，Spring 才会开始扫描标注了 @Configuration 注解的配置类并将其注册为 Bean 定义信息。这样确保了所有使用了 @Configuration 注解的配置类都被正确地处理，并在容器中注册为 Bean 定义信息，以供其他 Bean 进行依赖注入。</p>
</blockquote>
<ul>
<li>Spring为何先将类的Bean定义信息注册到IOC容器？为何不是直接注册实例化后的对象？</li>
</ul>
<blockquote>
<p>Spring 将类的 Bean 定义信息注册到 IOC 容器中，而不是直接注册实例化后的对象，这是因为 Spring 的核心思想是控制反转（IoC）和依赖注入（DI），即将对象之间的依赖关系交由容器管理。</p>
<p>在 Spring 中，所有的 Bean 都必须先定义，然后才能被实例化。这些 Bean 的定义信息包含了如何创建该 Bean 实例的指令，包括构造函数参数、属性值、初始化方法等等。因此，首先需要将类的 Bean 定义信息注册到容器中，以便在需要时可以使用这些信息来实例化对象。</p>
<p>如果直接注册实例化后的对象，则可能会导致一些问题。例如，在进行依赖注入时，可能无法确定对象的依赖关系。另外，如果在实例化对象时出现错误，可能会导致整个系统无法正常工作。因此，将类的 Bean 定义信息注册到 IOC 容器中，可以更好地控制对象的创建和依赖关系。</p>
</blockquote>
<ul>
<li>Spring为何是在刷新IOC容器时，实例化标注了@Configuration注解的配置类的代理对象？为何不是在创建IOC容器时就进行实例化？</li>
</ul>
<blockquote>
<p>在 AnnotationConfigApplicationContext 构造函数中，会先调用父类 AbstractApplicationContext 的构造函数创建一个空的 ApplicationContext 实例，然后调用 register() 方法注册配置类（componentClasses），最后再调用 refresh() 方法刷新容器。</p>
<p>在实际应用中，往往存在多个 @Configuration 注解的配置类，并且这些配置类之间可能存在依赖关系。如果在创建 IOC 容器时就立即实例化这些配置类，那么可能会出现依赖关系无法正确处理的情况。比如，如果 A 配置类依赖于 B 配置类的某个 Bean，而 B 配置类又依赖于 A 配置类的 Bean，那么在创建 IOC 容器时，就无法确定哪个 Bean 应该先被实例化，从而导致出现循环依赖问题。</p>
<p>因此，在 AnnotationConfigApplicationContext 中，Spring 采用了延迟实例化的方式来处理 @Configuration 注解的配置类。在 register() 方法中，会将配置类注册到容器中，并在 refresh() 方法中进行实例化和代理增强，以确保所有的配置类都能够正确地被处理，并且在需要时可以进行代理增强等操作，从而实现 AOP 功能。</p>
</blockquote>
<ul>
<li>Spring IOC容器的这种设计能给你带来哪些启示？</li>
</ul>
<blockquote>
<ol>
<li>控制反转（IoC）和依赖注入（DI）是实现松耦合、提高代码可测试性和可维护性的关键技术。将对象之间的依赖关系转移到容器中进行管理，可以更好地解耦组件之间的关系，提高系统的灵活性和可扩展性。</li>
<li>延迟实例化可以提高应用程序的启动速度和内存占用，避免在容器创建时就进行大量的对象实例化和初始化操作，从而减少启动时间和内存开销。</li>
<li>使用代理模式可以更好地实现面向切面编程（AOP）的功能，通过拦截方法调用，动态地对方法进行增强，从而实现事务管理、安全控制、缓存处理等功能。</li>
<li>面向接口编程可以提高代码的可扩展性和可维护性，利用接口隔离原则可以降低组件之间的耦合度，从而更容易进行模块化和单元测试。</li>
<li>设计模式、面向对象编程思想和一些基本的编码规范能够帮助我们写出可读性高、易于维护和扩展的代码。Spring 框架本身也是一个非常好的代码实践和学习的示例，可以借鉴其中的设计思想和实现方式。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC容器</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java注解</title>
    <url>/posts/Annotation.html</url>
    <content><![CDATA[<h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p>
<ul>
<li><strong>Java自带的标准注解</strong>，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>，<code>@Retention</code>用于标明注解被保留的阶段，<code>@Target</code>用于标明注解使用的范围，<code>@Inherited</code>用于标明注解可继承，<code>@Documented</code>用于标明是否生成javadoc文档。</li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<h3 id="注解的形式"><a href="#注解的形式" class="headerlink" title="注解的形式"></a>注解的形式</h3><p>Java 中，注解是以 <code>@</code> 字符开始的修饰符。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mySuperMethod</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注解可以包含命名或未命名的属性，并且这些属性有值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author(</span></span><br><span class="line"><span class="meta">   name = &quot;Benjamin Franklin&quot;,</span></span><br><span class="line"><span class="meta">   date = &quot;3/27/2003&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个名为 value 的属性，那么名称可以省略，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果注解没有属性，则称为<code>标记注解</code>。如：<code>@Override</code>。</p>
<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>从本质上来说，<strong>注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。</strong></p>
<p>解析一个注解往往有两种形式：</p>
<ul>
<li><strong>编译期直接的扫描</strong> - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。</li>
<li><strong>运行期的反射</strong> - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。</li>
</ul>
<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>注解有许多用途：</p>
<ul>
<li>编译器信息 - 编译器可以使用注解来检测错误或抑制警告。</li>
<li>编译时和部署时的处理 - 程序可以处理注解信息以生成代码，XML 文件等。</li>
<li>运行时处理 - 可以在运行时检查某些注解并处理。</li>
</ul>
<p>作为 Java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。</p>
<h3 id="注解的代价"><a href="#注解的代价" class="headerlink" title="注解的代价"></a>注解的代价</h3><p>凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：</p>
<ul>
<li>显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。</li>
<li>自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。</li>
<li>注解所产生的问题，相对而言，更难以 debug 或定位。</li>
</ul>
<p>但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。</p>
<h3 id="注解的应用范围"><a href="#注解的应用范围" class="headerlink" title="注解的应用范围"></a>注解的应用范围</h3><p>注解可以应用于类、字段、方法和其他程序元素的声明。</p>
<p>JDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：</p>
<p>类实例初始化表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="meta">@Interned</span> MyObject();</span><br></pre></td></tr></table></figure>
<p>类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myString = (<span class="meta">@NonNull</span> String) str;</span><br></pre></td></tr></table></figure>
<p>实现接口的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnmodifiableList</span>&lt;T&gt; implements</span><br><span class="line">    <span class="meta">@Readonly</span> List&lt;<span class="meta">@Readonly</span> T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>抛出异常声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">monitorTemperature</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> <span class="meta">@Critical</span> TemperatureException &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>、<code>@SafeVarargs</code>（JDK7 引入）和<code>@FunctionalInterface</code>（JDK8 引入）：</p>
<ul>
<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>
<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>
<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>
<li><code>@SafeVarargs</code>：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用</li>
<li><code>@FunctionalInterface</code>：用于指示被修饰的接口是函数式接口</li>
</ul>
<p>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</p>
<h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html"><code>@Override</code></a>用于表明被修饰方法覆写了父类的方法。</strong></p>
<p>如果试图使用 <code>@Override</code> 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。</p>
<p>我们先来看一下这个注解类型的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p>
<p><code>@Override</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideAnnotationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;getName&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;override getName&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  放开下面的注释，编译时会告警</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public String getName2() &#123;</span></span><br><span class="line"><span class="comment">            return &quot;override getName2&quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        System.out.println(per.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p><strong><code>@Deprecated</code> 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</strong></p>
<p><code>@Deprecated</code> 有一定的<strong>延续性</strong>：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 <code>@Deprecated</code>，但编译器仍然会告警。</p>
<blockquote>
<p>🔔 注意： <code>@Deprecated</code> 这个注解类型和 javadoc 中的 <code>@deprecated</code> 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。</p>
</blockquote>
<p>这个注解的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p>
<p><code>@Deprecated</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeprecatedAnnotationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeprecatedField</span> &#123;</span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEPRECATED_FIELD</span> <span class="operator">=</span> <span class="string">&quot;DeprecatedField&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeprecatedMethod</span> &#123;</span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DeprecatedMethod&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeprecatedClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DeprecatedClass&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(DeprecatedField.DEPRECATED_FIELD);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeprecatedMethod</span> <span class="variable">dm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeprecatedMethod</span>();</span><br><span class="line">        System.out.println(dm.print());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">DeprecatedClass</span> <span class="variable">dc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeprecatedClass</span>();</span><br><span class="line">        System.out.println(dc.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//DeprecatedField</span></span><br><span class="line"><span class="comment">//DeprecatedMethod</span></span><br><span class="line"><span class="comment">//DeprecatedClass</span></span><br></pre></td></tr></table></figure>
<h3 id="SuppressWarnnings"><a href="#SuppressWarnnings" class="headerlink" title="@SuppressWarnnings"></a>@SuppressWarnnings</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a>用于关闭对类、方法、成员编译时产生的特定警告。</strong></p>
<p><code>@SuppressWarning</code> 不是一个标记注解。它有一个类型为 <code>String[]</code> 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 <code>-Xlint</code> 选项有效的警告名也同样对 <code>@SuppressWarings</code> 有效，同时编译器会忽略掉无法识别的警告名。</p>
<p>这个注解我们也比较常用到，先来看下它的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>原描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>抑制所有警告</td>
<td>to suppress all warnings</td>
</tr>
<tr>
<td>boxing</td>
<td>抑制装箱、拆箱操作时候的警告</td>
<td>to suppress warnings relative to boxing/unboxing operations</td>
</tr>
<tr>
<td>cast</td>
<td>抑制映射相关的警告</td>
<td>to suppress warnings relative to cast operations</td>
</tr>
<tr>
<td>dep-ann</td>
<td>抑制启用注释的警告</td>
<td>to suppress warnings relative to deprecated annotation</td>
</tr>
<tr>
<td>deprecation</td>
<td>使用了不赞成使用的类或方法时的警告</td>
<td>to suppress warnings relative to deprecation</td>
</tr>
<tr>
<td>fallthrough</td>
<td>当 Switch 程序块直接通往下一种情况而没有 Break 时的警告</td>
<td>to suppress warnings relative to missing breaks in switch statements</td>
</tr>
<tr>
<td>finally</td>
<td>任何 finally 子句不能正常完成时的警告</td>
<td>to suppress warnings relative to finally block that don’t return</td>
</tr>
<tr>
<td>hiding</td>
<td>抑制与隐藏变数的区域变数相关的警告</td>
<td>to suppress warnings relative to locals that hide variable（）</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td>忽略没有完整的switch语句</td>
<td>to suppress warnings relative to missing entries in a switch statement (enum case)</td>
</tr>
<tr>
<td>nls</td>
<td>忽略非nls格式的字符</td>
<td>to suppress warnings relative to non-nls string literals</td>
</tr>
<tr>
<td>null</td>
<td>忽略对null的操作</td>
<td>to suppress warnings relative to null analysis</td>
</tr>
<tr>
<td>rawtype</td>
<td>使用generics时忽略没有指定相应的类型</td>
<td>to suppress warnings relative to un-specific types when using</td>
</tr>
<tr>
<td>restriction</td>
<td>抑制与使用不建议或禁止参照相关的警告</td>
<td>to suppress warnings relative to usage of discouraged or</td>
</tr>
<tr>
<td>serial</td>
<td>当在可序列化的类上缺少 serialVersionUID 定义时的警告</td>
<td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td>
</tr>
<tr>
<td>static-access</td>
<td>抑制不正确的静态访问方式警告</td>
<td>to suppress warnings relative to incorrect static access</td>
</tr>
<tr>
<td>synthetic-access</td>
<td>抑制子类没有按最优方法访问内部类的警告</td>
<td>to suppress warnings relative to unoptimized access from inner classes</td>
</tr>
<tr>
<td>unchecked</td>
<td>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型</td>
<td>to suppress warnings relative to unchecked operations</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td>抑制没有权限访问的域的警告</td>
<td>to suppress warnings relative to field access unqualified</td>
</tr>
<tr>
<td>unused</td>
<td>抑制没被使用过的代码的警告</td>
<td>to suppress warnings relative to unused code</td>
</tr>
</tbody>
</table>
</div>
<p><code>@SuppressWarning</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuppressWarningsAnnotationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SuppressDemo</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="keyword">var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuppressDemo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuppressDemo</span>();</span><br><span class="line">        d.setValue(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;地名：&quot;</span> + d.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;uncheck&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InternalAnnotationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@SuppressWarnings</span> 标记消除当前类的告警信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call method1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Deprecated</span> 标记当前方法为废弃方法，不建议使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call method2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Deprecated</span> 标记当前类为废弃类，不建议使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Override</span> 标记显示指明当前方法覆写了父类或接口的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        obj.method1();</span><br><span class="line">        obj.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><p><code>@SafeVarargs</code> 在 JDK7 中引入。</p>
<p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html"><code>@SafeVarargs</code></a>的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。</strong></p>
<p>简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 <code>ClassCastException</code> 异常。</p>
<p><code>@SafeVarargs</code> 注解使用范围：</p>
<ul>
<li><code>@SafeVarargs</code> 注解可以用于构造方法。</li>
<li><code>@SafeVarargs</code> 注解可以用于 <code>static</code> 或 <code>final</code> 方法。</li>
</ul>
<p><code>@SafeVarargs</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeVarargsAnnotationDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法实际上并不安全，不使用此注解，编译时会告警</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongMethod</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">        Object[] array = stringLists;</span><br><span class="line">        List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">        array[<span class="number">0</span>] = tmpList; <span class="comment">// 编译不告警</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 运行时报 ClassCastException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        wrongMethod(list, list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p><code>@FunctionalInterface</code> 在 JDK8 引入。</p>
<p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html"><code>@FunctionalInterface</code></a>用于指示被修饰的接口是函数式接口。</strong></p>
<p>需要注意的是，如果一个接口符合”函数式接口”定义，不加 <code>@FunctionalInterface</code> 也没关系；但如果编写的不是函数式接口，却使用 <code>@FunctionInterface</code>，那么编译器会报错。</p>
<p>什么是函数式接口？</p>
<p><strong>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong>。函数式接口可以被隐式转换为 lambda 表达式。</p>
<p>函数式接口的特点：</p>
<ul>
<li>接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。</li>
<li>不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。</li>
<li>允许有 default 实现方法。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalInterfaceAnnotationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Func1</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(T message)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@FunctionalInterface</span> 修饰的接口中定义两个抽象方法，编译时会报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*@FunctionalInterface</span></span><br><span class="line"><span class="comment">    public interface Func2&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">        void printMessage(T message);</span></span><br><span class="line"><span class="comment">        void printMessage2(T message);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Func1</span> <span class="variable">func1</span> <span class="operator">=</span> message -&gt; System.out.println(message);</span><br><span class="line">        func1.printMessage(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        func1.printMessage(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。</p>
<p><strong>元注解的作用就是用于定义其它的注解</strong>。</p>
<p>Java 中提供了以下元注解类型：</p>
<ul>
<li><code>@Retention</code></li>
<li><code>@Target</code></li>
<li><code>@Documented</code></li>
<li><code>@Inherited</code>（JDK8 引入）</li>
<li><code>@Repeatable</code>（JDK8 引入）</li>
<li><code>@Native</code>（JDK8 引入）</li>
</ul>
<p>这些类型和它们所支持的类在 <code>java.lang.annotation</code> 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html"><code>@Retention</code></a>指明了注解的保留级别。</strong></p>
<blockquote>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p>
</blockquote>
<p><code>@Retention</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<p><code>RetentionPolicy</code> 是一个枚举类型，它定义了被 <code>@Retention</code> 修饰的注解所支持的保留级别：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code> - 标记的注解仅在源文件中有效（源文件保留），编译器会忽略。</li>
<li><code>RetentionPolicy.CLASS</code> - 标记的注解在 class 文件中有效（编译期保留，默认值），JVM 会忽略。</li>
<li><code>RetentionPolicy.RUNTIME</code> - 标记的注解在运行时有效（运行期保留，可通过反射去获取注解信息）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    SOURCE,    <span class="comment">// 源文件保留</span></span><br><span class="line">    CLASS,       <span class="comment">// 编译期保留，默认值</span></span><br><span class="line">    RUNTIME   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SourcePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassPolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RuntimePolicy &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用定义好的三个注解类分别去注解一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetentionTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SourcePolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@ClassPolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@RuntimePolicy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过执行 <code>javap -verbose RetentionTest</code>命令获取到的RetentionTest 的 class 字节码内容如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> retention.RetentionTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sourcePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classPolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">11</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runtimePolicy</span><span class="params">()</span>;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">14</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p>
<ul>
<li>编译器并没有记录下 sourcePolicy() 方法的注解信息；</li>
<li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()</code>方法 和 <code>runtimePolicy()</code>方法 的注解信息；</li>
</ul>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html"><code>@Documented</code></a>表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）。更多内容可以参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html">Javadoc tools page</a>。</p>
<blockquote>
<p>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p>
</blockquote>
<p>以下代码在使用Javadoc工具可以生成<code>@TestDocAnnotation</code>注解信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestDocAnnotation &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestDocAnnotation(&quot;myMethodDoc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoc</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html"><code>@Target</code></a>指定注解可以修饰的元素类型。</strong></p>
<blockquote>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p>
</blockquote>
<p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。</p>
<p><code>@Target</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ElementType</code> 是一个枚举类型，它定义了被 <code>@Target</code> 修饰的注解可以应用的范围：</p>
<ul>
<li><code>ElementType.ANNOTATION_TYPE</code> - 标记的注解可以应用于注解类型。</li>
<li><code>ElementType.CONSTRUCTOR</code> - 标记的注解可以应用于构造函数。</li>
<li><code>ElementType.FIELD</code> - 标记的注解可以应用于字段或属性。</li>
<li><code>ElementType.LOCAL_VARIABLE</code> - 标记的注解可以应用于局部变量。</li>
<li><code>ElementType.METHOD</code> - 标记的注解可以应用于方法。</li>
<li><code>ElementType.PACKAGE</code> - 标记的注解可以应用于包声明。</li>
<li><code>ElementType.PARAMETER</code> - 标记的注解可以应用于方法的参数。</li>
<li><code>ElementType.TYPE</code> - 标记的注解可以应用于类的任何元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line"> </span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类</span></span><br><span class="line"> </span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量）</span></span><br><span class="line"> </span><br><span class="line">    METHOD, <span class="comment">// 成员方法</span></span><br><span class="line"> </span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数</span></span><br><span class="line"> </span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法</span></span><br><span class="line"> </span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量</span></span><br><span class="line"> </span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类</span></span><br><span class="line"> </span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包</span></span><br><span class="line"> </span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Target</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据表名称注解，默认值为类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tableName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;className&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NoDBColumn &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html"><code>@Inherited</code></a>表示注解类型可以被继承（默认情况下不是这样）</strong>。</p>
<blockquote>
<p>Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<p>🔔 注意：<code>@Inherited</code> 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。</p>
<p>此外，当 <code>@Inherited</code> 类型标注的注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，则反射 API 增强了这种继承性。如果我们使用 <code>java.lang.reflect</code> 去查询一个 <code>@Inherited</code> 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<p>我们来测试下这个注解：</p>
<ul>
<li>定义<code>@Inherited</code>注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInheritedAnnotation &#123;</span><br><span class="line">    String[] values();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">number</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用这个注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxxxxxx.TestInheritedAnnotation(values=[value], number=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>即使Student类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类Person被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此Student类自动有了该注解。</p>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html"><code>@Repeatable</code></a>表示注解可以重复使用。</strong>允许在同一申明类型(类，属性，或方法)多次使用同一个注解。</p>
<p>java 8之前也有重复使用注解的解决方案，但可读性不是很好，比如下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseOldVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Authorities(&#123;@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。</p>
<p>我们再来看看java 8里面的做法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Authorities.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</span><br><span class="line">     String <span class="title function_">role</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</span><br><span class="line">    Authority[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatAnnotationUseNewVersion</span> &#123;</span><br><span class="line">    <span class="meta">@Authority(role=&quot;Admin&quot;)</span></span><br><span class="line">    <span class="meta">@Authority(role=&quot;Manager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点。</p>
<h3 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h3><p>使用<code>@Native</code> 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。</p>
<h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><blockquote>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p>
</blockquote>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的相关接口</p>
<ul>
<li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li>
</ul>
<p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p>
<ul>
<li><code>Annotation[] getAnnotations()</code></li>
</ul>
<p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用 <code>@interface</code> 自定义注解时，自动继承了 <code>java.lang.annotation.Annotation</code> 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。<code>@interface</code> 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过 <code>default</code> 来声明参数的默认值。这里，我会通过实现一个名为 <code>RegexValid</code> 的正则校验注解工具来展示自定义注解的全步骤。</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure>
<p>我们来定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RegexValid &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>通过上一节对于元注解 <code>@Target</code>、<code>@Retention</code>、<code>@Documented</code> 的说明，这里就很容易理解了。</p>
<ul>
<li>上面的代码中定义了一个名为 <code>@RegexValid</code> 的注解。</li>
<li><code>@Documented</code> 表示 <code>@RegexValid</code> 应该使用 javadoc。</li>
<li><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</code> 表示 <code>@RegexValid</code> 可以在类成员或方法参数上修饰。</li>
<li>@Retention(RetentionPolicy.RUNTIME) 表示 <code>@RegexValid</code> 在运行时有效。</li>
</ul>
</blockquote>
<p>此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。</p>
<h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p>注解属性的语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问级别修饰符] [数据类型] 名称() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure>
<p>例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🔔 注意：<strong>在注解中，我们定义属性时，属性名后面需要加 <code>()</code></strong>。</p>
</blockquote>
<p>定义注解属性有以下要点：</p>
<ul>
<li><strong>注解属性只能使用 <code>public</code> 或默认访问级别（即不指定访问级别修饰符）修饰</strong>。</li>
<li><strong>注解属性的数据类型有限制要求</strong>。支持的数据类型如下：<ul>
<li>所有基本数据类型（byte、char、short、int、long、float、double、boolean）</li>
<li>String 类型</li>
<li>Class 类</li>
<li>enum 类型</li>
<li>Annotation 类型</li>
<li>以上所有类型的数组</li>
</ul>
</li>
<li><strong>注解属性必须有确定的值，建议指定默认值</strong>。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。</li>
<li>如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两种方式效果相同</span></span><br><span class="line"><span class="meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br><span class="line"><span class="meta">@RegexValid(value = &quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>了解了注解属性的定义要点，让我们来为 <code>@RegexValid</code> 注解定义几个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RegexValid &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Policy</span> &#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        EMPTY(<span class="literal">null</span>),</span><br><span class="line">        DATE(<span class="string">&quot;^(?:(?!0000)[0-9]&#123;4&#125;([-/.]?)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1&quot;</span></span><br><span class="line">            + <span class="string">&quot;(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|&quot;</span></span><br><span class="line">            + <span class="string">&quot;(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))$&quot;</span>),</span><br><span class="line">        MAIL(<span class="string">&quot;^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]&#123;2,&#125;)$&quot;</span>);</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String policy;</span><br><span class="line"></span><br><span class="line">        Policy(String policy) &#123;</span><br><span class="line">            <span class="built_in">this</span>.policy = policy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> policy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Policy <span class="title function_">policy</span><span class="params">()</span> <span class="keyword">default</span> Policy.EMPTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>在上面的示例代码中，我们定义了两个注解属性：<code>String</code> 类型的 value 属性和 <code>Policy</code> 枚举类型的 policy 属性。<code>Policy</code> 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。</p>
</blockquote>
<p>至此，<code>@RegexValid</code> 的声明已经结束。但是，程序仍不知道如何处理 <code>@RegexValid</code> 这个注解。我们还需要定义注解处理器。</p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建与使用注解处理器。JDK5 扩展了反射机制的 API，以帮助程序员快速地构造自定义注解处理器。</p>
<p><strong><code>java.lang.annotation.Annotation</code> 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据</strong>。</p>
<p><code>Annotation</code> 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，Java 中支持<strong>注解处理器接口 <code>java.lang.reflect.AnnotatedElement</code></strong> ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p>
<ul>
<li><code>Class</code> - 类定义</li>
<li><code>Constructor</code> - 构造器定义</li>
<li><code>Field</code> - 类的成员变量定义</li>
<li><code>Method</code> - 类的方法定义</li>
<li><code>Package</code> - 类的包定义</li>
</ul>
<p><code>java.lang.reflect</code> 包下主要包含一些实现反射功能的工具类。实际上，<code>java.lang.reflect</code> 包所有提供的反射 API 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 <code>AnnotatedElement</code> 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的<code>AnnotatedElement</code> 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：</p>
<ul>
<li><code>getAnnotation</code> - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。</li>
<li><code>getAnnotations</code> - 返回该程序元素上存在的所有注解。</li>
<li><code>isAnnotationPresent</code> - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。</li>
<li><code>getDeclaredAnnotations</code> - 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注解直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<p>了解了以上内容，让我们来实现 <code>@RegexValid</code> 的注解处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexValidUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Field[] fields = obj.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 判断成员是否被 @RegexValid 注解所修饰</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(RegexValid.class)) &#123;</span><br><span class="line">                <span class="type">RegexValid</span> <span class="variable">valid</span> <span class="operator">=</span> field.getAnnotation(RegexValid.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> valid.value();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                    RegexValid.<span class="type">Policy</span> <span class="variable">policy</span> <span class="operator">=</span> valid.policy();</span><br><span class="line">                    value = policy.getPolicy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过设置 setAccessible(true) 来访问私有成员</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">fieldObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fieldObj = field.get(obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fieldObj == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                        .append(String.format(<span class="string">&quot;%s 类中的 %s 字段不能为空！&quot;</span>, obj.getClass().getName(), field.getName()));</span><br><span class="line">                    result = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fieldObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (String) fieldObj;</span><br><span class="line">                        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(value);</span><br><span class="line">                        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(text);</span><br><span class="line">                        result = m.matches();</span><br><span class="line">                        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                            sb.append(<span class="string">&quot;\n&quot;</span>).append(String.format(<span class="string">&quot;%s 不是合法的 %s ！&quot;</span>, text, field.getName()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;\n&quot;</span>).append(</span><br><span class="line">                            String.format(<span class="string">&quot;%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！&quot;</span>, obj.getClass().getName(), field.getName()));</span><br><span class="line">                        result = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>以上示例中的注解处理器，执行步骤如下：</p>
<ol>
<li>通过 getDeclaredFields 反射方法获取传入对象的所有成员。</li>
<li>遍历成员，使用 isAnnotationPresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。</li>
<li>如果成员被注解所修饰，通过 <code>RegexValid valid = field.getAnnotation(RegexValid.class);</code> 这样的形式获取，注解实例化对象，然后，就可以使用 <code>valid.value()</code> 或 <code>valid.policy()</code> 这样的形式获取注解中设定的属性值。</li>
<li>根据属性值，进行逻辑处理。</li>
</ol>
</blockquote>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>完成了以上工作，我们就可以使用自定义注解了，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexValidDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="meta">@RegexValid(policy = RegexValid.Policy.DATE)</span></span><br><span class="line">        <span class="keyword">private</span> String date;</span><br><span class="line">        <span class="meta">@RegexValid(policy = RegexValid.Policy.MAIL)</span></span><br><span class="line">        <span class="keyword">private</span> String mail;</span><br><span class="line">        <span class="meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String date, String mail, String phone)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.date = date;</span><br><span class="line">            <span class="built_in">this</span>.mail = mail;</span><br><span class="line">            <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, date=&#x27;&quot;</span> + date + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, mail=&#x27;&quot;</span> + mail + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, phone=&#x27;&quot;</span></span><br><span class="line">                + phone + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDate</span><span class="params">(<span class="meta">@RegexValid(policy = RegexValid.Policy.DATE)</span> String date)</span>&#123;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;1990-01-31&quot;</span>, <span class="string">&quot;xxx@163.com&quot;</span>, <span class="string">&quot;18612341234&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;2019-02-29&quot;</span>, <span class="string">&quot;sadhgs&quot;</span>, <span class="string">&quot;183xxxxxxxx&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (RegexValidUtil.check(user)) &#123;</span><br><span class="line">            System.out.println(user + <span class="string">&quot;正则校验通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RegexValidUtil.check(user2)) &#123;</span><br><span class="line">            System.out.println(user2 + <span class="string">&quot;正则校验通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><h3 id="注解支持继承吗？"><a href="#注解支持继承吗？" class="headerlink" title="注解支持继承吗？"></a>注解支持继承吗？</h3><blockquote>
<p>注解是不支持继承的</p>
</blockquote>
<p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.</p>
<p>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<h3 id="注解实现的原理？"><a href="#注解实现的原理？" class="headerlink" title="注解实现的原理？"></a>注解实现的原理？</h3><ul>
<li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li>
<li><a href="https://www.race604.com/annotation-processing/">https://www.race604.com/annotation-processing/</a></li>
</ul>
<h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><h3 id="配置化到注解化-框架的演进"><a href="#配置化到注解化-框架的演进" class="headerlink" title="配置化到注解化 - 框架的演进"></a>配置化到注解化 - 框架的演进</h3><p>Spring 框架 配置化到注解化的转变。</p>
<h3 id="继承实现到注解实现-Junit3到Junit4"><a href="#继承实现到注解实现-Junit3到Junit4" class="headerlink" title="继承实现到注解实现 - Junit3到Junit4"></a>继承实现到注解实现 - Junit3到Junit4</h3><blockquote>
<p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p>
</blockquote>
<ul>
<li>被测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;hello....&quot;</span>);</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;world....&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Junit 3 实现UT</li>
</ul>
<p>通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> <span class="keyword">extends</span> <span class="title class_">TestCase</span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="built_in">super</span>.setUp();</span><br><span class="line"> 		hw=<span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">//1.测试没有返回值</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			hw.sayHello();</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> 			System.out.println(<span class="string">&quot;发生异常.....&quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span>&#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span>&#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//返回对象</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span>&#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="built_in">super</span>.tearDown();</span><br><span class="line"> 		hw=<span class="literal">null</span>;</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Junit 4 实现UT</li>
</ul>
<p>通过定义@Before，@Test，@After等等注解来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> HelloWorld hw;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Before</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw = <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Test(expected=NumberFormatException.class)</span></span><br><span class="line"> 	<span class="comment">// 1.测试没有返回值,有别于junit3的使用，更加方便</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw.sayHello();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorld</span><span class="params">()</span> &#123;</span><br><span class="line"> 		hw.sayWorld();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 2.测试有返回值的方法</span></span><br><span class="line"> 	<span class="comment">// 返回字符串</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span> &#123;</span><br><span class="line"> 		assertEquals(<span class="string">&quot;测试失败&quot;</span>, hw.say(), <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line"> 	<span class="comment">// 返回对象</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObj</span><span class="params">()</span> &#123;</span><br><span class="line"> 		assertNull(<span class="string">&quot;测试对象不为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"> 		assertNotNull(<span class="string">&quot;测试对象为空&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@After</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		hw = <span class="literal">null</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。</p>
<h3 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h3><blockquote>
<p>最为常见的就是使用Spring AOP切面实现<strong>统一的操作日志管理</strong>，我这里找了一个开源项目中的例子（只展示主要代码），展示下如何通过注解实现解耦的。</p>
</blockquote>
<ul>
<li>自定义Log注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BusinessType <span class="title function_">businessType</span><span class="params">()</span> <span class="keyword">default</span> BusinessType.OTHER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作人类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否保存请求的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现日志的切面, 对自定义注解Log作切点进行拦截</li>
</ul>
<p>即对注解了@Log的方法进行切点拦截，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置织入点 - 自定义注解的包路径</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理完请求后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object jsonResult)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, <span class="literal">null</span>, jsonResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截异常操作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        handleLog(joinPoint, e, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLog</span><span class="params">(<span class="keyword">final</span> JoinPoint joinPoint, <span class="keyword">final</span> Exception e, Object jsonResult)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得注解</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">controllerLog</span> <span class="operator">=</span> getAnnotationLog(joinPoint);</span><br><span class="line">            <span class="keyword">if</span> (controllerLog == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前的用户</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> ShiroUtils.getSysUser();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// *========数据库日志=========*//</span></span><br><span class="line">            <span class="type">OperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperLog</span>();</span><br><span class="line">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br><span class="line">            <span class="comment">// 请求的地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ShiroUtils.getIp();</span><br><span class="line">            operLog.setOperIp(ip);</span><br><span class="line">            <span class="comment">// 返回参数</span></span><br><span class="line">            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));</span><br><span class="line"></span><br><span class="line">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br><span class="line">            <span class="keyword">if</span> (currentUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setOperName(currentUser.getLoginName());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotNull(currentUser.getDept())</span><br><span class="line">                        &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) &#123;</span><br><span class="line">                    operLog.setDeptName(currentUser.getDept().getDeptName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br><span class="line">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置方法名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">            operLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置请求方式</span></span><br><span class="line">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br><span class="line">            <span class="comment">// 处理设置注解上的参数</span></span><br><span class="line">            getControllerMethodDescription(controllerLog, operLog);</span><br><span class="line">            <span class="comment">// 保存数据库</span></span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            <span class="comment">// 记录本地异常日志</span></span><br><span class="line">            log.error(<span class="string">&quot;==前置通知异常==&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;异常信息:&#123;&#125;&quot;</span>, exp.getMessage());</span><br><span class="line">            exp.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注解中对方法的描述信息 用于Controller层注解</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> log 日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog 操作日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getControllerMethodDescription</span><span class="params">(Log log, OperLog operLog)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置action动作</span></span><br><span class="line">        operLog.setBusinessType(log.businessType().ordinal());</span><br><span class="line">        <span class="comment">// 设置标题</span></span><br><span class="line">        operLog.setTitle(log.title());</span><br><span class="line">        <span class="comment">// 设置操作人类别</span></span><br><span class="line">        operLog.setOperatorType(log.operatorType().ordinal());</span><br><span class="line">        <span class="comment">// 是否需要保存request，参数和值</span></span><br><span class="line">        <span class="keyword">if</span> (log.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="comment">// 获取参数的信息，传入到数据库中。</span></span><br><span class="line">            setRequestValue(operLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的参数，放到log中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operLog</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRequestValue</span><span class="params">(OperLog operLog)</span> &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> JSONObject.toJSONString(map);</span><br><span class="line">        operLog.setOperParam(StringUtils.substring(params, <span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在注解，如果存在就获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Log <span class="title function_">getAnnotationLog</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) signature;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> method.getAnnotation(Log.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用@Log注解</li>
</ul>
<p>以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/dept&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;system/dept&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDeptService deptService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增保存部门</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:add&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">addSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;新增部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.insertDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:edit&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">editSave</span><span class="params">(<span class="meta">@Validated</span> Dept dept)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，部门名称已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dept.getParentId().equals(dept.getDeptId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">&quot;修改部门&#x27;&quot;</span> + dept.getDeptName() + <span class="string">&quot;&#x27;失败，上级部门不能是自己&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.updateDept(dept));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE)</span></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;system:dept:remove&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/remove/&#123;deptId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable(&quot;deptId&quot;)</span> Long deptId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deptService.selectDeptCount(deptId) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;存在下级部门,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deptService.checkDeptExistUser(deptId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> AjaxResult.warn(<span class="string">&quot;部门存在用户,不允许删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toAjax(deptService.deleteDeptById(deptId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样的，你也可以看到权限管理也是通过类似的注解（<code>@RequiresPermissions</code>）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E6%B3%A8%E8%A7%A3%E7%AE%80%E4%BB%8B.svg" alt="注解简介"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3.svg" alt="内置注解"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%85%83%E6%B3%A8%E8%A7%A3.svg" alt="元注解"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.svg" alt="自定义注解"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>银行会计学笔记</title>
    <url>/posts/bank2.html</url>
    <content><![CDATA[<h2 id="银行会计基础概念"><a href="#银行会计基础概念" class="headerlink" title="银行会计基础概念"></a><strong>银行会计基础概念</strong></h2><h3 id="会计"><a href="#会计" class="headerlink" title="会计"></a>会计</h3><p>会计是以货币计量为基本形式，应用一整套专门方法，对经济活动的全过程进行核算和监督，为相关各方提供决策所需要的信息。</p>
<h3 id="银行会计"><a href="#银行会计" class="headerlink" title="银行会计"></a>银行会计</h3><p>银行会计是会计学的一个分支，是根据会计学的基本原理和基本方法，针对银行业务的工作特点而制定的特种会计，适用于银行系统的会计核算和经营管理。按照银行的职能划分，会计大致分为三类：中央银行会计、政策性银行会计和商业银行会计。</p>
<blockquote>
<p>会计是以货币形式为基础才产生的，而银行会计是会计学的一个分支，是基于银行的一些业务而特定出来的一个种记账的方式、方法。</p>
</blockquote>
<h3 id="商业银行会计"><a href="#商业银行会计" class="headerlink" title="商业银行会计"></a>商业银行会计</h3><p>商业银行会计与会计一样都是以货币为主要计量单位，基于商业银行的形式、行业策略采用独特的专门方法，对银行的经营活动过程进行连续、全面、系统的核算和监督，为银行的经营管理者及有关方面提供一系列信息的专业会计。</p>
<blockquote>
<p>会计记账最主要的功能是确认、计量、记录和报告。</p>
<ul>
<li>确认是指确认一笔业务的发生；</li>
<li>计量，用它作为一个单位，其实也是用货币作为单位，不管是元还是万元，各种单位都是以货币为基础的；</li>
<li>记录是指，记录业务的发生；</li>
<li>报告是指生成一些报表等用于事后的分析和监管的报送。</li>
</ul>
</blockquote>
<h3 id="会计要素"><a href="#会计要素" class="headerlink" title="会计要素"></a>会计要素</h3><p>会计要素是为了便于确认、计量、记录和报告，必须按照经济业务不同方面的影响而将其分为不同的内容，也就是会计对象的具体内容进行初次的分类，这就形成了会计要素。</p>
<h3 id="银行会计要素"><a href="#银行会计要素" class="headerlink" title="银行会计要素"></a>银行会计要素</h3><p>银行会计要素包括<strong>资产、负债、所有者权益、收入、费用、利润</strong>六项内容，六大要素是银行<strong>会计核算</strong>的基础。银行将按六大会计要素的增减变化进行会计核算、反映和监督，为关注银行的投资者、债权人及有利益相关人员提供有用的经济信息和财务信息。</p>
<p><strong>资产</strong>是指过去的交易、事项形成并由企业拥有或者控制的资源，该资源预期会给企业带来经济利益。资产按其流动性可分为流动资产和非流动资产。</p>
<p><strong>负债</strong>是指过去的交易、事项形成的现时义务，履行该义务预期会导致经济利益流出企业。负债按其流动性可分为流动负债和长期负债。</p>
<p><strong>所有者权益</strong>是指所有者在企业资产中享有的经济利益，其金额为资产减去负债后的余额。商业银行的所有者权益包括实收资本、资本公积、盈余公积和未分配利润。</p>
<p>商业银行的<strong>收入</strong>是指银行在经营融资及其他业务中获得的各种收益，主要包括利息收入、金融企业往来收入、手续费收入、贴现利息收入、汇兑收益和其他业务收入等。</p>
<p><strong>费用</strong>是指商业银行为销售商品、提供劳务等日常活动所发生的经济利益流出。商业银行的费用主要包括利息支出、金融企业往来支出、手续费支出、汇兑损失和其他业务支出等。</p>
<p><strong>利润</strong>是商业银行在一定的会计期间的经营成果，包括营业利润、利润总额和净利润。</p>
<blockquote>
<ul>
<li>资产可以理解成我们所拥有的资源；</li>
<li>负债相对资产来说是它的一个反的方向，指把我们拥有的给到别人，流动负债也可以理解为短期的负债；</li>
<li>所有者权益可以理解为资产减去负债剩余的一些净额；</li>
<li>利润用到了一个<strong>会计期间</strong>的概念，像银行会有比较常用的会计期间有月度和年度的区分，要看我们这个核算的一个会计期间的情况，年度期间核算的是全年的利润，月度期间核算的是本月的利润。</li>
</ul>
</blockquote>
<h2 id="银行会计核算基础"><a href="#银行会计核算基础" class="headerlink" title="银行会计核算基础"></a>银行会计核算基础</h2><p>银行会计核算方法是根据会计的基本方法，结合银行业务活动的特点和经营管理的要求用来反映和监督会计核算对象，完成会计核算任务的手段。</p>
<p>构成：由基本核算方法和业务处理方法构成。</p>
<p>基本核算方法包括会计科目与账户的设置、记账方法的确定、会计凭证的填制、账簿的登记和报表的编制。</p>
<h3 id="会计科目"><a href="#会计科目" class="headerlink" title="会计科目"></a>会计科目</h3><p>会计科目是会计核算工作的基础，不仅可以对经济业务进行科学的分类，为管理提供各项分类核算的数据，还为正确应用一系列会计核算方法如填制会计凭证、登记账簿、编制会计报表等提供了理论依据。</p>
<p>会计科目是对会计要素按其经济内容和用途所作的进一步分类，它是设置账户、处理账务所必须遵守的规则和依据。</p>
<p>银行会计科目是对银行会计对象的具体内容即银行会计要素所作的进一步分类。</p>
<h4 id="银行会计科目分类"><a href="#银行会计科目分类" class="headerlink" title="银行会计科目分类"></a>银行会计科目分类</h4><p><strong>银行会计科目按资金性质分为四大类</strong><br>1、资产类科目：包括各种资产、债权和其他权利，分为流动资产、长期投资、固定资产、无形资产、递延资产。</p>
<p>2、负债类科目：负债是形成银行资产的主要来源，分为流动负债、长期负债。</p>
<p>3、所有者权益科目：反映银行投资者对银行净资产的所有权包括实收资本、资本公积、盈余公积、本年利润、利润分配。</p>
<p>4、损益类科目：反映银行财务收支及经营损益。</p>
<p><strong>按与资产负债表、损益表的关系分为表内科目和表外科目</strong></p>
<ol>
<li><p>表内科目一一用以反映涉及银行资金实际增减变动的会计事项，从而纳入资产负债表内的会计科目。如资产类、负债类、所有者权益类、损益类会计科目。如下表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E8%A1%A8%E5%86%85%E7%A7%91%E7%9B%AE.png" alt="表内科目"></p>
</li>
<li><p>表外科目一一用以反映不涉及银行资金实际增减变动的重要业务事项，从而不纳入资产负债表内的会计科目。如:“应收未收利息”“”“重要空白凭证”“逾期贷款应收未收利息等。</p>
</li>
</ol>
<p><strong>按经济内容分</strong></p>
<ol>
<li>资产类</li>
<li>负债类</li>
<li>资产负债共同类</li>
<li>所有者权益类</li>
<li>损益类科目</li>
</ol>
<h3 id="记账方法"><a href="#记账方法" class="headerlink" title="记账方法"></a>记账方法</h3><p>记账方法是根据一定的记账原理和规则，以货币为计量单位，采用记账符号，将发生的经济业务按会计科目进行整理、分类和登记会计账簿的一种专门方法。</p>
<h4 id="银行会计记账方法的种类"><a href="#银行会计记账方法的种类" class="headerlink" title="银行会计记账方法的种类"></a>银行会计记账方法的种类</h4><p>银行会计记账方法按记账方式的不同，分为<strong>单式记账法</strong>和<strong>复式记账法</strong>。</p>
<p><strong>单式记账法：</strong>是指对发生的每一笔经济业务只在一个账户进行登记的记账方法，是一种比较简单的、不完整的记账方法<br>目前，银行会计表外科目采用单式收付记账方法即业务发生时记收入，业务注销或冲减时记付出，余额反映未销数额。</p>
<p><strong>复式记账法：</strong>是指对发生的每笔经济业务，都以相等的金额，在相互联系的两个或两个以上的账户中同时进行登记，全面反映经济业务来龙去脉的记账方法。目前，银行会计表内科目采用复式借贷记账方法。<br><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230404153632987.png" alt="image-20230404153632987"></p>
<h4 id="借贷记账法"><a href="#借贷记账法" class="headerlink" title="借贷记账法"></a>借贷记账法</h4><p><strong>借贷记账法</strong>是以资产负债平衡原理为依据，以“借”“贷”为记账符号，以“有借必有贷，借贷必相等”为记账规则，用以记录和反映会计要素增减变化过程及其结果的一种复式记账方法。</p>
<p><strong>(一) 记账主体</strong><br>借贷记账法是以会计科目为主，按照复式记账法原理将反映银行会计对象的会计科目分为资产类、负债类、资产负债共同类、所有者权益类和损益类五个类别。</p>
<p><strong>(二) 记账符号</strong>：“借”和“贷”、左边为借方 右边为贷方</p>
<p><strong>资产类账户：</strong>借方记资产增加，贷方记资产减少，余额一般在借方;<br><strong>负债及所有者权益类账户：</strong>贷方记增加，借方记减少，余额一般在贷方;</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230404154128602.png" alt="image-20230404154128602"></p>
<p><strong>损益类账户中费用类账户：</strong>借方记增加，贷方记减少，期末结转后无余额;<br><strong>资产负债共同类账户：</strong>资产增加数和负债减少数记借方，资产减少数和负债增加数记记贷方。</p>
<p><strong>(三) 记账规则:“有借必有贷，借贷必相等”</strong></p>
<p>一笔经济业务的发生，必须以相等的金额记入一个账户的借方和另一个账户(或几个账户) 的贷方；或记入一个账户的贷方和另一个账户(或几个账户) 的借方。须注意: 不可以多借多贷</p>
<p><strong>(四)借贷记账法试算平衡</strong><br>1、发生额试算平衡公式<br>全部科目<strong>本期</strong>借方发生额合计=全部科目<strong>本期</strong>贷方发生额合计<br>2、余额试算平衡公式:<br>全部科目借方余额合计=全部科目贷方余额合计</p>
<h3 id="会计凭证"><a href="#会计凭证" class="headerlink" title="会计凭证"></a>会计凭证</h3><h4 id="银行会计凭证的含义"><a href="#银行会计凭证的含义" class="headerlink" title="银行会计凭证的含义"></a>银行会计凭证的含义</h4><p>会计凭证是记录经济业务，明确经济责任，具有法律效力的书面证明，是登记账簿的依据。<br>银行会计凭证是银行各项业务和财务收支发生的书面证明，是银行办理货币资金收付和记账的依据，也是明确经济责任、核对账务和事后检查的依据。</p>
<h4 id="会计凭证的分类"><a href="#会计凭证的分类" class="headerlink" title="会计凭证的分类"></a>会计凭证的分类</h4><ul>
<li><p>按填制程序和用途分为<strong>原始凭证</strong>和<strong>记账凭证</strong><br><strong>原始凭证：</strong>是在经济业务发生时，直接取得或编制的会计凭证。按其取得的来源不同，又分为<strong>外来原始凭证</strong>和<strong>自制原始凭证</strong>。<br><strong>记账凭证：</strong>是会计人员根据审核无误的原始凭证，加以归类整理而编制的会计凭证。<strong>银行的记账凭证</strong>由于需要在银行内部的不同部门之间传递，所以俗称“传票”。</p>
</li>
<li><p>按外表形式分为<strong>单式记账凭证</strong>和<strong>复式记账凭证</strong></p>
</li>
<li><p>按使用范围</p>
<p><strong>基本凭证：</strong>现金收入传票 、现金付出传票 、转账借方传票 、转账贷方传票 、特种转账借方传票、特种转账贷方传票 、表外科目收入传票 、表外科目付出传票<br><strong>专用凭证：</strong>支票、现金缴款单、联行报单、本票汇票等。</p>
</li>
<li><p>按重要程度分为一般凭证和重要凭证</p>
</li>
</ul>
<h4 id="会计凭证的基本要素"><a href="#会计凭证的基本要素" class="headerlink" title="会计凭证的基本要素"></a>会计凭证的基本要素</h4><p>（一）会计凭证的填制</p>
<p>1、银行会计凭证的基本要素</p>
<ul>
<li>年、月、日</li>
<li>收、付款人的户名和账号</li>
<li>收、付款人开户银行的名称和行号</li>
<li>人民币或外币符号和大小写金额</li>
<li>款项来源、用途或摘要、附件张数</li>
<li>会计分录和凭证编号</li>
<li>客户按照有关规定加盖的印章</li>
<li>经办银行及有关人员的印章</li>
</ul>
<p>2、银行会计凭证的填制</p>
<ul>
<li>要素齐全、内容完整、及时真实、数字正确、字迹清楚</li>
<li>单联式用墨汁书写、多联式用圆珠笔套写</li>
<li>符号规定: #、@、￥、年/月/日，%、%。</li>
<li>阿拉伯数字和汉字大写金额的书写</li>
<li>金额大写:零、壹、贰、叁、肆、伍、陆柒、捌、玖、拾、佰、仟、万、亿</li>
<li>票据出票日期必须大写</li>
</ul>
<p>必须由专人或者相互交叉严格审核。主要审核会计凭证的真实性、正确性、合法性和完整性。</p>
<ul>
<li>是否应为本行受理的凭证</li>
<li>使用凭证的种类是否正确，内容、联数与附件是否完整齐全是否超过有效期限</li>
<li>账号与户名是否相符</li>
<li>大小写金额是否一致，字迹有无涂改</li>
<li>取款是否超过存款余额，贷款是否超过额度</li>
<li>密押、印鉴是否真实、齐全</li>
<li>款项来源、用途是否符合政策、法规和信贷、结算管理原则</li>
<li>计息、收费、赔偿金的计算是否正确</li>
<li>内部科目的账户名称使用是否正确</li>
</ul>
<h4 id="会计凭证的传递"><a href="#会计凭证的传递" class="headerlink" title="会计凭证的传递"></a>会计凭证的传递</h4><p>各类业务凭证传递的基本程序是：<br>1、编制并审核会计凭证。<br>2、根据凭证登记明细账。</p>
<p><strong>必须符合下列规定：</strong></p>
<p>现金收入业务凭证，必须“先收款、后记账”</p>
<p>现金付出业务凭证，必须先“先记账、后付款”</p>
<p>转账业务凭证，必须先记付款单位账户，后记收款单位账户；贯彻银行不垫款原则。<br>3、编制科目日结单，登记总账</p>
<p><strong>传递的原则：</strong>准确及时、手续严密、先外后内、先急后缓</p>
<h4 id="会计凭证的整理-装订与保管"><a href="#会计凭证的整理-装订与保管" class="headerlink" title="会计凭证的整理 装订与保管"></a>会计凭证的整理 装订与保管</h4><p>1、<strong>多采用单式凭证</strong><br>2、<strong>原始凭证可代替记账凭证。</strong>银行大量以客户提交的原始凭证代替记账凭证作为记账的依据。</p>
<h3 id="财务组织"><a href="#财务组织" class="headerlink" title="财务组织"></a>财务组织</h3><p>账务组织是指根据凭证对经济业务核算时，从账簿的设置、记账程序，到账务平衡，编制出会计日报表为止，整个核算过程中各种方法相互配合所形成的核算体系。</p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>银行</tag>
      </tags>
  </entry>
  <entry>
    <title>银行的主营业务和运营模式</title>
    <url>/posts/bank.html</url>
    <content><![CDATA[<h3 id="什么是银行"><a href="#什么是银行" class="headerlink" title="什么是银行?"></a>什么是银行?</h3><p>银行（Bank），是依法成立的经营货币信贷业务的金融机构，是商品货币经济发展到一定阶段的产物。</p>
<p>银行是金融机构之一，银行按类型分为：中央银行、政策性银行、商业银行、专营机构、投资银行、世界银行，它们的职责各不相同。</p>
<ul>
<li><p><strong>中央银行</strong>：即中国人民银行是我国的中央银行。</p>
<p>中央银行（Central Bank）是国家中居主导地位的金融中心机构，是国家干预和调控国民经济发展的重要工具。负责制定并执行国家货币信用政策，独具货币发行权，实行金融监管。<br>中国的中央银行为中国人民银行，简称央行。</p>
</li>
<li><p><strong>国有政策性银行</strong>：包括中国进出口银行、中国农业发展银行、国家开发银行。 </p>
<p>职责：参股或保证的，不以营利为目的，专门为贯彻、配合政府社会经济政策或意图，在特定的业务领域内，直接或间接地从事政策性融资活动，充当政府发展经济、促进社会进步、进行宏观经济管理工具的金融机构。</p>
</li>
<li><p><strong>国有商业银行</strong>：包括中国工商银行、中国农业银行、中国银行、中国建设银行、中国邮政储蓄银行、交通银行等。 </p>
<p>职责：通过存款、贷款、汇兑、储蓄等业务，承担信用中介的金融机构。商业银行是金融机构之一，而且是最主要的金融机构，商业它主要的业务范围有吸收公众存款、发放贷款以及办理票据贴现等。</p>
</li>
<li><p><strong>专营机构</strong>：指商业银行针对本行某一特定领域业务所设立的、有别于传统分支行的机构；</p>
</li>
<li><p><strong>投资银行</strong>：包括高盛集团、摩根士丹利、花旗集团、富国银行、瑞银集团、法国兴业银行等。</p>
<p>职责：从事证券发行、承销、交易、企业重组、兼并与收购、投资分析、风险投资、项目融资等业务的非银行金融机构。</p>
</li>
<li><p><strong>世界银行</strong>：用于资助国家克服穷困，各机构在减轻贫困和提高生活水平的使命中发挥独特的作用。</p>
</li>
</ul>
<h3 id="银行的主营业务"><a href="#银行的主营业务" class="headerlink" title="银行的主营业务"></a>银行的主营业务</h3><p>主要分为负债业务、资产业务、中间业务三大类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230410191725733.png" alt="image-20230410191725733"></p>
<p><strong>一、商业银行的负债业务</strong></p>
<p>商业银行的负债是商业银行筹措资金，借以形成资金来源的业务，是商业银行资产业务和其他业务的基础。金融行业之所以称银行为“金主”，首要的原因便是银行的资金吸收能力无比强大。</p>
<p>商业银行负债主要分为储蓄存款、对公存款、同业存款、同业拆借、向中央银行借款、金融债券、回购协议等。</p>
<p>在各类负债业务中，存款是最为核心的业务，主要包括对公存款和储蓄存款。储蓄存款为银行带来了长期稳定的资金流，同业存放、同业拆入、向中国人民银行借款及债券融资也是重要的资金来源渠道。发行金融债券、大额可转让定期存单，以及出售或发行商业票据等新业务也日益成为负债业务发展的增长点。商业银行负债风险则包括流动性风险、利率风险和清偿性风险。总之，银行资金来源渠道多元化，而且储蓄存款作为低成本资金来源占比较大。</p>
<p><strong>二、商业银行的资产业务</strong></p>
<p>商业银行资产业务，是指商业银行运用资金的业务，也就是商业银行将其吸收的资金贷放或投资出去赚取收益的活动。</p>
<p><strong>商业银行的资产结构具有以下特点：</strong></p>
<p>第一，金融资产占据了绝大部分的比重；</p>
<p>第二，各项贷款是最重要的盈利性资产；</p>
<p>第三，现金类资产是银行最有意义的资产。</p>
<p>商业银行盈利状况如何、经营是否成功，很大程度上取决于资金运用的结果，其中以贷款和投资最为重要。金融行业之所以称银行为“金主”，银行的资金投资规模无与伦比也是一大原因。</p>
<p>贷款，即按一定利率和确定的期限贷出货币资金的信用活动，是商业银行资产业务中最重要的项目，在资产业务中所占比重最大，因此存贷款之间的利差是商业银行最重要的利润来源之一。</p>
<p>常见的贷款形式主要有：信用贷款、普通借款限额、透支贷款、备用贷款承诺、消费者贷款、票据贴现贷款、保证书担保贷款等。商业银行的投资业务按照所投标的类型的不同可以分为标准化资产业务与非标准化资产业务。</p>
<p>标准化资产是指在银行间市场、交易所市场等公开市场发行及转让的资产，以债券为典型代表；除此之外均为非标准化资产，例如各种受益权和结构化产品。</p>
<p><strong>三、商业银行的中间业务</strong></p>
<p>商业银行中间业务是指其从事的不在资产负债表内反映的业务，商业银行中间业务收入是指各类中间业务所带来的营业收入。由于中间业务不占用银行自有资金，经营风险较小、相对可持续发展，中间业务收入及其占营业收入的比重被认为是衡量商业银行收入结构优劣的重要指标。</p>
<p>发达国家商业银行中间业务收入占其营业收入比重一般在40%以上，欧洲一些全能银行更高达70%以上，而我国商业银行目前一般为20%左右，主要原因在于国内商业银行的盈利模式仍然以传统的利差收入为主导。</p>
<p>当然，国内商业银行仍然以利差收入为主要盈利模式，一方面是由于商业银行大多为国有体制背景，缺乏积极创新推动的动力，另一方面是由于我国金融业实行分业经营，银行拓展业务的空间有限。</p>
<p>中间业务大体上分为支付结算类中间业务、银行卡业务、代理类中间业务、担保类中间业务、承诺类中间业务、交易类中间业务、基金托管业务、咨询顾问类业务和其他类中间业务。</p>
<p>中间业务资本占用少、风险小、客户黏性高、收益稳定性强，其发展水平的高低，很大程度上已成为衡量一家银行客户服务能力、市场竞争能力和金融创新能力的显著标志。</p>
<p>例如，银行多年的业务经营积累了得天独厚的客户资源，通过与券商投行部门的合作，商业银行参与各类债券的前期承揽与后期的资金监管，可以获得承销费分成与资金托管费双重收入。</p>
<h3 id="银行的运营模式"><a href="#银行的运营模式" class="headerlink" title="银行的运营模式"></a>银行的运营模式</h3><p>银行是一家金融机构，其主要业务是接受客户存款并向客户提供贷款和其他金融服务，以及进行投资、外汇交易等业务。银行通过吸收存款和发放贷款的方式，实现资金的调剂和流通，从而促进经济的发展。</p>
<p>以下是银行运作的主要步骤：</p>
<ol>
<li><strong>吸收存款：</strong>银行通过向客户提供安全可靠的存款服务，吸收存款并支付一定的利息作为回报。存款是银行获得资金的主要渠道之一，用于向其他客户提供贷款以及进行其他投资活动。</li>
<li><strong>发放贷款：</strong>银行向客户提供贷款，以获得更高的利润。贷款可以是个人贷款、商业贷款、房屋贷款等。银行在发放贷款时，会对客户的信用记录、收入状况和借款目的等进行评估，并收取一定的利息作为贷款回报。</li>
<li><strong>投资：</strong>银行可以进行各种类型的投资，包括股票、债券、房地产和其他金融产品等。投资可以带来更高的回报，但也伴随着更高的风险。银行需要在投资时进行风险评估，并制定相应的风险管理策略。</li>
<li><strong>外汇交易：</strong>银行可以进行外汇交易，即买卖不同货币之间的汇率。这可以带来更高的利润，但也伴随着更高的风险。银行需要在外汇交易时进行风险评估，并制定相应的风险管理策略。</li>
<li><strong>其他金融服务：</strong>银行可以提供其他金融服务，如信用卡、汇票、保险、基金等。这些服务可以帮助银行获得额外的收入，同时也可以提供方便的金融工具给客户。</li>
</ol>
<p>银行运作的主要目标是实现资金的调剂和流通，同时为客户提供各种金融服务，以获得利润和推动经济的发展。</p>
<h3 id="银行核心系统"><a href="#银行核心系统" class="headerlink" title="银行核心系统"></a>银行核心系统</h3><p>银行核心系统，又称核心银行系统、银行综合业务系统、银行核心账务系统，英文名称：Core Banking System，是以客户为中心，进行帐务处理、满足综合柜员制、并提供24小时服务的支撑银行日常经营活动的主要应用系统。</p>
<p>不同层次、不同类型和不同规模的银行，在银行核心系统建设上的进展状况也有所不同，一般可以分为五个阶段：PC单机、联网联机、数据大集中、瘦核心大外围、分布式微服务。</p>
<h4 id="瘦核心"><a href="#瘦核心" class="headerlink" title="瘦核心"></a>瘦核心</h4><p>经过全国大集中的建设，银行系统集中带来了很多优势，同时也带来了一些问题。</p>
<p>系统集中后，纳入了越来越多的功能以及地方特色，导致了后台系统越来越庞大，耦合严重，难以修改维护，开发新的功能耗时越来越长。因此，这个阶段以前的银行核心系统，也叫“综合业务系统”，综合实现了银行的各种业务功能。</p>
<p>为了解决系统庞大耦合的问题，业内一致开展了核心系统瘦身的运动，喊出了“瘦核心，大外围”的口号。从系统结构上，不断从核心中拆分管理功能建立各类管理系统，分析统计功能建立数据仓库，报表功能建立报表系统，第三方对接建立各类前置系统、中间业务系统。为了这些系统的连接，建立了ESB服务总线，为了各系统客户信息统一共享，建立了ECIF全行级客户信息系统。甚至一些激进的银行，将核心账务内容也分开，建立贷款系统，存款系统，以及互联网核心系统等，并配套总账系统汇总处理各账务系统的会计流水。</p>
<p>除了核心功能瘦身，内部实现上也全面转向了以客户为中心，引入产品工厂，定价模型等参数化、配置化，使得核心系统灵活性、健壮性大大提升。</p>
<p>由一定的编码规则生成系统唯一的<strong>客户号</strong>，再通过客户号管理同一客户下的各账号，建立统一的客户信息视图，打破原有客户群各自封闭的情况，实现银行的服务理念从“以账户为中心”向“以客户为中心”的转变。</p>
<p>以客户为中心（支持复杂的关联关系），如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/640.jpg" alt="640"></p>
<p>系统参数的灵活配置实现产品特色化，为客户提供利率、费率及汇率的差异化定价，并将客户之间的关系进行归集（如：针对集团客户可归集其下辖各子公司的账户），实现客户与账户的多层级管理，掌握客户每笔交易的资金动态和流向等。</p>
<p>通过对客户需求的聚焦，进而对指定客户群或是个别优质的客户提供有针对性的服务，在吸引新客户和留住老客户的同时，也为今后业务的发展奠定了坚实的基础。</p>
<h4 id="分布式微服务"><a href="#分布式微服务" class="headerlink" title="分布式微服务"></a>分布式微服务</h4><p>2015年作为民营银行元年，网商银行2015年6月，微众银行2015年9月正式开业。拥有互联网基因的民营银行，采用了去IOE的分布式微服务架构来建设核心系统，提供了一种新的设计思路。近年来，随着监管要求国产化的推进，而国产化在大型机方向上的缺乏，分布式核心系统出镜率越来越高。</p>
<p>分布式核心系统是与集中式核心系统相对的，有好几种组建模式。特别值得注意的是，分布式和微服务是两个不同的概念，不能混为一谈。</p>
<p><strong>分布式</strong>是指核心系统对存储数据使用多机进行分片，目的有两个：</p>
<p>一是突破单机系统的数据存储和数据处理能力上限，使得数据量规模可以横向扩展。</p>
<p>二是分片后减小单台机器设备突发故障的影响面，使得一个故障只影响一个分片的机器，而其他分片可以照常处理。这样就不算系统整体中断服务。</p>
<p><strong>微服务</strong>是指核心系统按照功能模块进行服务拆分，单独打包部署，将整个核心分成一个个小块，目的是解决模块间耦合问题，以期降低系统修改时的影响范围和难度。</p>
<h3 id="存款种类的分类"><a href="#存款种类的分类" class="headerlink" title="存款种类的分类"></a>存款种类的分类</h3><p>首先按照期限，可以将存款划分为活期存款（指单位有权随时支取或用于结算的款项）和定期存款。定期存款有许多种类，我们来分析一下。</p>
<p><strong>第一个：整存整取。</strong>整存整取是一次性存入一笔钱，到期之后一起去取本金和利息。这种存款方式是期限越长，利息越高。根据不同银行规定，是否可以提前支取是不一样的，有的银行可以无限次的提前支取、有的银行可以支取两次、有的银行甚至规定不到期是不可以提前支取的。根据银行存款模式不同，整存整取存款期限，一般分为三个月、半年、一年、两年、三年和五年。</p>
<p><strong>第二个：零存整取。</strong>零存整取是每个月存固定数量的钱，到期后一次性还本付息。什么叫到期呢？就是你提前设定的一次性取钱的期限。分为一年，三年，五年。零存整取有它的利和弊，如果你不能坚持每个月存同样数量的钱，可能你有几个月没存，那这个存款就失效了。或者当你想提前支取的时候，那么这个存款是完全按照活期计息的，不可以部分提前支取，只是他的缺点。它的优点是有利于养成很好的储蓄计划，养成存钱的习惯。不同银行零存整取的利息是不一样的，你可以选择比较合适的银行去办这个业务。</p>
<p><strong>第三个：整存零取。</strong>正好和零存整取是相反的事，整存零取是存入一笔钱之后，每个月都可以取出相关的利息，正好可以补充资金流的不足。</p>
<p><strong>第四个：存本取息。</strong>是存了一笔钱之后，以后逐月的领取利息，到期之后拿到的是本金。有人问：“存本取息和零存整取有什么区别吗？”零存整取，取的是本金和利息之和的一部分。比如存一年期，本金加利息除以12，就是每个月取的。存本取息是一次性存入本金，那么本金是不动的，以后逐月领取的是利息。</p>
<p><strong>第五个：定活两便。</strong>是灵活性比较大的一种存款，在存款期内不约定期限的时候，支取时按照一年以内的定期整存整取同期次打六折、有的银行更好了，两年以上打六折，不同银行的规定不同，但是大部分银行执行的是一年以内，按照整存整取同期次靠档计息打六折，也就说当存到第八个月，我想取的时候，是按照六个月的利息去给我计息，但是要打六折给我这个利息。也有的银行业务开展得非常灵活，时间比较长的也有。</p>
<p><strong>定活两便储蓄存款是一种不确定存款期限，利率随存期长短而变动的介于活期和定期之间的储蓄方式，起存金额为50元。其产品特点和计息方式如下表所示。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411101035484.png" alt="image-20230411101035484"></p>
<p><strong>第六个：通知型存款。</strong>一般分为一天通知和七天通知存款。目前市面上常见的是智能型通知存款，当你想取钱的时候可以直接取出来，而不需要向银行打招呼去通知，特点是比活期利息高，但是不如天天理财利息高。它只是一种比活期利息更高的出款形式。但是它的优点就在于非常灵活。</p>
<p><strong>第七个：教育型存款。</strong>是一种特殊的零存整取的定期储蓄存款。针对人群一般是学校四年级以上的学生，一般分为一年期、三年期、六年期，本金最高也只能有两万元，这个一般适合给孩子形成一种很好的储蓄习惯。它在利息方面，没什么优势可谈，但是它作为存款的一种类型是存在的。</p>
<p><strong>第八个：大额存单。</strong>今天我们介绍的都是常规的存款品种，<strong>还有一种存款，是现在比较新兴的，是2015年6月15日正式推出的大额存单。</strong>大额存单是银行业存款机构向个人或其它机构企业发行的一种存款凭证。可以理解它是一种存款凭证。大额存单与存款不同的地方在于，大额存单在到期之前可以转让，可以交易转让的金额为整数，那么利率一定是比正常的存单利率要高一些。不同银行浮动的利率是不一样的，大额存单起点是比较高的，对一些高端客户实现投资回报，相对比普通存款高一些。至于回报到底是多高？这取决于不同的银行，有的银行在这方面回报确实是特别高，有的银行并不是比一般的存款高很多。所以大额存单是在金融市场，算是一个比较新兴的，逐步在代替一些高负载型的产品，高利息负载的产品对于降低社会融资成本，具有非常积极的意义。</p>
<h3 id="对公和个人结算账户的分类和管理办法"><a href="#对公和个人结算账户的分类和管理办法" class="headerlink" title="对公和个人结算账户的分类和管理办法"></a>对公和个人结算账户的分类和管理办法</h3><h4 id="对公结算账户"><a href="#对公结算账户" class="headerlink" title="对公结算账户"></a>对公结算账户</h4><p>存款人以单位名称开立的银行结算账户为单位银行结算账户，也称<strong>对公结算账户</strong>。单位银行结算账户按用途分为基本存款账户、一般存款账户、专用存款账户、临时存款账户。</p>
<p>对公结算账户就是企业银行结算账户，是存款人以企业的名称或是单位的名称开设的银行结算账户，对于个体工商户来说，必须要凭借着营业的执照以及字号对经营者的姓名来开设的银行结算账户，并对结算账户的交纳单位银行进行结算的账户进行全面的管理。</p>
<p><strong>账户要求：</strong></p>
<ol>
<li>基本存款账户是存款人因办理日常转账结算和现金收付需要开立的银行结算账户。</li>
<li>一般存款账户是存款人因借款或其它结算需要，在基本存款账户开户银行以外的银行营业机构开立的银行结算账户。</li>
<li>专用存款账户是存款人按照法律、行政法规和规章，对其特定用途资金进行专项管理和使用而开立的银行结算账户</li>
<li>临时存款账户是存款人因临时需要并在规定期限内使用而开立的银行结算账户。<br>同时，还规定：<ol>
<li>单位银行结算账户的存款人只能在银行开立一个基本存款账户。</li>
<li>基本存款账户是存款人的主办账户。存款人日常经营活动的资金收付及其工资、奖金和现金的支取，应通过该账户办理。</li>
<li>一般存款账户用于办理存款人借款转存、借款归还和其它结算的资金收付。该账户可以办理现金缴存，但不得办理现金支取。</li>
</ol>
</li>
</ol>
<h4 id="个人结算账户"><a href="#个人结算账户" class="headerlink" title="个人结算账户"></a>个人结算账户</h4><p>个人银行结算账户，是自然人以身份证或是相应的证件，因投资、消费、结算等而开立的可办理支付结算业务的银行结算帐户。建立个人银行账户分类管理机制，即在现有个人银行账户基础上，增加银行账户种类，将个人银行账户分为Ⅰ类银行账户、Ⅱ类银行账户、Ⅲ类银行账户（以下分别简称Ⅰ类户、Ⅱ类户、Ⅲ类户），不同类别的个人银行账户有不同的功能和权限。</p>
<p><strong>三类个人银行账户的功能区分</strong></p>
<p>Ⅰ类账户属于全功能的银行结算账户，Ⅱ类账户满足直销银行、网上理财产品等支付需求，Ⅲ类账户则主要用于快捷支付，比如“闪付”“免密支付”等；</p>
<p>Ⅰ类户可用于办理存款、购买投资理财产品、转账、消费和缴费支付、支取现金等业务；</p>
<p>Ⅱ类户可用于办理存款、购买投资理财产品、限定金额的消费和缴费支付等业务；单日累计支付额度不超过10000元；</p>
<p>Ⅲ类户可用于办理限定金额的消费和缴费支付服务；账户余额不得超过2000元；</p>
<p><strong>个人银行结算账户使用中应注意的问题：</strong><br>单位从银行结算账户支付给个人银行结算账户的款项，每笔超过5万元的，应向其开户银行提供完税证明（即对应前面个人银行结算账户使用范围的相关证明）<br>从单位银行结算账户支付给银行结算账户的款项应纳税的，税收代扣单位付款时，应向其开户银行提供完税证明。<br>个人持出票人为单位的支票向开户银行委托收款，将款项转入其个人结算银行账户的或者个人持申请人为单位的银行汇票和银行本票向开户银行提示付款，将款项转入其个人结算银行账户的，个人应当提供有关收款依据。<br>个人持出票人（或申请人）为单位，且一手或多手背书人为单位的支票、银行汇票或银行本票，向开户银行提示付款并将款项转入其个人银行结算账户的，应当提供有关最后一手背书人为单位且被背书人为个人的收款依据。</p>
<h3 id="银行卡业务"><a href="#银行卡业务" class="headerlink" title="银行卡业务"></a>银行卡业务</h3><p>银行卡是指经批准由商业银行（含邮政金融机构）向社会发行的具有消费信用、转账结算、存取现金等全部或部分功能的信用支付工具。</p>
<h4 id="银行卡分类"><a href="#银行卡分类" class="headerlink" title="银行卡分类"></a>银行卡分类</h4><p>一般情况下，银行卡分为信用卡和借记卡两种，具体如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411105149233.png" alt="image-20230411105149233"></p>
<p>信用卡又分为贷记卡和准贷记卡。贷记卡是指发卡银行给予持卡人一定的信用额度，持卡人可在信用额度内先消费、后还款的信用卡。准贷记卡是指持卡人先按银行要求交存一定金额的备用金，当备用金不足以支付时，可在发卡银行规定的信用额度内透支的信用卡。</p>
<p>借记卡按功能不同分为转账卡、专用卡和储蓄卡。借记卡不能透支。转账卡具有转账、存取现金和消费的功能。专用卡是在特定区域、专用用途（百货、餐饮、娱乐行业以外的用途）使用的借记卡，具有转账、存取现金的功能。储蓄卡是银行根据持卡人要求将资金转至卡内储存，交易时直接从卡内扣款的预付钱包式借记卡，这也是我们经常用到的银联卡。</p>
<p>除了以上分类方法外，银行卡还有其他分类标准：按信息载体不同分为磁条卡和芯片卡；按发行主体是否在境内分为境内卡和境外卡；按发行对象不同分为个人卡和单位卡；按账户币种不同分为人民币卡、外币卡和双币种卡。</p>
<h4 id="银行卡相关事项"><a href="#银行卡相关事项" class="headerlink" title="银行卡相关事项"></a>银行卡相关事项</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411105315928.png" alt="image-20230411105315928"></p>
<h4 id="信用卡业务"><a href="#信用卡业务" class="headerlink" title="信用卡业务"></a>信用卡业务</h4><p>信用卡是一种非现金交易付款的方式，是简单的信贷服务。信用卡由银行或信用卡公司依照用户的信用度与财力发给持卡人，持卡人持信用卡消费时无须支付现金，待账单日时再进行还款。除部分与金融卡结合的信用卡外，一般的信用卡与借记卡、提款卡不同，信用卡不会由用户的账户直接扣除资金。我们所说的信用卡，一般指贷记卡。</p>
<p>信用卡的主要特点及优点、缺点详见下表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411105657797.png" alt="image-20230411105657797"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411105810181.png" alt="image-20230411105810181"></p>
<h3 id="银行凭证"><a href="#银行凭证" class="headerlink" title="银行凭证"></a>银行凭证</h3><p>银行凭证是用于记录银行金融活动的一种单据。</p>
<p><strong>主要分类</strong></p>
<p>银行凭证分重要凭证和普通凭证两大类。</p>
<p>重要凭证主要指金融活动中使用的票据（如汇票、本票、支票等）和卡片（如借记卡、信用卡）等。</p>
<p>普通凭证主要指金融活动充当过程记录的单据，如通用记账凭证、财务凭证等。</p>
<p><strong>借记卡，</strong>是指发卡银行向持卡人签发的，没有信用额度，持卡人先存款、后使用的一种银行卡。</p>
<p>借记卡具有存取现金、转账汇款、刷卡消费、代收代付、资产管理等功能，有易用、普及、安全可靠等特征。有些借记卡只适用于密码操作，有些则密码和签名两用。</p>
<p><strong>借记卡的特点</strong></p>
<p>开卡方便即时申领，个人在本行任意网点，只需凭有效身份证件、填写申请、存入现金、设置密码，即可当场领取借记卡。一卡多户灵活方便，借记卡将活期存款、整存整取、零存整取、定活两便等多个储蓄品种集于一身，手续简便，方便理财。一户多卡 集中管理，客户以身份证件生成唯一客户号，可统揽持卡人在本行的所有储蓄账户、各类如意卡账户，有效避免多张存折不易保管、容易丢失的风险。</p>
<p><strong>借记卡和储蓄卡的区别</strong></p>
<p>储蓄卡顾名思义主要适用于“储蓄”资产。它是借记卡的一种，功能相当于90年代经常使用的存折，具有一定的局限性。我们可以通过储蓄卡办理存取款业务、缴纳水电费以及在联网的POS上进行消费。值得注意的是储蓄卡不能透支消费，只能先存后取。</p>
<p><strong>贷记卡：</strong>它就是平时所说的信用卡，具有透支消费的功能，可透支的额度比准贷记卡大，使用年限一般为三年。持卡人在使用贷记卡透支消费时，可以享受最长56天的免息期，如果还款有压力，还能申请最低还款。但是把钱存在贷记卡(信用卡)里是不能享受银行利息的。</p>
<p><strong>支票</strong>是出票人签发的，委托办理支票存款业务的银行或者其他金融机构，在见票时无条件支付确定的金额给收款人或者持票人的票据。目前支票已实现全国通用，同城票据或异城间的单位和个人之间款项结算，均可使用支票。支票可以支取现金，也可以转账。其中，现金支票只能用于支取现金；转账支票只能用于转账，不得支取现金。</p>
<p>开立支票存款账户，应符合以下条件：</p>
<ul>
<li>申请人必须使用其本名，并提交证明其身份的合法证件；</li>
<li>申请人应当预留其本人的签名式样和印鉴；</li>
<li>申请人应当有可靠的资信，并存入一定的资金。</li>
</ul>
<p><strong>存折，</strong>又称存款簿，是用来记录银行账户交易的纸制簿子，其面积大小会因不同国家以及银行机构而不同，此外，一本存折对应一个账户，现在也有一户多折的情况，但一折只能对应一个账户。</p>
<p><strong>一本通</strong>，是在一个存折上办理多种货币和多种存期，并在联机网点办理通存通兑的整存整取定期储蓄存款方式。</p>
<p>一本通集多种货币于一折，方便保管；兼有一般活期存款同城通存通兑的功能；可以接受国内、外不同货币的汇款，储户可事后到柜面或自助银行存折补打机打印确认汇款是否到帐；可进行个人实盘外汇买卖；与电话银行相连通，足不出户便实现个人理财。</p>
<h3 id="信贷业务"><a href="#信贷业务" class="headerlink" title="信贷业务"></a>信贷业务</h3><p>信贷业务是商业银行最重要的资产业务，通过放款收回本金和利息，扣除成本后获得利润，所以信贷是商业银行的主要盈利手段。</p>
<h4 id="信贷业务的分类"><a href="#信贷业务的分类" class="headerlink" title="信贷业务的分类"></a>信贷业务的分类</h4><p>信贷业务按不同的划分标准有不同的分类，具体如下表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411103411274.png" alt="image-20230411103411274"></p>
<h4 id="个人信贷业务的分类"><a href="#个人信贷业务的分类" class="headerlink" title="个人信贷业务的分类"></a>个人信贷业务的分类</h4><p>个人信贷业务主要是指运用从负债业务筹集的资金，将资金的使用权在一定期限内有偿让渡给个人，并在贷款到期时收回资金本息以取得收益的业务。个人信贷是信贷业务的一种，其特点和具体分类详见下表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411103536786-20231217152349661.png" alt="image-20230411103536786"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411103804464.png" alt="image-20230411103804464"></p>
<h3 id="贷款的种类"><a href="#贷款的种类" class="headerlink" title="贷款的种类"></a>贷款的种类</h3><p><strong>第一种分:按性质划分</strong>，分为信用贷款和抵押贷款两种，也称无抵押贷款和有抵押贷款。</p>
<p><strong>信用贷款，</strong>顾名思义就是凭借信用去申请的一种贷款，这类贷款最典型的代表就是信用卡，给你一个额度，不需要任何担保。用了之后一个月之后再还款。信用贷款特点之一就是利率比较高，年利率一般都在15%以上。根据申请人条件的不一样利率跨度大概15%-40%。利率高的原因也是因为作为出借方来说，自己借出去的钱几乎没有什么保障，完全就是凭借款方的信用。另一个特点就是，额度不会很高。单家机构的出借金额一般都在50万以内，额度上限不高，也是因为控制风险。</p>
<p><strong>有抵押贷款，</strong>当然就是需要提供东西去作为抵押的贷款。一般最常见的抵押物是房产，这跟房产是不动产并且保值有很大关系。因为有东西作为抵押，出借人的风险相对可控所以年利率一般都在20%以下，最低的银行可以低到年利率4%。另外抵押贷款的金额主要由抵押物价值决定，一般最高可贷款金额是抵押物价值的70%。比如房子价值100万，最高就能贷70万。</p>
<p><strong>第二种划分方式，按用途划分</strong>，分为<strong>按揭贷款</strong>，<strong>消费性贷款</strong>和<strong>经营性贷款</strong>。按揭贷款是专门用于购买住房的贷款，由于有国家管控，并且专款专用，所以利率较低。消费性贷款指的是你去银行贷款银行会要求你提供贷款用途的证明材料，例如:装修、买车、出国留学。经营性贷款除了需要提供营业执照以外还需要提供上下游的合同，例如你买设备，那么就需要提供订单，首付款，跟厂家签的合同等等。消费类贷款一般设置的借款上限是100万，毕竟装修费花掉100万的还是少数。经营性贷款上限一般也在1000万以内。</p>
<p><strong>第三种划分方式，按借款主体划分</strong>，分为<strong>个人贷款</strong>和<strong>企业贷款</strong>。个人贷款就是以家庭为借款主体申请的贷款。贷款之后负债只体现在个人名下，审核的时候也只审查本人和配偶的情况。而企业贷款是以企业作为借款主体，负债在企业名下，需要提供企业的相关材料，会审核企业的经营情况，也需要参考企业征信，有些时候需要考察经营场所，这也是为了控制风险，防止空壳企业的申请企业贷款。</p>
<p>当然，同一笔贷款有可能同时具有几种特定的属性，比如，我个人，以名下房子作为抵押申请的装修贷款。即是个人贷款，也是抵押贷款，也是消费贷款。</p>
<p>我们最常见的按揭贷款就是属于个人名下的抵押贷款，抵押物就是房子。</p>
<h3 id="活期存款利息计算方法"><a href="#活期存款利息计算方法" class="headerlink" title="活期存款利息计算方法"></a>活期存款利息计算方法</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411100711810.png" alt="image-20230411100711810"></p>
<p><strong>1. 活期存款的利息是按天数计算的：利息的计算公式是</strong><br>　　　　活期利息=存款余额×（活期利率÷360）×存款天数          （1）<br>其中的（活期利率÷360）是日利率。因为银行给出的利率都是年利率。要把它换算为日利率时还必须除以360（除360，而不是除365，这是银行的规定）。例如当活期利率是0.5%时，日利率就是0.5%÷360=0.001389%。也就是说你存10000元的话，每天得到的利息是Y=10000元×0.001389%=0.139元<br>也就是说，存10000元的活期时，每天的利息不到一角四分钱。如果存一年，得到的利息就是 50元。<br>    当储户提款时，按提款日挂牌公告的活期利率计息。而不是按存款时的利率计息。计算存款期时，采用计头不计尾的方法。即一笔存款存入银行后，利息应该从存入日开始计息，算到取款日前一天为止。支取当日不计息。</p>
<p><strong>2.活期存款的累计利息是分段计算的</strong><br>    活期存款是经常变动的，不管它怎样变动，只要按照上述方法把每天的利息计算出来，然后相加就可以得出总利息了。可是，这个方法太麻烦了。实际计算利息的公式是分段计算后加以累计计算的。<br>　　　　活期利息=各段积数的总和×日利率                   （2）<br>    什么是积数呢？根据我的理解，这里说的积数就是存款余额数跟这个余额存在银行的天数的乘积，它的单位应该是“元·日”。<br>举例说：<br>    例1．老王于2011年的11月20日在银行存了10000元活期存款。当年的11月28日取出了6000元；12月3日他又存入了 2000元。到12月30日，他想把全部存款都取出来，问他能得到多少利息？<br>答：实际上这个问题可以分三段计算。<br>第一段是从11月20日开始存款阶段，此存款10000元数维持了8天，因此，第一阶段的积数是10000元×8天=80000（元·日）；<br>第二段是取出6000元以后的4000元存款阶段，此存款数维持了5天，因此，第二阶段的积数是4000元×5天=20000（元·日）；<br>第三段是他再存入2000元以后的6000元存款阶段，此存款数维持了27天，因此，第三阶段的积数是6000元×27天=162000（元·日）。<br>各个阶段的积数总和为：80000（元·日）+20000（元·日）+162000（元·日）=262000（元·日）。将此结果代入公式（2）可以得到总利息是262000（元·日）×0.5%÷360日= 31.4元</p>
<p><strong>3.银行是按季度结算活期利息的</strong><br>     如果你不把活期存款取出来，银行是按季度结算你的利息的。据我了解，中国银行和工商银行是于每个季度最后那个月的20日结算的；也就是说，每年的3月20日、6月20日、9月20日和12月20日这四天为结算日。兴业银行似乎是每个季末月的15日为结算日。<br>     由于采用按季计结息，上一个季度结下来的利息，又可以本金的形式在下个季度中再次计息，这就是“利滚利”了。据此计算，活期存款利息就增大了。当然，这只是理论上的探讨，经过我计算这个利率的增长是完全忽略不计的。<br>     不过，了解这个规定，对你选择存取款的时间或规避小额存款管理费或许有所帮助。<br>     例2：下述内容是老饶的活期存折上的记录，可以看出：2011年9月21日银行按季计算得到的利息是0.83元。请你说明这0.83元利息是怎样计算出来的？</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/256716-20171225172534087-101029194.jpg" alt="img"></p>
<p>答：因为活期利息是分段计算的。在本问中，所需的分段比较多，为了使读者看得清楚，让我用表格的形式进行计算。下表中第1列、第2列、第3列和第4列都是取存折内的数据；第5列、第6列和第7列则是计算结果。读者应该特别注意的是第6列的数据选取方法，这是计算成败的关键。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/256716-20171225172728134-1235181242.jpg" alt="img"></p>
<p>因为这个0.83元利息是从6月22日至9月21日这段时间（一个季度）内累计的，所以，其积数也是这段时间内的累计积数。从上表的第7列可以知道，这个累计积数等于(2644.2+200.4+787.2+1592.5+46800+7653+159)（元·日） = 59836.3（元·日）。因此，<br>　　总利息=59836.3（元·天）×0.5% ÷360天=0.83元。<br>可见，这个计算结果跟银行用计算机计算的结果完全一致。计算机是很容易实现利息的日结日清的。为什么要一个季度才结算一次利息呢？我认为，这一方面是为了减少记账的麻烦；另一方面也可能跟银行要收小额存款管理费有关。因为小额管理费也是一个季度收一次的。什么是小额存款管理费，下面即将介绍。</p>
<p><strong>4.小额活期存款是要收管理费的</strong><br>据说在银行开立的活期存折中，小用户占70%左右，这些用户占用了银行的大部分资源，为此，银行多次号召储户把储蓄存折进行合并，或者把不常使用的账号撤销。为了限制小用户多存折的现象，就有了对小额存款户加收管理费的规定。这是银行的公开理由，是不是还有牟利的企图不敢妄加评论。<br>    大部分银行加收管理费的标准定为日平均存款不足300元的储户。收款额是每季度3元。收管理费的时间跟结算利息的时间相一致，大致都是每个季度最后那个月的20号。也有的银行把标准定为500元甚至更高，收费时间也不一定在20日前后。但是，按规定，新储户的新存折在第一个季度是不收管理费的。 也有免收管理费的情况，比如，如果你的存折是跟借记卡相关联的话，就不收，因为借记卡是要收年费的。还有，如果是发工资或退休金的账户，银行也不收管理费。总之，因为国家对小额账户管理费怎样收法似乎没有统一规定，所以，当你开立账户时，应该把人家的规定弄清楚。 如果按存款额为日均300元计算，只要在每季最后那个月的20日之前把累计积数凑足300元×90天=27000(元·日)就可以免收小额存款管理费了。为了规避管理费，我认为在每年的3月20日、6月20日、9月20日和12月20日之前就可以采取一些规避措施。比如把27000元存一天，或把2700元存10天，或者使你的存折上始终保持有300元以上的存款余额……，总之，只要在一个结算季度内能满足积数等于或大于27000（元·日），就都可以免交管理费了。 有了小额存款管理费这一个规定，就不能保证“凡是存款，都能获利”这一个传统观念了。如果你在银行存折上的10元余额不取出来，说不定几个月之后就化为乌有了。如果你的账户存款被扣光了以后，你不再继续补充存款，在规定时间内，你的账户也须就被撤消了。<br>让我再举一个例子说明存款后可能遭致负利率的情况：<br>    例3：李君存了100元的活期存款，问存满三年后，他收回的本利是多少？    答：李君享受的是0.5%的年利率，合季度利率是0.125%。因为他的日平均存款额不足300元，因此，从存款的第二个季度起，银行每季要收他的小额存款管理费3元，合每季收3%的管理费。因此，三年（12个季度）以后他得到的本利是</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/256716-20171225173230853-1544325056.jpg" alt="img"></p>
<p>因为第一季度并不收他的管理费，因此，三年期满后银行应该给他的本利是73.46元。也就是说，他存了三年活期，不但没有得到利息，还亏本26.54元。 从账户的利息可以计算出储户在本季度存款的积数，积数可以按下式计算<br>　　　　积数 = 得到的利息× 360 ÷ 活期利率                       (3)<br>    从老饶的存折上可以看到，她在2011年的二季度只有0.04元的利息，所以她的积数是0.04元× 360 日÷ 0.5 % = 2880(元·日)。离不收管理费的标准——27000（元·日）还远着哩。<br>    从上述关系还可以知道，利息的多少跟是否收管理费是紧密相关的。如果利息超过某个值时，也就不收管理费了。这个利息值的临界值是27000(元·日) × 0.5 % ÷360 = 0.375元。     所以，如果哪天银行给你的利息稍稍小于0.375元，相信你会后悔的，因为在这种情况下，只要在结算月的20日之前的一两天补存一点儿钱，使积数凑足27000（元·日），就可以少损失3元的管理费。我建议：在结算日之前，大体核算一下本季度的积数，这时你就可以根据实际情况，选择凑足27000(元·日)，规避交管理费，或者选择不予“挽救”，任由银行扣3元管理费。</p>
<h3 id="存款利息"><a href="#存款利息" class="headerlink" title="存款利息"></a>存款利息</h3><p>存款利息是指银行向存款人支付的利息。存款利息金额因存款种类和期限的长短而不同。存款的期限越长，存款人的利息收入越高；活期存款最不稳定，所以存款人的利息收入也最低。不同存款方式的利率和计息方式不同，具体内容如下表所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20230411101544779.png" alt="image-20230411101544779"></p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>银行</tag>
      </tags>
  </entry>
</search>
