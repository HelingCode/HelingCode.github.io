<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 | vulkhe's blog</title><meta name="keywords" content="八股文"><meta name="author" content="vulkhe"><meta name="copyright" content="vulkhe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="😀 JDK和JRE有什么区别 JDK:Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。 JRE:Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提 供了所需环境。  😀 Java8的新特性 Lambda 表达式:Lambda 允许把函数作为一个方法的参数 Stream API :">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://helingcode.github.io/posts/java-basic.html">
<meta property="og:site_name" content="vulkhe&#39;s blog">
<meta property="og:description" content="😀 JDK和JRE有什么区别 JDK:Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。 JRE:Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提 供了所需环境。  😀 Java8的新特性 Lambda 表达式:Lambda 允许把函数作为一个方法的参数 Stream API :">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png">
<meta property="article:published_time" content="2022-07-01T05:25:34.000Z">
<meta property="article:modified_time" content="2023-12-17T08:10:11.800Z">
<meta property="article:author" content="vulkhe">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%A4%B4%E5%83%8F.jpg"><link rel="canonical" href="https://helingcode.github.io/posts/java-basic"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: vulkhe","link":"链接: ","source":"来源: vulkhe's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-17 16:10:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="vulkhe's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">vulkhe's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-01T05:25:34.000Z" title="发表于 2022-07-01 13:25:34">2022-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-17T08:10:11.800Z" title="更新于 2023-12-17 16:10:11">2023-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="😀-JDK和JRE有什么区别"><a href="#😀-JDK和JRE有什么区别" class="headerlink" title="😀 JDK和JRE有什么区别"></a>😀 JDK和JRE有什么区别</h3><ul>
<li>JDK:Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE:Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提 供了所需环境。</li>
</ul>
<h3 id="😀-Java8的新特性"><a href="#😀-Java8的新特性" class="headerlink" title="😀 Java8的新特性"></a>😀 Java8的新特性</h3><ul>
<li>Lambda 表达式:Lambda 允许把函数作为一个方法的参数</li>
<li>Stream API : 新添加的 Stream API(java.util.stream) 把真正的函数式编程风格引入到 Java 中</li>
<li>方法引用: 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象 (实例)的方法或构造器。</li>
<li>默认方法: 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>Optional 类 :Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Date Time API :加强对日期与时间的处理。</li>
</ul>
<h3 id="😀-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#😀-一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="😀 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>😀 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3><p>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p>
<h3 id="😀-说说-amp-和-amp-amp-的区别"><a href="#😀-说说-amp-和-amp-amp-的区别" class="headerlink" title="😀 说说&amp;和&amp;&amp;的区别"></a>😀 说说&amp;和&amp;&amp;的区别</h3><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，a&amp;b 表示把 a 和 b 都转换成二进制数，再进行与的运算;</p>
<h3 id="😀-在JAVA中如何跳出当前的多重嵌套循环？"><a href="#😀-在JAVA中如何跳出当前的多重嵌套循环？" class="headerlink" title="😀 在JAVA中如何跳出当前的多重嵌套循环？"></a>😀 在JAVA中如何跳出当前的多重嵌套循环？</h3><p>让外层的循环条件表达式的结果可以受到内层循环体代码的控制，例如，要在二维数组中查找到某个数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length &amp;&amp; !found; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] == <span class="number">5</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="😀-switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#😀-switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="😀 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a>😀 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</h3><p>在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。</p>
<p>switch 不可作用于 long double float boolean，以及他们的包装类；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖,内部实现在 switch 中使用字符串的 hashcode。</p>
<h3 id="😀-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#😀-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="😀 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>😀 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h3><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。</p>
<p>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<h3 id="😀-char型变量中能不能存贮一个中文汉字-为什么"><a href="#😀-char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="😀 char型变量中能不能存贮一个中文汉字?为什么?"></a>😀 char型变量中能不能存贮一个中文汉字?为什么?</h3><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h3 id="😁-用最有效率的方法算出2乘以8等于几"><a href="#😁-用最有效率的方法算出2乘以8等于几" class="headerlink" title="😁 用最有效率的方法算出2乘以8等于几?"></a>😁 用最有效率的方法算出2乘以8等于几?</h3><p>2 &lt;&lt; 3。因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算是cpu直接支持的，效率最高，所以，2乘以8等于几的最高效的方法是2 &lt;&lt; 3。</p>
<h3 id="😀-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#😀-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="😀 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>😀 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h3><p><strong>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。</strong>例如，对于如下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StringBuffer a=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;immutable&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>执行如下语句将报告编译期错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是，执行如下语句则可以通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="string">&quot; broken!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="keyword">final</span> StringBuffer param)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param.append(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="😀-“-”和equals方法究竟有什么区别？"><a href="#😀-“-”和equals方法究竟有什么区别？" class="headerlink" title="😀 “==”和equals方法究竟有什么区别？"></a>😀 “==”和equals方法究竟有什么区别？</h3><p><code>==</code>对于基本数据类型和引用数据类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p>因为 Java 只有值传递，所以，对于 <code>==</code> 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>==o;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals()</code>方法存在两种使用情况：</p>
<ul>
<li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的内容是否相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<h3 id="😀-什么是值传递和引用传递？"><a href="#😀-什么是值传递和引用传递？" class="headerlink" title="😀 什么是值传递和引用传递？"></a>😀 什么是值传递和引用传递？</h3><ul>
<li>值传递是对基本型变量而言的,传递的是该变量的一个副本，改变副本不影响原变量.</li>
<li>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.</li>
</ul>
<h3 id="😀-静态变量和成员变量的区别？"><a href="#😀-静态变量和成员变量的区别？" class="headerlink" title="😀 静态变量和成员变量的区别？"></a>😀 静态变量和成员变量的区别？</h3><p>在语法定义上的区别：静态变量前要加static关键字，而成员变量前则不加。</p>
<p>在程序运行时的区别：成员变量是属于某个对象的属性，必须创建了实例对象，其中的成员变量才会被分配空间，才能使用这个成员变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，成员变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<h3 id="😀-是否可以从一个static方法内部发出对非static方法的调用？"><a href="#😀-是否可以从一个static方法内部发出对非static方法的调用？" class="headerlink" title="😀 是否可以从一个static方法内部发出对非static方法的调用？"></a>😀 是否可以从一个static方法内部发出对非static方法的调用？</h3><p>不可以。</p>
<p>因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不可以发出对非static方法的调用。</p>
<h3 id="😀-可以在-static-环境中访问非-static-变量吗"><a href="#😀-可以在-static-环境中访问非-static-变量吗" class="headerlink" title="😀 可以在 static 环境中访问非 static 变量吗?"></a>😀 可以在 static 环境中访问非 static 变量吗?</h3><p>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。因为静态的成员属于类， 随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建， 没有实例，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态!</p>
<h3 id="😀-Integer与int的区别"><a href="#😀-Integer与int的区别" class="headerlink" title="😀 Integer与int的区别"></a>😀 Integer与int的区别</h3><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，Integer使用需要判空处理。例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</p>
<p>Integer 的缓存机制:为了节省内存和提高性能，Integer 类在内部通过使用相同的对象引用实现缓存和重用，Integer 类默认在-128 ~ 127 之间，可以通过 - XX:AutoBoxCacheMax 进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建 Integer 对象时无用。</p>
<h3 id="😀-Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#😀-Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="😀 Math.round(11.5)等于多少? Math.round(-11.5)等于多少?"></a>😀 Math.round(11.5)等于多少? Math.round(-11.5)等于多少?</h3><p>Math类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor的英文意义是地板，该方法就表示向下取整，Math.floor(11.6)的结果为11,Math.floor(-11.6)的结果是-12；<strong>最难掌握的是round方法，它表示“四舍五入”，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</strong></p>
<h3 id="😀-请说出作用域public，private，protected，以及不写时的区别。"><a href="#😀-请说出作用域public，private，protected，以及不写时的区别。" class="headerlink" title="😀 请说出作用域public，private，protected，以及不写时的区别。"></a>😀 请说出作用域public，private，protected，以及不写时的区别。</h3><p>这四个作用域的可见范围如下表所示</p>
<p>说明：如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">作用域</th>
<th style="text-align:left">当前类</th>
<th style="text-align:left">同一package</th>
<th style="text-align:left">子孙类</th>
<th style="text-align:left">其他package</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
</tr>
<tr>
<td style="text-align:left">friendly</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p>
</li>
<li><p>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用。</p>
</li>
<li><p>protected：protected对于子类、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。</p>
</li>
</ul>
<h3 id="😀-Overload-重载-和Override-重写-的区别。Overloaded的方法是否可以改变返回值的类型"><a href="#😀-Overload-重载-和Override-重写-的区别。Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="😀 Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?"></a>😀 Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?</h3><p>重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
<p>重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。<strong>如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</strong></p>
<p>如果几个Overloaded的方法的参数列表不一样，它们的返回者类型也可以不一样。</p>
<p>如果两个方法的参数列表完全一样，则不可以让它们的返回值不同来实现重载Overload。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候<strong>假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，Java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</strong></p>
<p>override可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：</p>
<p>1）覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
<p>2）覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
<p>3）覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
<p>4）被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<h3 id="😀-构造方法是否可以被重写"><a href="#😀-构造方法是否可以被重写" class="headerlink" title="😀 构造方法是否可以被重写?"></a>😀 构造方法是否可以被重写?</h3><p>构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以谈不上继承。 又由于构造器不能被继承，所以相应的就不能被重写了。但可以被重载Overload。</p>
<h3 id="😀-接口是否可继承接口-抽象类是否可实现接口-抽象类是否可继承具体类-抽象类中是否可以有静态的main方法？"><a href="#😀-接口是否可继承接口-抽象类是否可实现接口-抽象类是否可继承具体类-抽象类中是否可以有静态的main方法？" class="headerlink" title="😀 接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承具体类? 抽象类中是否可以有静态的main方法？"></a>😀 接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承具体类? 抽象类中是否可以有静态的main方法？</h3><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。</p>
<p>抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。</p>
<h3 id="😀-如何实现对象的克隆"><a href="#😀-如何实现对象的克隆" class="headerlink" title="😀 如何实现对象的克隆"></a>😀 如何实现对象的克隆</h3><ul>
<li>实现 Cloneable 接口，重写 clone() 方法。</li>
<li>Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。</li>
<li>对象的属性的 Class 也实现 Cloneable 接口，在克隆对象时也手动克隆属性，完成深拷贝</li>
<li>结合序列化(JDK java.io.Serializable 接口、JSON 格式、XML 格式等)，完成深拷贝</li>
</ul>
<h3 id="😀-写clone-方法时，通常都有一行代码，是什么？"><a href="#😀-写clone-方法时，通常都有一行代码，是什么？" class="headerlink" title="😀 写clone()方法时，通常都有一行代码，是什么？"></a>😀 写clone()方法时，通常都有一行代码，是什么？</h3><p>clone 有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员。</p>
<h3 id="😀-面向对象的”六原则一法则”"><a href="#😀-面向对象的”六原则一法则”" class="headerlink" title="😀 面向对象的”六原则一法则”"></a>😀 面向对象的”六原则一法则”</h3><ul>
<li><strong>单一职责原则:</strong> 一个类只做它该做的事情。</li>
<li><strong>开闭原则:</strong> 软件实体应当对扩展开放，对修改关闭。</li>
<li><strong>依赖倒转原则:</strong> 面向接口编程。</li>
<li><strong>接口隔离原则:</strong> 接口要小而专，绝不能大而全。</li>
<li><strong>合成聚合复用原则:</strong> 优先使用聚合或合成关系复用代码。</li>
<li><strong>迪米特法则:</strong> 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li>
</ul>
<h3 id="😀-面向对象的特征有哪些方面"><a href="#😀-面向对象的特征有哪些方面" class="headerlink" title="😀 面向对象的特征有哪些方面"></a>😀 面向对象的特征有哪些方面</h3><p>面向对象的编程语言有<strong>封装、继承 、抽象、多态</strong>等4个主要的特征。</p>
<p><strong>1）封装：</strong></p>
<p>面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了。</p>
<p>例如，人要在黑板上画圆，这一共涉及三个对象：人、黑板、圆，画圆的方法要分配给哪个对象呢？由于画圆需要使用到圆心和半径，圆心和半径显然是圆的属性，如果将它们在类中定义成了私有的成员变量，那么，画圆的方法必须分配给圆，它才能访问到圆心和半径这两个属性，人以后只是调用圆的画圆方法、表示给圆发给消息而已，画圆这个方法不应该分配在人这个对象上，这就是面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。</p>
<p>优点:</p>
<ul>
<li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p><strong>说到封装，为什么有了私有属性，还要提供对外访问的公有方法，这样属性私有有什么意义</strong>？</p>
<p>其实这里体现的就是封装的思想: <strong>将数据与行为进行分离。</strong></p>
<p>试想， 如果外面的程序可以随意修改一个类的成员变量，会造成不可预料的程序错误， 就象一个人的名字，<br>不能被外部随意修改，只能通过各种给定的方法去修改这个属性。<br>所以我们将成员变量声明为private，再通过 public的方法来对这个变量进行访问。</p>
<p>对一个变量的操作，一般都有读取和赋值操作，我们分别定义两个方法来实现这两种操作：<br>一个是getXxx()（Xxx 表示要访问的成员变量的名字），用来获取这个成员变量；<br>另外一个是 setXxx()用来对这个成员变量修改。<strong>我们可以在set方法里做变量赋值逻辑判断，如果外部类赋的值不符合规则的话，就赋值失败。</strong></p>
<p><strong>2）继承：</strong></p>
<p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p>
<p><strong>3）抽象：</strong></p>
<p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。例如，定义一个Person类，如下：</p>
<p>class Person{</p>
<p>String name;</p>
<p>int age;</p>
<p>}</p>
<p>人本来是很复杂的事物，有很多方面，但因为当前系统只需要了解人的姓名和年龄，所以上面定义的类中只包含姓名和年龄这两个属性，这就是一种抽像，使用抽象可以避免考虑一些与目标无关的细节。我对抽象的理解就是不要用显微镜去看一个事物的所有方面，这样涉及的内容就太多了，而是要善于划分问题的边界，当前系统需要什么，就只考虑什么。</p>
<p><strong>4）多态：</strong></p>
<p>多态分为编译时多态和运行时多态:</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件:</p>
<ul>
<li>继承</li>
<li>覆盖(重写)</li>
<li>向上转型</li>
</ul>
<p><strong>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定</strong>，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。</p>
<h3 id="😀-Java中实现多态的机制是什么？"><a href="#😀-Java中实现多态的机制是什么？" class="headerlink" title="😀 Java中实现多态的机制是什么？"></a>😀 Java中实现多态的机制是什么？</h3><ul>
<li>多态机制包括静态多态(编译时多态)和动态多态(运行时多态)</li>
<li>静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法。</li>
<li>我们通常所说的多态一般指运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直等到运行时才能确定。</li>
<li>多态实现方式:子类继承父类(extends)和类实现接口(implements)</li>
<li>多态核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果</li>
<li>Java 里对象方法的调用是依靠类信息里的方法表实现的，对象方法引用调用和接口方法引用调用的大致思想是一样的。当调用对象的某个方法时，JVM 查找该对象 类的方法表以确定该方法的直接引用地址，有了地址后才真正调用该方法。</li>
</ul>
<h3 id="😀-Java为什么不支持多继承"><a href="#😀-Java为什么不支持多继承" class="headerlink" title="😀 Java为什么不支持多继承"></a>😀 Java为什么不支持多继承</h3><ul>
<li>安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</li>
<li>Java 提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li>
</ul>
<h3 id="😀-abstract-class-抽象类-和interface-接口-有什么区别"><a href="#😀-abstract-class-抽象类-和interface-接口-有什么区别" class="headerlink" title="😀 abstract class(抽象类)和interface(接口)有什么区别?"></a>😀 abstract class(抽象类)和interface(接口)有什么区别?</h3><p>含有abstract修饰符的class即为抽象类，<strong>abstract 类不能创建实例对象。</strong>含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p>
<p>下面比较一下两者的语法区别：</p>
<p>1）抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>2）抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>3）抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>4） 抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p>
<p>5）抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>6）抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
<p>7）一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p><strong>接口的变量为什么是static和final的？</strong></p>
<p>static：必须。因为接口是可以多继承的。如果一个类实现了两个接口，且两个接口都具有相同名字的变量，此时这个变量可以被实现类使用，那么如果不是static的，这个变量来自哪一个接口就会产生歧义，所以实现类使用接口中的变量必须通过接口名指定，也就只能定为static的。</p>
<p>final：我认为因为必须是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&amp;spm=1001.2101.3001.7020">static</a>的，那么所有子类共享，而接口是一种抽象， 所以一个子类修改了值会影响到其他所有子类，因此就不应该允许子类修改这个值，所以定义为final。</p>
<p><strong>下面接着再说说两者在应用上的区别：</strong></p>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 记录访问日志, 进行权限判断</span></span><br><span class="line">        <span class="keyword">if</span> (具有权限) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doService(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// todo：记录异常信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet1</span> <span class="keyword">extends</span> <span class="title class_">BaseServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOExcetion, ServletException &#123;</span><br><span class="line">        <span class="comment">// 本Servlet只处理的具体业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。<br>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。</p>
<h3 id="😀-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized"><a href="#😀-abstract的method是否可同时是static-是否可同时是native，是否可同时是synchronized" class="headerlink" title="😀 abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?"></a>😀 abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</h3><p>abstract的method 不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</p>
<p>native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputStream类要和硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk 的源代码，可以发现FileOutputStream的open方法的定义如下：</p>
<p>private native void open(String name) throws FileNotFoundException;</p>
<p>如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，用我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。</p>
<p>关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。</p>
<h3 id="😀-什么是内部类？静态内部类和内部类的不同"><a href="#😀-什么是内部类？静态内部类和内部类的不同" class="headerlink" title="😀 什么是内部类？静态内部类和内部类的不同"></a>😀 什么是内部类？静态内部类和内部类的不同</h3><p><strong>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</strong>（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），<strong>内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中</strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out_x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在方法体内部定义的内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner2</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                out_x = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner2</span> <span class="variable">inner2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在方法体外面定义的内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法体外面定义的内部类的访问类型可以是public,protected,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner1</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Innner1</span>();</span><br></pre></td></tr></table></figure>
<p><strong>在方法内部定义的内部类前面不能有访问类型修饰符</strong>，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在方法外部定义的内部类前面可以加上static关键字，从而成为Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static Nested Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static Nested Class，例如，假设Inner是定义在Outer类中的Static Nested Class，那么可以使用如下语句创建Inner类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>
<p>由于static Nested Class不依赖于外部类的实例对象，所以，static Nested Class不能访问外部类的非static成员变量。当在外部类中访问Static Nested Class时，可以直接使用Static Nested Class的名字，而不需要加上外部类的名字了，在Static Nested Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。</p>
<p>在静态方法中定义的内部类也是Static Nested Class，这时候不能在类前面加static关键字，静态方法中的Static Nested Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</p>
<p>备注：首先根据印象说出自己对内部类的总体方面的特点。例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。</p>
<h3 id="😀-内部类可以引用它的包含类的成员吗？有没有什么限制？"><a href="#😀-内部类可以引用它的包含类的成员吗？有没有什么限制？" class="headerlink" title="😀 内部类可以引用它的包含类的成员吗？有没有什么限制？"></a>😀 内部类可以引用它的包含类的成员吗？有没有什么限制？</h3><p>完全可以。如果不是静态内部类，那没有什么限制！</p>
<p>如果把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            syso(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="😀-匿名内部类是否可以继承其它类，是否可以实现接口？"><a href="#😀-匿名内部类是否可以继承其它类，是否可以实现接口？" class="headerlink" title="😀 匿名内部类是否可以继承其它类，是否可以实现接口？"></a>😀 匿名内部类是否可以继承其它类，是否可以实现接口？</h3><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<p><strong>可以继承其他类或实现其他接口。不仅是可以，而是必须!</strong></p>
<h3 id="😀-匿名内部类的特点"><a href="#😀-匿名内部类的特点" class="headerlink" title="😀 匿名内部类的特点"></a>😀 匿名内部类的特点</h3><ul>
<li><p>没有名字</p>
</li>
<li><p>匿名内部类必须继承一个抽象类或者实现一个接口。</p>
</li>
<li><p>匿名内部类不能定义任何静态成员和静态方法。</p>
</li>
<li><p>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220909154956592-20231217153340288.png" alt="image-20220909154956592" style="zoom:33%;" /></p>
</li>
<li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
</li>
<li><p>匿名内部类不能访问外部类方法中的局部变量，除非该变量被声明为 final 类型</p>
</li>
</ul>
<h3 id="😀-静态内部类与非静态内部类有什么区别"><a href="#😀-静态内部类与非静态内部类有什么区别" class="headerlink" title="😀 静态内部类与非静态内部类有什么区别"></a>😀 静态内部类与非静态内部类有什么区别</h3><ul>
<li>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员和静态方法,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</li>
<li>实例化静态内部类与非静态内部类的方式不同</li>
<li>调用内部静态类的方法或静态变量,可以通过类名直接调用</li>
</ul>
<h3 id="😀-super-getClass-方法调用"><a href="#😀-super-getClass-方法调用" class="headerlink" title="😀 super.getClass()方法调用"></a>😀 super.getClass()方法调用</h3><p>下面程序的输出结果是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Test</span>().test();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">super</span>.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很奇怪，结果是Test。</p>
<p>在test方法中，直接调用getClass().getName()方法，返回的是Test类名。由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。</p>
<p>如果想得到父类的名称，应该用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getSuperClass().getName();</span><br></pre></td></tr></table></figure>
<h3 id="😀-String-为什么是不可变的"><a href="#😀-String-为什么是不可变的" class="headerlink" title="😀 String 为什么是不可变的?"></a>😀 String 为什么是不可变的?</h3><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="😀-String类的常用方法都有哪些"><a href="#😀-String类的常用方法都有哪些" class="headerlink" title="😀 String类的常用方法都有哪些?"></a>😀 String类的常用方法都有哪些?</h3><ul>
<li><p>indexOf():返回指定字符的索引。</p>
</li>
<li><p>charAt():返回指定索引处的字符。</p>
</li>
<li>replace():字符串替换。</li>
<li>trim():去除字符串两端空白。</li>
<li>split():分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes():返回字符串的 byte 类型数组。</li>
<li>length():返回字符串长度。</li>
<li>toLowerCase():将字符串转成小写字母。</li>
<li>toUpperCase():将字符串转成大写字符。</li>
<li>substring():截取字符串。</li>
<li>equals():字符串比较。</li>
</ul>
<h3 id="😀-object中定义了哪些方法？"><a href="#😀-object中定义了哪些方法？" class="headerlink" title="😀 object中定义了哪些方法？"></a>😀 object中定义了哪些方法？</h3><ul>
<li>getClass(); 获取类结构信息</li>
<li>hashCode() 获取哈希码</li>
<li>equals(Object) 默认比较对象的地址值是否相等，子类可以重写比较规则</li>
<li>clone() 用于对象克隆</li>
<li>toString() 把对象转变成字符串</li>
<li>notify() 多线程中唤醒功能</li>
<li>notifyAll() 多线程中唤醒所有等待线程的功能</li>
<li>wait() 让持有对象锁的线程进入等待</li>
<li>wait(long timeout) 让持有对象锁的线程进入等待，设置超时毫秒数时间</li>
<li>wait(long timeout, int nanos) 让持有对象锁的线程进入等待，设置超时纳秒数时间</li>
<li>finalize() 垃圾回收前执行的方法</li>
</ul>
<h3 id="😀-String、StringBuffer、StringBuilder-的区别？"><a href="#😀-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="😀 String、StringBuffer、StringBuilder 的区别？"></a>😀 String、StringBuffer、StringBuilder 的区别？</h3><ul>
<li><p><strong>可变性</strong>：String是不可变的，<code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
</li>
<li><p><strong>线程安全性</strong>:<code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。 </p>
</li>
<li><p><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p>
</li>
</ul>
<h3 id="😀-如何将String字符串反转？"><a href="#😀-如何将String字符串反转？" class="headerlink" title="😀 如何将String字符串反转？"></a>😀 如何将String字符串反转？</h3><ul>
<li>使用 StringBuilder 或 StringBuffer 的 reverse 方法，本质都调用了它们的父类 AbstractStringBuilder 的 reverse 方法实现。(JDK1.8)</li>
<li>使用 chatAt 函数，倒过来输出;</li>
</ul>
<h3 id="😀-String-s-“Hello”-s-s-“-world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？"><a href="#😀-String-s-“Hello”-s-s-“-world-”-这两行代码执行后，原始的String对象中的内容到底变了没有？" class="headerlink" title="😀 String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？"></a>😀 String s = “Hello”;s = s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</h3><p>没有。</p>
<p>因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s原先指向一个String对象，内容是 “Hello”，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个 String对象，内容为”Hello world!”，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。</p>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。因为 String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，应该考虑使用StringBuffer类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。</p>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> Demo &#123;</span><br><span class="line">	s = <span class="string">&quot;Initial Value&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Initial Value&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。</p>
<p>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。</p>
<p>至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。</p>
<h3 id="😀-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？"><a href="#😀-String-s-new-String-“xyz”-创建了几个String-Object-二者之间有什么区别？" class="headerlink" title="😀 String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？"></a>😀 String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</h3><p>两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代码就不会创建”xyz”自己了，直接从缓冲区拿。</p>
<h3 id="😀-String-s-与-new-String-与有什么区别"><a href="#😀-String-s-与-new-String-与有什么区别" class="headerlink" title="😀 String s 与 new String 与有什么区别"></a>😀 String s 与 new String 与有什么区别</h3><p>String str =”abc”;</p>
<p>String newStr =new String (“abc”); </p>
<p>String str =”abc”, 先在常量池中查找有没有”abc” 这个对象,如果有，就让 str 指向那个”abc”.如 果没有，在常量池中新建一个“abc”对象，并让 str 指向在常量池中新建的对象”abc”。</p>
<p>String newStr =new String (“abc”); 是在堆中建立的对象”abc” ,在栈中创建堆中”abc” 对象的内存地址。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220908150355631-20231217153340551.png" alt="image-20220908150355631"></p>
<h3 id="😀-String-和StringBuffer的区别"><a href="#😀-String-和StringBuffer的区别" class="headerlink" title="😀 String 和StringBuffer的区别"></a>😀 String 和StringBuffer的区别</h3><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串可以进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffer来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p>
<p>接着要举一个具体的例子来说明，我们要把1到100的所有数字拼起来，组成一个串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	sbf.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码效率很高，因为只创建了一个StringBuffer对象，而下面的代码效率很低，因为创建了101个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	str = str + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String覆盖了equals方法和hashCode方法，而StringBuffer没有覆盖equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。</p>
<h3 id="😀-在自己的代码中，如果创建一个-java-lang-String-类，-这个类是否可以被类加载器加载-为什么。"><a href="#😀-在自己的代码中，如果创建一个-java-lang-String-类，-这个类是否可以被类加载器加载-为什么。" class="headerlink" title="😀 在自己的代码中，如果创建一个 java.lang.String 类， 这个类是否可以被类加载器加载?为什么。"></a>😀 在自己的代码中，如果创建一个 java.lang.String 类， 这个类是否可以被类加载器加载?为什么。</h3><p>不可以。因为 JDK 处于安全性的考虑，基于双亲委派模型，优先加载 JDK 的 String 类，如果 java.lang.String 已经加载，便不会再次被加载。</p>
<h3 id="😀-下面这条语句一共创建了多少个对象-String-s-”a”-”b”-”c”-”d”"><a href="#😀-下面这条语句一共创建了多少个对象-String-s-”a”-”b”-”c”-”d”" class="headerlink" title="😀 下面这条语句一共创建了多少个对象? String s=”a”+”b”+”c”+”d”;"></a>😀 下面这条语句一共创建了多少个对象? String s=”a”+”b”+”c”+”d”;</h3><p>对于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">System.out.println(s3 == <span class="string">&quot;ab&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。</p>
<p><code>String s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;</code>相当于直接定义了一个”abcd”的字符串，写如下两行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;d&quot;</span>;</span><br><span class="line">System.out.println(s == <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Java 编译器对字符串常量直接相加的表达式进行优化，不等到运行期去进行加 法运算，在编译时就去掉了加号，直接将其编译成一个这些常量相连的结果。 所以 “a”+”b”+”c”+”d” 相当于直接定义一个 “abcd” 的字符串。</p>
<p>最终打印的结果应该为true。</p>
<h3 id="😀-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#😀-try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="😀 try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>😀 try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</h3><p>也许你的答案是在return之前，但往更细地说，我的答案是在return中间执行，请看下面程序代码的运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ++x;</span><br><span class="line">           <span class="comment">// return x;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————-执行结果 ————-</p>
<p>1</p>
<p>运行结果是1，为什么呢？如果在try中return的情况下，先把try中将要return的值先存到一个本地变量中，即本例中的x=1将会被保存下来。接下来去执行finally语句，最后返回的是存在本地变量中的值，即返回x=1.</p>
<p>还有一点要注意的，如果你在finally里也用了return语句，比如return ++x。那么程序返回值会是2。因为JVM规范规定了，当try和finally里都有return时，会忽略try的return，而使用finally的return。</p>
<h3 id="😀-try-catch-finally-return-执行顺序"><a href="#😀-try-catch-finally-return-执行顺序" class="headerlink" title="😀 try-catch-finally-return 执行顺序"></a>😀 try-catch-finally-return 执行顺序</h3><ul>
<li>如果不发生异常，不会执行 catch 部分。</li>
<li>不管有没有发生异常，finally 都会执行到。</li>
<li>即使 try 和 catch 中有 return 时，finally 仍然会执行</li>
<li>finally 是在 return 后面的表达式运算完后再执行的。(此时并没有返回运算后的值，而是先把要返回的值保存起来，若 finally 中无 return，则不管 finally 中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，该情况下函数返回值是在 finally 执行前确定的)</li>
<li>finally 部分就不要 return 了，要不然，就回不去 try 或者 catch 的 return 了。</li>
</ul>
<h3 id="😀-final-finally-finalize的区别"><a href="#😀-final-finally-finalize的区别" class="headerlink" title="😀 final, finally, finalize的区别"></a>😀 final, finally, finalize的区别</h3><p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可重写，类不可继承。</p>
<p>内部类要访问局部变量，局部变量必须定义成final类型。</p>
<p>finally是异常处理语句结构的一部分，表示总是执行。</p>
<p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用</p>
<h3 id="😀-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#😀-java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="😀 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>😀 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h3><p>字节流，字符流。</p>
<p>字节流继承于InputStream OutputStream，字符流继承于InputStreamReader OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<h3 id="😀-Java-中-IO-流分为几种"><a href="#😀-Java-中-IO-流分为几种" class="headerlink" title="😀 Java 中 IO 流分为几种?"></a>😀 Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO 流共涉及 40 多个类， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="😀-字节流与字符流的区别"><a href="#😀-字节流与字符流的区别" class="headerlink" title="😀 字节流与字符流的区别"></a>😀 字节流与字符流的区别</h3><p>要把一片二进制数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>在应用中，经常要把完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</p>
<p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。</p>
<p>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p>
<p><strong>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</strong></p>
<h3 id="😀-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用"><a href="#😀-什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用" class="headerlink" title="😀 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用"></a>😀 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用</h3><p><strong>我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象</strong>，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java 帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的。</p>
<p>例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口。如果对象要经过分布式系统进行网络传输或通过RPC等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现Serializable接口。</p>
<h3 id="😀-Java源码的编译过程？"><a href="#😀-Java源码的编译过程？" class="headerlink" title="😀 Java源码的编译过程？"></a>😀 Java源码的编译过程？</h3><p>Java源码是由Javac编译器编译的，流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20170205113216819.jpg" alt=""></p>
<p>Javac的任务就是将Java源代码编译成Java字节码，总结过程如下：</p>
<p>源代码-&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器</p>
<p><strong>词法分析就是将关键词组织成token流即检查源码中的的关键词是否正确并组织成token流，而语法分析就是检查源码是否符合java语法规范并将词组成语句。语义分析就是简化复杂的添加缺少的，检查变量类型是否合法。字节码生成器就是遍历这棵树生成符合JVM规范的字节码。</strong></p>
<p> 1）<strong>词法分析</strong>：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程。</p>
<p>词法分析的结果：就是从源代码中找出了一些规范化的token流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。</p>
<p>2）<strong>语法分析</strong>：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。</p>
<p>语法分析的结果：就是形成一个符合Java语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。</p>
<p>3）<strong>语义分析</strong>：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。</p>
<p>语义分析结果：就是将复杂的语法转化为简单的语法，对应到Java就是将foreach转化为for循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。</p>
<p>4）<strong>字节码生成</strong>：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装文英文语句。代码生成器的结果就是生成符合java虚拟机规范的字节码。</p>
<h3 id="😀-一个Object占多少字节？"><a href="#😀-一个Object占多少字节？" class="headerlink" title="😀 一个Object占多少字节？"></a>😀 一个Object占多少字节？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// o普通对象指针（Oops）4 字节（开启压缩占 4 字节，没开启占 8 字节），object对象占 16 字节 </span></span><br></pre></td></tr></table></figure>
<h3 id="😀-什么是字节码-采用字节码的好处是什么"><a href="#😀-什么是字节码-采用字节码的好处是什么" class="headerlink" title="😀 什么是字节码?采用字节码的好处是什么?"></a>😀 什么是字节码?采用字节码的好处是什么?</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<h3 id="😀-Java-程序从源代码到运行的过程"><a href="#😀-Java-程序从源代码到运行的过程" class="headerlink" title="😀 Java 程序从源代码到运行的过程"></a>😀 Java 程序从源代码到运行的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220209132736220.png" alt="image-20220209132736220"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。 </p>
<h3 id="😀-静态方法为什么不能调用非静态成员"><a href="#😀-静态方法为什么不能调用非静态成员" class="headerlink" title="😀 静态方法为什么不能调用非静态成员?"></a>😀 静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="😀-静态方法和实例方法有何不同？"><a href="#😀-静态方法和实例方法有何不同？" class="headerlink" title="😀 静态方法和实例方法有何不同？"></a>😀 静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h3 id="😀-HashCode的作用是什么"><a href="#😀-HashCode的作用是什么" class="headerlink" title="😀 HashCode的作用是什么?"></a>😀 HashCode的作用是什么?</h3><ul>
<li><p>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等， hashCode 是用来在散列存储结构中确定对象的存储地址的;</p>
</li>
<li><p>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同;</p>
</li>
<li>如果对象的 equals 方法被重写，那么对象的 hashCode 也尽量重写，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，否则就会违反上面提到的第 2 点;</li>
<li>两个对象的 hashCode 相同，并不一定表示两个对象就相同，也就是不一定适用于 equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中.</li>
</ul>
<h3 id="😀-为什么要有-hashCode？"><a href="#😀-为什么要有-hashCode？" class="headerlink" title="😀 为什么要有 hashCode？"></a>😀 为什么要有 hashCode？</h3><p>我们以<code>HashSet</code> 如何检查重复为例子来说明为什么要有 <code>hashCode</code>？</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HastSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="😀-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#😀-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="😀 为什么重写 equals() 时必须重写 hashCode() 方法？"></a>😀 为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而 是一种业务上的对象相等。在这种情况下，原生的 equals 方法就不能满足我 们的需求了，所以这个时候我们需要重写 equals 方法，来满足我们的业务系 统上的需求。</p>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h3 id="😀-包装类型的常量池技术了解么？"><a href="#😀-包装类型的常量池技术了解么？" class="headerlink" title="😀 包装类型的常量池技术了解么？"></a>😀 包装类型的常量池技术了解么？</h3><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<h3 id="😀-自动装箱与拆箱了解吗？原理是什么？"><a href="#😀-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="😀 自动装箱与拆箱了解吗？原理是什么？"></a>😀 自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h3 id="😀-面向对象和面向过程的区别"><a href="#😀-面向对象和面向过程的区别" class="headerlink" title="😀 面向对象和面向过程的区别"></a>😀 面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="😀-成员变量与局部变量的区别有哪些？"><a href="#😀-成员变量与局部变量的区别有哪些？" class="headerlink" title="😀 成员变量与局部变量的区别有哪些？"></a>😀 成员变量与局部变量的区别有哪些？</h3><p><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p>
<p><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p>
<p><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>
<h3 id="😀-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#😀-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="😀 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>😀 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><strong>引用拷贝</strong>就是两个不同的引用指向同一个对象。</p>
<h3 id="😀-字符串常量池的作用了解吗？"><a href="#😀-字符串常量池的作用了解吗？" class="headerlink" title="😀 字符串常量池的作用了解吗？"></a>😀 字符串常量池的作用了解吗？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗专为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
<h3 id="😀-Java-泛型了解么？什么是类型擦除？"><a href="#😀-Java-泛型了解么？什么是类型擦除？" class="headerlink" title="😀 Java 泛型了解么？什么是类型擦除？"></a>😀 Java 泛型了解么？什么是类型擦除？</h3><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。比如我们向一个整型list集合里面添加一个字符，直接调用add方法的话，会报错，但是可以通过反射的方法添加，这就说明在运行期间所有的泛型信息都会被擦掉。</p>
<p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h4 id="泛型的上限和下限？"><a href="#泛型的上限和下限？" class="headerlink" title="泛型的上限和下限？"></a>泛型的上限和下限？</h4><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加是可以的</span></span><br><span class="line"><span class="comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h3 id="😀-常用的通配符有哪些？"><a href="#😀-常用的通配符有哪些？" class="headerlink" title="😀 常用的通配符有哪些？"></a>😀 常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h3 id="😀-何为反射？"><a href="#😀-何为反射？" class="headerlink" title="😀 何为反射？"></a>😀 何为反射？</h3><p>Java 的<strong>反射机制</strong>是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p>
<p><strong>每个类都有一个Class对象</strong>，每当编译一个新类就产生一个Class对象（更恰当地说，是被保存在一个同名的.class文件中）。比如创建一个Student类，那么，JVM就会创建一个Student对应Class类的Class对象，该Class对象保存了Student类相关的类型信息。<strong>Class类的对象作用</strong>是运行时提供或获得某个对象的类型信息。</p>
<p><strong>反射机制优缺点</strong></p>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>
</ul>
<h4 id="😀-获取Class对象的三种方法"><a href="#😀-获取Class对象的三种方法" class="headerlink" title="😀 获取Class对象的三种方法"></a>😀 获取Class对象的三种方法</h4><p><strong>第一种，使用 Class.forName 静态方法。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="attr">class1</span> = Class.forName(<span class="string">&quot;reflection.TestReflection&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种，使用类的.class 方法</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="attr">class2</span> = TestReflection.class<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>第三种，使用实例对象的 getClass() 方法。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestReflection <span class="attr">testReflection</span> = new TestReflection()<span class="comment">;</span></span><br><span class="line">Class <span class="attr">class3</span> = testReflection.getClass()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="😀-如何通过反射创建对象"><a href="#😀-如何通过反射创建对象" class="headerlink" title="😀 如何通过反射创建对象"></a>😀 如何通过反射创建对象</h4><p>通过反射创建类对象主要有两种方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f1b85fc34ce537~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217134322196-20231217153341216.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906191818636-20231217153341423.png" alt="image-20220906191818636"></p>
<h4 id="😀-反射获取类的构造器"><a href="#😀-反射获取类的构造器" class="headerlink" title="😀 反射获取类的构造器"></a>😀 反射获取类的构造器</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f1662225a43b9e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153341589.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906192253508.png" alt="image-20220906192253508"></p>
<h4 id="😀-反射获取类的成员变量"><a href="#😀-反射获取类的成员变量" class="headerlink" title="😀 反射获取类的成员变量"></a>😀 反射获取类的成员变量</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f19b116e71c366~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153341953.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906192603253-20231217153342255.png" alt="image-20220906192603253"></p>
<p>即<code>getField(String name)</code> 根据参数变量名，返回一个具体的具有public属性的成员变量，如果该变量<strong>不是public属性</strong>，则报异常。</p>
<h4 id="😀-反射获取类的方法"><a href="#😀-反射获取类的方法" class="headerlink" title="😀 反射获取类的方法"></a>😀 反射获取类的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f19c250c645069~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153342413.awebp" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f19c70f7446654~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="😀-反射的实现原理"><a href="#😀-反射的实现原理" class="headerlink" title="😀 反射的实现原理"></a>😀 反射的实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906195319527.png" alt="image-20220906195319527"></p>
<p><strong>invoke方法执行时序图</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/16f27996f9e5ed0f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0-20231217153342987.awebp" alt="img"></p>
<p><strong>我们跟着反射链路去看一下源码，先看Method的invoke方法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906195551641-20231217153343236.png" alt="image-20220906195551641"></p>
<p>由上可知道，Method 的 invoke 方法，其实是返回接口MethodAccessor的invoke方法。MethodAccessor接口有三个实现类，到底调用的是哪个类的 invoke 方法呢？进入acquireMethodAccessor方法，可以看到MethodAccessor由ReflectionFactory 的 newMethodAccessor方法决定。再进ReflectionFactory的newMethodAccessor方法，我们可以看到返回的是DelegatingMethodAccessorImpl对象，也就是说调用的是它的invoke方法。再看DelegatingMethodAccessorImpl的invoke方法，DelegatingMethodAccessorImpl的invoke方法返回的是MethodAccessorImpl的invoke方法，而MethodAccessorImpl的invoke方法，由它的子类NativeMethodAccessorImpl重写，这时候返回的是本地方法invoke0。因此，Method的invoke方法，是由本地方法invoke0决定的，再底层就是c++相关了。</p>
<h3 id="😀-反射应用"><a href="#😀-反射应用" class="headerlink" title="😀 反射应用"></a>😀 反射应用</h3><p>反射是Java框架的灵魂技术，很多框架都使用了反射技术，如spring，Mybatis，Hibernate等。</p>
<h4 id="JDBC-的数据库的连接"><a href="#JDBC-的数据库的连接" class="headerlink" title="JDBC 的数据库的连接"></a>JDBC 的数据库的连接</h4><p>在JDBC连接数据库中，一般包括<strong>加载驱动，获得数据库连接</strong>等步骤。而加载驱动，就是引入相关Jar包后，通过<strong>Class.forName()</strong> 即反射技术，加载数据库的驱动程序。</p>
<h4 id="Spring-框架的使用"><a href="#Spring-框架的使用" class="headerlink" title="Spring 框架的使用"></a>Spring 框架的使用</h4><p>Spring 通过 XML 配置模式装载 Bean，也是反射的一个典型例子。</p>
<p><strong>装载过程：</strong></p>
<ul>
<li>将程序内XML 配置文件加载入内存中</li>
<li>Java类解析xml里面的内容，得到相关字节码信息</li>
<li>使用反射机制，得到Class实例</li>
<li>动态配置实例的属性，使用</li>
</ul>
<p><strong>这样做当然是有好处的：</strong></p>
<p>不用每次都去new实例了，并且可以修改配置文件，比较灵活。</p>
<h3 id="😀-反射存在的问题"><a href="#😀-反射存在的问题" class="headerlink" title="😀 反射存在的问题"></a>😀 反射存在的问题</h3><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>java反射的性能并不好，原因主要是编译器没法对反射相关的代码做优化。</p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>我们知道单例模式的设计过程中，会强调<strong>将构造器设计为私有</strong>，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，<strong>修改访问权限</strong>。所以这样并不一定是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906211523209-20231217153343510.png" alt="image-20220906211523209"></p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220906211542614-20231217153343791.png" alt="image-20220906211542614"></p>
<p>显然，反射不管你是不是私有，一样可以调用。 所以，使用反射通常需要程序的运行没有<strong>安全限制</strong>。如果一个程序对安全性有强制要求，最好不要使用反射啦。</p>
<h3 id="😀-反射中，Class-forName和ClassLoader的区别"><a href="#😀-反射中，Class-forName和ClassLoader的区别" class="headerlink" title="😀 反射中，Class.forName和ClassLoader的区别"></a>😀 反射中，Class.forName和ClassLoader的区别</h3><p>Class.forName 和 ClassLoader 都可以对类进行加载。它们区别在哪里呢? ClassLoader 负责加载 Java 类的字节代码到 Java 虚拟机中。 Class.forName 其实是调用了 ClassLoader，如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220908150722829-20231217153343977.png" alt="image-20220908150722829"></p>
<p>这里面，forName0 的第二个参数为 true，表示对加载的类进行初始化。其 实还可以调用 <code>Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>方法实现一样的功能，它的源码如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220908150908273.png" alt="image-20220908150908273"></p>
<p>所以，Class.forName 和 ClassLoader 的区别，就是在类加载的时候， class.forName 有参数控制是否对类进行初始化。</p>
<h3 id="😀-JDK动态代理和cglib实现的区别"><a href="#😀-JDK动态代理和cglib实现的区别" class="headerlink" title="😀 JDK动态代理和cglib实现的区别"></a>😀 JDK动态代理和cglib实现的区别</h3><ul>
<li>java 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。</li>
<li>cglib 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>JDK 动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>cglib 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成 final</li>
</ul>
<h3 id="😀-Java和C语言的区别是什么"><a href="#😀-Java和C语言的区别是什么" class="headerlink" title="😀 Java和C语言的区别是什么"></a>😀 Java和C语言的区别是什么</h3><p>相同的地方：</p>
<p>　　1、语法类似：</p>
<p>　　由于Java可以算是从C++发展而来的，因此Java与C语言的语法比较类似</p>
<p>　　2、编程的熟练程度就是对语言程序库的掌握程度：</p>
<p>　　从某种程度上来说，编程语言都是由语法和相应的程序库所构成，Java有自身的类库，C语言则有标准库。所谓的编程，就是使用与语法来调用和组合程序库中的函数。</p>
<p>　　不同的地方：</p>
<p>　　1、内存管理</p>
<p>　　在Java中，基本不用考虑内存的问题，如果想用一个对象，new一个就可以，这个过程的背后则是JRE为对象分类的一定内存，当JRE发现你不再使用这个对象的时候，他就会自动回收内存，也就是说你只管借东西，不用管归还，因为与有人当你的跟班，在你不使用的时候就把东西归还了，不过这个过程还是有的，只不过是JRE作的而已。</p>
<p>　　但是C则不同，如果你想用，你可以用malloc之类的方法申请内存，当你使用完了，因为没有跟班的，你需要自己把这块内存归还回去，也就是调用free方法来完成这个任务。由于需要显式的归还内存，因此当一个函数需要将一块内存返回给调用者的时候，问题就比较复杂了，不如面向对象和具有内存回收功能的Java那么直观了。对于这个问题，在C语言中，有几种解决方案：</p>
<p>　　（1） 在调用者中先分配好内存，作为参数传入到被调用的函数中</p>
<p>　　（2） 在被调用的函数中分配，使用完后在调用者中释放</p>
<p>　　（3） 在被调用函数中使用static变量，可以将该变量返回</p>
<p>　　2、面向对象</p>
<p>　　Java的面向对象的特点很明显，而C则是一个地道的结构化语言。 Java中有一个字符串类String， 通过调用 String.length（）就可以知道字符串的长度，但是在C语言中，则需要调用函数strlen（str）来得到字符串（字符数组）的长度。由于C不是面向对象的语言，也就没有this的概念，因此当使用一个与某个“东西”相关的函数时，就需要不厌其烦的将代表这个“东西”的变量作为参数传递进去。</p>
<p>　　3、名称空间</p>
<p>　　Java通过包（package）来实现名称空间，在C语言中，所有的函数都处于同一名称空间，也就是没有名称空间，因此就会很多程序提供的api接口函数都有一个前缀，例如MYSQL的mysql<em>init（）， mysql_real_connect（）， mysql_real_query（）等函数名称前面的mysql</em>。</p>
<h3 id="😀-int类型和long类型相加，结果是什么类型"><a href="#😀-int类型和long类型相加，结果是什么类型" class="headerlink" title="😀 int类型和long类型相加，结果是什么类型"></a>😀 int类型和long类型相加，结果是什么类型</h3><p>结果是long类型，int类型会自动进行类型提升</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020905371">https://segmentfault.com/a/1190000020905371</a></p>
<h3 id="😀-int强制转换成byte类型的变量"><a href="#😀-int强制转换成byte类型的变量" class="headerlink" title="😀 int强制转换成byte类型的变量"></a>😀 int强制转换成byte类型的变量</h3><p>我们可以做强制转换，但是在 Java 中，int 是 32 位，byte 是 8 位，如 果强制做转化，int 类型的高 24 位将会被丢弃。</p>
<h3 id="😀-static-关键字有什么作用"><a href="#😀-static-关键字有什么作用" class="headerlink" title="😀 static 关键字有什么作用"></a>😀 static 关键字有什么作用</h3><p>static关键字可以用来修饰代码块表示静态代码块，修饰成员变量表示全局静态成员变量，修饰方法表示静态方法。(注意：不能修饰普通类，除了内部类）</p>
<p>静态是相对于动态的，动态是指Java程序在JVM上运行时，JVM会根据程序的需要动态创建对象并存储对象(分配内存)，对象使命结束后，对象会被垃圾回收器销毁，即内存回收由JVM统一管理并分配给其他新创建的对象；静态是指Java程序还没有运行时，JVM就会为加载的类分配空间存储被static关键字修饰的内容；如静态成员变量，Java类加载到JVM中，JVM会把类以及类的静态成员变量存储在方法区，我们知道方法区是线程共享且很少发生GC的区域，所以被static关键字修饰的内容都是全局共享的，且只会为其分配一次存储空间。</p>
<p>所以当类的某些内容不属于对象，而由对象共享即属于类的时候，就可以考虑是否用static关键字进行修饰。</p>
<p><strong>static关键字的的作用</strong></p>
<p><strong>1 修饰代码块</strong></p>
<p>类中用static关键字修饰的代码块称为静态代码，反之没有用static关键字修饰的代码块称为实例代码块。</p>
<p>实例代码块会随着对象的创建而执行，即每个对象都会有自己的实例代码块，表现出来就是实例代码块的运行结果会影响当前对象的内容，并随着对象的销毁而消失(内存回收)；而静态代码块是当Java类加载到JVM内存中而执行的代码块，由于类的加载在JVM运行期间只会发生一次，所以静态代码块也只会执行一次。</p>
<p>因为静态代码块的主要作用是用来进行一些复杂的初始化工作，所以静态代码块跟随类存储在方法区的表现形式是静态代码块执行的结果存储在方法区，即初始化量存储在方法区并被线程共享。</p>
<p><strong>2 修饰成员变量</strong></p>
<p>类中用static关键字修饰的成员变量称为静态成员变量，因为static不能修饰局部变量(为什么？)，因此静态成员变量也能称为静态变量。静态变量跟代码块类似，在类加载到JVM内存中，JVM会把静态变量放入方法区并分配内存，也由线程共享。访问形式是：类名.静态成员名。</p>
<p>一个类的静态变量和该类的静态代码块的加载顺序。类会优先加载静态变量，然后加载静态代码块，但有多个静态变量和多个代码块时，会按照编写的顺序进行加载。</p>
<p><strong>static关键不能修饰局部变量，包括实例方法和静态方法，不然就会与static关键字的初衷-共享相违背。</strong></p>
<p><strong>3 修饰方法</strong></p>
<p>用static关键字修饰的方法称为静态方法，否则称为实例方法。通过类名.方法名调用，但需要注意静态方法可以直接调用类的静态变量和其他静态方法，不能直接调用成员变量和实例方法(除非通过对象调用)。</p>
<p><strong>注意</strong>：既然类的实例方法需要对象调用才能访问，而静态方法直接通过类名就能访问，那么在不考虑部署服务器的情况下，一个类是如何开始执行的呢？最大的可能就是通过“类名.静态方法”启动Java，而我定义那么多静态方法，JVM又是如何知道主入口呢？</p>
<p>或许，你想到了main方法。</p>
<p>没错，就是main方法被Java规范定义成Java类的主入口。Java类的运行都由main方法开启</p>
<p><strong>static关键字的缺点</strong></p>
<p>封装是Java类的三大特性之一，也是面向对象的主要特性。因为不需要通过对象，而直接通过类就能访问类的属性和方法，这有点破坏类的封装性；所以除了Utils类，代码中应该尽量少用static关键字修饰变量和方法。</p>
<h3 id="😀-Tomcat处理HTTP请求过程分析"><a href="#😀-Tomcat处理HTTP请求过程分析" class="headerlink" title="😀 Tomcat处理HTTP请求过程分析"></a>😀 Tomcat处理HTTP请求过程分析</h3><p>Tomcat是一个web应用服务器，是一个Servlet/Jsp容器，主要负责将客户端请求传递给对应的Servlet，并且将Servlet的响应数据返回给客户端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20181214143933248.jpg" alt=""></p>
<p>Tomcat的心脏是两个核心组件：Connector（连接器）和Container（容器）。其中一个Container可以选择多个Connector。</p>
<p>redirectPort字面意思是重定向端口。当用户用http请求某个资源，而该资源本身又被设置了必须要https方式访问，此时Tomcat会自动重定向到这个redirectPort设置的https端口。</p>
<h4 id="1、Connector组件"><a href="#1、Connector组件" class="headerlink" title="1、Connector组件"></a><strong>1、Connector组件</strong></h4><p>Connector 最重要的功能就是接收连接请求然后分配线程让 Container来处理这个请求，所以这必然是多线程的，多线程的处理是 Connector 设计的核心。Connector监听指定端口上请求，当请求到来时创建一个request和response对象交换数据，然后新建一个线程来处理请求并把request和response传递给Engine组件，最后从Engine获取一个响应并返回给客户端。</p>
<p>Connector组件常用属性说明：</p>
<p>（1） address：指定连接器监听的地址，默认为所有地址，即0.0.0.0，可以自己指定地。（2） maxThreads：支持的最大并发连接数，默认为200；</p>
<p>（3） port：监听的端口；</p>
<p>（4） protocol：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3；</p>
<p>（5） redirectPort：如果某连接器支持的协议是HTTP，当接收客户端发来的HTTPS请求时，则转发至此属性定义的端口；</p>
<p>（6） connectionTimeout：等待客户端发送请求的超时时间，单位为毫秒，默认为60000，即1分钟；</p>
<p>（7） enableLookups：是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名；默认为true； 进行反解的，可以设置为false。</p>
<p>（8） acceptCount：设置等待队列的最大长度；通常在tomcat所有处理线程均处于繁忙状态时，新发来的请求将被放置于等待队列中；</p>
<h4 id="2-container组件"><a href="#2-container组件" class="headerlink" title="2.container组件"></a><strong>2.container组件</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20181214144120710.jpg" alt=""></p>
<p>Container是容器的父接口，该容器的设计用的是典型的责任链的设计模式，它由四个自容器组件构成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。通常一个Servlet class对应一个Wrapper，如果有多个Servlet则定义多个Wrapper，如果有多个Wrapper就要定义一个更高的Container，如Context。 Context定义在父容器 Host 中，其中Host 不是必须的，但是要运行 war 程序，就必须要 Host，因为 war 中必有 web.xml 文件，这个文件的解析就需要 Host 了，如果要有多个 Host 就要定义一个 top 容器 Engine 了。而 Engine 没有父容器了，一个 Engine 代表一个完整的 Servlet 引擎。</p>
<p>2.1、Engine<br>Engine是Servlet处理器的一个实例，即servlet引擎，默认为定义在server.xml中的Catalina。Engine需要defaultHost属性来为其定义一个接收所有请求的虚拟主机host组件。</p>
<p>2.2、Host<br>Host是Engine的子容器。一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用、接收并处理请求、保存一个主机应该有的信息。</p>
<p>常用属性说明：</p>
<p>（1）appBase：此Host的webapps目录，项目存放路径，可以使用绝对路径；</p>
<p>（2）autoDeploy：在Tomcat处于运行状态时放置于appBase目录中的应用程序文件是否自动进行deploy；默认为true；</p>
<p>（3）unpackWars：在启用此webapps时是否对WAR格式的归档文件先进行展开；默认为true；</p>
<p>2.3、Context<br>Context 代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。Context 最重要的功能就是管理它里面的 Servlet 实例，Servlet 实例在 Context 中是以 Wrapper 出现的，还有一点就是 Context 如何才能找到正确的 Servlet 来执行它呢？ Tomcat5 以前是通过一个 Mapper 类来管理的，Tomcat5 以后这个功能被移到了 request 中，在前面的时序图中就可以发现获取子容器都是通过 request 来分配的</p>
<p>常用属性定义：</p>
<p>（1） docBase：相应的Web应用程序的存放位置；也可以使用相对路径，起始路径为此Context所属Host中appBase定义的路径；切记，docBase的路径名不能与相应的Host中appBase中定义的路径名有包含关系，比如，如果appBase为deploy，而docBase绝不能为deploy-bbs类的名字；</p>
<p>（2）path：相对于Web服务器根路径而言的URI；如果为空“”，则表示为此webapp的根路径；如果context定义在一个单独的xml文件中，此属性不需要定义，有可能是别名；</p>
<p>（3） reloadable：是否允许重新加载此context相关的Web应用程序的类；默认为false；</p>
<p>2.4、Wrapper<br>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>2.5、Realm<br>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。 Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p>
<p>2.6、Value<br>Valve类似于过滤器，它可以工作于Engine和Host/Context之间、Host和Context之间以及Context和Web应用程序的某资源之间。一个容器内可以建立多个Valve，而且Valve定义的次序也决定了它们生效的次序。</p>
<h4 id="😀-Tomcat处理一个HTTP请求的过程"><a href="#😀-Tomcat处理一个HTTP请求的过程" class="headerlink" title="😀 Tomcat处理一个HTTP请求的过程"></a>😀 Tomcat处理一个HTTP请求的过程</h4><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20181214144140580-20231217153344781.jpg" alt=""></p>
<p>1.用户在浏览器中输入网址localhost:8080/test/index.jsp，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得；</p>
<p>2.Connector把该请求交给它所在的Service的Engine（Container）来处理，并等待Engine的回应；</p>
<p>3.Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；</p>
<p>4.Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）。名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）；</p>
<p>5.path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL Pattern为*.jsp的Servlet，对应于JspServlet类；</p>
<p>6.构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet()或doPost(),执行业务逻辑、数据存储等；</p>
<p>7.Context把执行完之后的HttpServletResponse对象返回给Host；</p>
<p>8.Host把HttpServletResponse对象返回给Engine；</p>
<p>9.Engine把HttpServletResponse对象返回Connector；</p>
<p>10.Connector把HttpServletResponse对象返回给客户Browser。</p>
<h3 id="😀-a-a-b-与-a-b-的区别"><a href="#😀-a-a-b-与-a-b-的区别" class="headerlink" title="😀 a = a + b 与 a += b 的区别"></a>😀 a = a + b 与 a += b 的区别</h3><p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)</p>
<h3 id="😀-3-0-1-0-3-将会返回什么-true-还是-false"><a href="#😀-3-0-1-0-3-将会返回什么-true-还是-false" class="headerlink" title="😀 3*0.1 == 0.3 将会返回什么? true 还是 false?"></a>😀 3*0.1 == 0.3 将会返回什么? true 还是 false?</h3><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h3 id="😀-this和super关键字的作用"><a href="#😀-this和super关键字的作用" class="headerlink" title="😀 this和super关键字的作用"></a>😀 this和super关键字的作用</h3><p><strong>this:</strong></p>
<ul>
<li>对象内部指代自身的引用</li>
<li>解决成员变量和局部变量同名问题</li>
<li>可以调用成员变量，不能调用局部变量</li>
<li>可以调用成员方法</li>
<li>在普通方法中可以省略 this</li>
<li>在静态方法当中不允许出现 this 关键字</li>
</ul>
<p><strong>super:</strong></p>
<ul>
<li>调用父类的成员或者方法 </li>
<li>调用父类的构造函数</li>
</ul>
<h3 id="😀-this-amp-super-在构造方法中的区别？"><a href="#😀-this-amp-super-在构造方法中的区别？" class="headerlink" title="😀 this() &amp; super()在构造方法中的区别？"></a>😀 this() &amp; super()在构造方法中的区别？</h3><ul>
<li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li>
<li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li>
<li>尽管可以用this调用一个构造器, 却不能调用2个</li>
<li>this和super不能出现在同一个构造器中, 否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ul>
<h3 id="😀-Java移位运算符？"><a href="#😀-Java移位运算符？" class="headerlink" title="😀 Java移位运算符？"></a>😀 Java移位运算符？</h3><p>java中有三种移位运算符</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li>
</ul>
<h3 id="😀-Comparator-与-Comparable-有什么区别"><a href="#😀-Comparator-与-Comparable-有什么区别" class="headerlink" title="😀 Comparator 与 Comparable 有什么区别?"></a>😀 Comparator 与 Comparable 有什么区别?</h3><ul>
<li>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</li>
<li>Comparator 位于包 java.util 下，而 Comparable 位于包 java.lang 下。</li>
<li>Comparable 是一个对象本身就已经支持自比较所需要实现的接口(如String、Integer 自己就可以完成比较大小操作，已经实现了 Comparable 接 口) 自定义的类要在加入 list 容器中后能够排序，可以实现 Comparable 接 口，在用 Collections 类的 sort 方法排序时，如果不指定 Comparator，那么 就以自然顺序排序， 这里的自然顺序就是实现 Comparable 接口设定的排序方式。</li>
<li>而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。</li>
<li>可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。 用 Comparator 是策略模式(strategy design pattern)，就是不改变对象自身，而用一个策略对象(strategy object)来改变它的行为。 比如:你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类(实际上你也不能这么做)去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</li>
</ul>
<h3 id="😀-类的实例化顺序"><a href="#😀-类的实例化顺序" class="headerlink" title="😀 类的实例化顺序"></a>😀 类的实例化顺序</h3><p>父类静态代码块/静态域-&gt;子类静态代码块/静态域 - &gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类非静态代码块 -&gt; 子类构造器</p>
<h3 id="😀-Java创建对象有几种方式"><a href="#😀-Java创建对象有几种方式" class="headerlink" title="😀 Java创建对象有几种方式"></a>😀 Java创建对象有几种方式</h3><p>Java 创建对象有 5 种方式</p>
<ul>
<li>用 new 语句创建对象。</li>
<li>使用反射，使用 Class.newInstance()创建对象/调用类对象的构造方法——Constructor</li>
<li>调用对象的 clone()方法。</li>
<li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject()方法.</li>
<li>使用 Unsafe</li>
</ul>
<h3 id="😀-守护线程是什么？如何实现守护线程"><a href="#😀-守护线程是什么？如何实现守护线程" class="headerlink" title="😀 守护线程是什么？如何实现守护线程"></a>😀 守护线程是什么？如何实现守护线程</h3><ul>
<li>守护线程是运行在后台的一种特殊进程。</li>
<li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li>
<li>在 Java 中垃圾回收线程就是特殊的守护线程。</li>
</ul>
<h3 id="😀-for-each-与常规-for-循环的效率对比"><a href="#😀-for-each-与常规-for-循环的效率对比" class="headerlink" title="😀 for-each 与常规 for 循环的效率对比"></a>😀 for-each 与常规 for 循环的效率对比</h3><p>关于这个问题,《Effective Java》给我们做的解答:</p>
<blockquote>
<p>for-each 能够让代码更加清晰，并且减少了出错的机会。 下面的惯用代码适用于集合与数组类型:</p>
<p>for (Element e : elements) { doSomething(e);</p>
<p>}</p>
<p>使用 for-each 循环与常规的 for 循环相比，并不存在性能损失，即使对数组进 行迭代也是如此。实际上，在有些场合下它还能带来微小的性能提升，因为它 只计算一次数组索引的上限。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://helingcode.github.io">vulkhe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://helingcode.github.io/posts/java-basic.html">https://helingcode.github.io/posts/java-basic.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://helingcode.github.io" target="_blank">vulkhe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/java-collection.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java集合面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/53549.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">启动SpringBoot项目时报错Error parsing HTTP request header</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/java-juc.html" title="Java多线程面试题"><img class="cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Java多线程面试题</div></div></a></div><div><a href="/posts/java-collection.html" title="Java集合面试题"><img class="cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Java集合面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">vulkhe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HelingCode"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HelingCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:linghezhu.if@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-JDK%E5%92%8CJRE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">😀 JDK和JRE有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">😀 Java8的新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%B8%80%E4%B8%AA%E2%80%9D-java%E2%80%9D%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E6%8B%AC%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%88%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">😀 一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E8%AF%B4%E8%AF%B4-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">😀 说说&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%9C%A8JAVA%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%BD%93%E5%89%8D%E7%9A%84%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">😀 在JAVA中如何跳出当前的多重嵌套循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-switch%E8%AF%AD%E5%8F%A5%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8byte%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8long%E4%B8%8A%EF%BC%8C%E8%83%BD%E5%90%A6%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A"><span class="toc-number">6.</span> <span class="toc-text">😀 switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-short-s1-1-s1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99-short-s1-1-s1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%99"><span class="toc-number">7.</span> <span class="toc-text">😀 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错? short s1 &#x3D; 1; s1 +&#x3D; 1;有什么错?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">8.</span> <span class="toc-text">😀 char型变量中能不能存贮一个中文汉字?为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%81-%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%87%A0"><span class="toc-number">9.</span> <span class="toc-text">😁 用最有效率的方法算出2乘以8等于几?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%BD%BF%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E6%98%AF%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%8F%98%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">😀 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E2%80%9C-%E2%80%9D%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%A9%B6%E7%AB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">😀 “&#x3D;&#x3D;”和equals方法究竟有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">😀 什么是值传递和引用传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">😀 静态变量和成员变量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AAstatic%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9Estatic%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">😀 是否可以从一个static方法内部发出对非static方法的调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%AF%E4%BB%A5%E5%9C%A8-static-%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9E-static-%E5%8F%98%E9%87%8F%E5%90%97"><span class="toc-number">15.</span> <span class="toc-text">😀 可以在 static 环境中访问非 static 变量吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">😀 Integer与int的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91-Math-round-11-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-number">17.</span> <span class="toc-text">😀 Math.round(11.5)等于多少? Math.round(-11.5)等于多少?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BD%9C%E7%94%A8%E5%9F%9Fpublic%EF%BC%8Cprivate%EF%BC%8Cprotected%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8D%E5%86%99%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">18.</span> <span class="toc-text">😀 请说出作用域public，private，protected，以及不写时的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Overload-%E9%87%8D%E8%BD%BD-%E5%92%8COverride-%E9%87%8D%E5%86%99-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82Overloaded%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">😀 Overload(重载)和Override(重写)的区别。Overloaded的方法是否可以改变返回值的类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99"><span class="toc-number">20.</span> <span class="toc-text">😀 构造方法是否可以被重写?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%85%B7%E4%BD%93%E7%B1%BB-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9C%89%E9%9D%99%E6%80%81%E7%9A%84main%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">😀 接口是否可继承接口? 抽象类是否可实现接口? 抽象类是否可继承具体类? 抽象类中是否可以有静态的main方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86"><span class="toc-number">22.</span> <span class="toc-text">😀 如何实现对象的克隆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%86%99clone-%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E9%80%9A%E5%B8%B8%E9%83%BD%E6%9C%89%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">😀 写clone()方法时，通常都有一行代码，是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9D%E5%85%AD%E5%8E%9F%E5%88%99%E4%B8%80%E6%B3%95%E5%88%99%E2%80%9D"><span class="toc-number">24.</span> <span class="toc-text">😀 面向对象的”六原则一法则”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-number">25.</span> <span class="toc-text">😀 面向对象的特征有哪些方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">😀 Java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">27.</span> <span class="toc-text">😀 Java为什么不支持多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-abstract-class-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E5%92%8Cinterface-%E6%8E%A5%E5%8F%A3-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">😀 abstract class(抽象类)和interface(接口)有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-abstract%E7%9A%84method%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFstatic-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFnative%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E6%98%AFsynchronized"><span class="toc-number">29.</span> <span class="toc-text">😀 abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">30.</span> <span class="toc-text">😀 什么是内部类？静态内部类和内部类的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%8C%85%E5%90%AB%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">😀 内部类可以引用它的包含类的成员吗？有没有什么限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">😀 匿名内部类是否可以继承其它类，是否可以实现接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">33.</span> <span class="toc-text">😀 匿名内部类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">34.</span> <span class="toc-text">😀 静态内部类与非静态内部类有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-super-getClass-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">35.</span> <span class="toc-text">😀 super.getClass()方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">36.</span> <span class="toc-text">😀 String 为什么是不可变的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">37.</span> <span class="toc-text">😀 String类的常用方法都有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-object%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">😀 object中定义了哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">😀 String、StringBuffer、StringBuilder 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%A6%82%E4%BD%95%E5%B0%86String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">😀 如何将String字符串反转？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String-s-%E2%80%9CHello%E2%80%9D-s-s-%E2%80%9C-world-%E2%80%9D-%E8%BF%99%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%9A%84String%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%B0%E5%BA%95%E5%8F%98%E4%BA%86%E6%B2%A1%E6%9C%89%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">😀 String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAString-Object-%E4%BA%8C%E8%80%85%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">😀 String s &#x3D; new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String-s-%E4%B8%8E-new-String-%E4%B8%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">43.</span> <span class="toc-text">😀 String s 与 new String 与有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-String-%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">44.</span> <span class="toc-text">😀 String 和StringBuffer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-java-lang-String-%E7%B1%BB%EF%BC%8C-%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD-%E4%B8%BA%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">45.</span> <span class="toc-text">😀 在自己的代码中，如果创建一个 java.lang.String 类， 这个类是否可以被类加载器加载?为什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%80%E5%85%B1%E5%88%9B%E5%BB%BA%E4%BA%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1-String-s-%E2%80%9Da%E2%80%9D-%E2%80%9Db%E2%80%9D-%E2%80%9Dc%E2%80%9D-%E2%80%9Dd%E2%80%9D"><span class="toc-number">46.</span> <span class="toc-text">😀 下面这条语句一共创建了多少个对象? String s&#x3D;”a”+”b”+”c”+”d”;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-try-%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AAreturn%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%B4%A7%E8%B7%9F%E5%9C%A8%E8%BF%99%E4%B8%AAtry%E5%90%8E%E7%9A%84finally-%E9%87%8C%E7%9A%84code%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%9C%A8return%E5%89%8D%E8%BF%98%E6%98%AF%E5%90%8E"><span class="toc-number">47.</span> <span class="toc-text">😀 try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-try-catch-finally-return-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">48.</span> <span class="toc-text">😀 try-catch-finally-return 执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">49.</span> <span class="toc-text">😀 final, finally, finalize的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-java%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%EF%BC%9FJDK%E4%B8%BA%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BB%A5%E4%BE%9B%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BB%96%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">😀 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="toc-number">51.</span> <span class="toc-text">😀 Java 中 IO 流分为几种?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">52.</span> <span class="toc-text">😀 字节流与字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">53.</span> <span class="toc-text">😀 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java%E6%BA%90%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">😀 Java源码的编译过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%B8%80%E4%B8%AAObject%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">😀 一个Object占多少字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">56.</span> <span class="toc-text">😀 什么是字节码?采用字节码的好处是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java-%E7%A8%8B%E5%BA%8F%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">57.</span> <span class="toc-text">😀 Java 程序从源代码到运行的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">58.</span> <span class="toc-text">😀 静态方法为什么不能调用非静态成员?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">😀 静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-HashCode%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">60.</span> <span class="toc-text">😀 HashCode的作用是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">😀 为什么要有 hashCode？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">😀 为什么重写 equals() 时必须重写 hashCode() 方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">😀 包装类型的常量池技术了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">😀 自动装箱与拆箱了解吗？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">65.</span> <span class="toc-text">😀 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">😀 成员变量与局部变量的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">😀 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">😀 字符串常量池的作用了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">😀 Java 泛型了解么？什么是类型擦除？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E9%99%90%E5%92%8C%E4%B8%8B%E9%99%90%EF%BC%9F"><span class="toc-number">69.1.</span> <span class="toc-text">泛型的上限和下限？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">70.</span> <span class="toc-text">😀 常用的通配符有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E4%BD%95%E4%B8%BA%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">😀 何为反射？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">71.1.</span> <span class="toc-text">😀 获取Class对象的三种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">71.2.</span> <span class="toc-text">😀 如何通过反射创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">71.3.</span> <span class="toc-text">😀 反射获取类的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">71.4.</span> <span class="toc-text">😀 反射获取类的成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">71.5.</span> <span class="toc-text">😀 反射获取类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">71.6.</span> <span class="toc-text">😀 反射的实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8"><span class="toc-number">72.</span> <span class="toc-text">😀 反射应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">72.1.</span> <span class="toc-text">JDBC 的数据库的连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">72.2.</span> <span class="toc-text">Spring 框架的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">73.</span> <span class="toc-text">😀 反射存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">73.1.</span> <span class="toc-text">性能问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">73.2.</span> <span class="toc-text">安全问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%8F%8D%E5%B0%84%E4%B8%AD%EF%BC%8CClass-forName%E5%92%8CClassLoader%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">74.</span> <span class="toc-text">😀 反射中，Class.forName和ClassLoader的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">75.</span> <span class="toc-text">😀 JDK动态代理和cglib实现的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">76.</span> <span class="toc-text">😀 Java和C语言的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-int%E7%B1%BB%E5%9E%8B%E5%92%8Clong%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%8A%A0%EF%BC%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">77.</span> <span class="toc-text">😀 int类型和long类型相加，结果是什么类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-int%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">78.</span> <span class="toc-text">😀 int强制转换成byte类型的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-static-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">79.</span> <span class="toc-text">😀 static 关键字有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Tomcat%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">80.</span> <span class="toc-text">😀 Tomcat处理HTTP请求过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Connector%E7%BB%84%E4%BB%B6"><span class="toc-number">80.1.</span> <span class="toc-text">1、Connector组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-container%E7%BB%84%E4%BB%B6"><span class="toc-number">80.2.</span> <span class="toc-text">2.container组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%98%80-Tomcat%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">80.3.</span> <span class="toc-text">😀 Tomcat处理一个HTTP请求的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-a-a-b-%E4%B8%8E-a-b-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">81.</span> <span class="toc-text">😀 a &#x3D; a + b 与 a +&#x3D; b 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-3-0-1-0-3-%E5%B0%86%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88-true-%E8%BF%98%E6%98%AF-false"><span class="toc-number">82.</span> <span class="toc-text">😀 3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">83.</span> <span class="toc-text">😀 this和super关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-this-amp-super-%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">84.</span> <span class="toc-text">😀 this() &amp; super()在构造方法中的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">85.</span> <span class="toc-text">😀 Java移位运算符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Comparator-%E4%B8%8E-Comparable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">86.</span> <span class="toc-text">😀 Comparator 与 Comparable 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">87.</span> <span class="toc-text">😀 类的实例化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">88.</span> <span class="toc-text">😀 Java创建对象有几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">89.</span> <span class="toc-text">😀 守护线程是什么？如何实现守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-for-each-%E4%B8%8E%E5%B8%B8%E8%A7%84-for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">90.</span> <span class="toc-text">😀 for-each 与常规 for 循环的效率对比</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e2442faf.html" title="List集合中的过滤方法"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/a467aebd801525568936c94d00561e433d9ad503-20231217161140266.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List集合中的过滤方法"/></a><div class="content"><a class="title" href="/posts/e2442faf.html" title="List集合中的过滤方法">List集合中的过滤方法</a><time datetime="2023-06-01T09:01:12.000Z" title="发表于 2023-06-01 17:01:12">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51bbb0f6.html" title="List集合中排序的几种方法"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/71e52c67f5094e44b92ccaed93db15c5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List集合中排序的几种方法"/></a><div class="content"><a class="title" href="/posts/51bbb0f6.html" title="List集合中排序的几种方法">List集合中排序的几种方法</a><time datetime="2023-05-31T14:57:48.000Z" title="发表于 2023-05-31 22:57:48">2023-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bank.html" title="银行的主营业务和运营模式"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%86%B0%E5%86%B0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行的主营业务和运营模式"/></a><div class="content"><a class="title" href="/posts/bank.html" title="银行的主营业务和运营模式">银行的主营业务和运营模式</a><time datetime="2023-05-25T07:15:24.000Z" title="发表于 2023-05-25 15:15:24">2023-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bank2.html" title="银行会计学笔记"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/ddb5718952d4064e25629c7d1dc4dee50b53f456.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行会计学笔记"/></a><div class="content"><a class="title" href="/posts/bank2.html" title="银行会计学笔记">银行会计学笔记</a><time datetime="2023-05-25T07:15:24.000Z" title="发表于 2023-05-25 15:15:24">2023-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/docker.html" title="Docker的安装及常用命令"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20220820192714_c20e6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker的安装及常用命令"/></a><div class="content"><a class="title" href="/posts/docker.html" title="Docker的安装及常用命令">Docker的安装及常用命令</a><time datetime="2023-05-03T07:15:24.000Z" title="发表于 2023-05-03 15:15:24">2023-05-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By vulkhe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"><img class="icp-icon" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/beian_logo-20231217160134340.png"><span>苏ICP备2021044866号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://helingcode.github.io/posts/java-basic.html'
    this.page.identifier = '/posts/java-basic.html'
    this.page.title = 'Java基础'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://cstube.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>