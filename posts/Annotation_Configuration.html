<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>深入理解@Configuration注解 | vulkhe's blog</title><meta name="keywords" content="IOC容器"><meta name="author" content="vulkhe"><meta name="copyright" content="vulkhe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@Configuration注解可以标注到类上，当标注到类上时，启动Spring就会自动扫描@Configuration注解标注的类，将其注册到IOC容器中，并被实例化成Bean对象。如果被@Configuration注解标注的类中存在使用@Bean注解标注的创建某个类对象的方法，那么，Spring也会自动执行使用@Bean注解标注的方法，将对应的Bean定义信息注册到IOC容器，并进行实例化。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解@Configuration注解">
<meta property="og:url" content="https://helingcode.github.io/posts/Annotation_Configuration.html">
<meta property="og:site_name" content="vulkhe&#39;s blog">
<meta property="og:description" content="@Configuration注解可以标注到类上，当标注到类上时，启动Spring就会自动扫描@Configuration注解标注的类，将其注册到IOC容器中，并被实例化成Bean对象。如果被@Configuration注解标注的类中存在使用@Bean注解标注的创建某个类对象的方法，那么，Spring也会自动执行使用@Bean注解标注的方法，将对应的Bean定义信息注册到IOC容器，并进行实例化。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/p2889295883.jpg">
<meta property="article:published_time" content="2023-04-16T06:58:57.000Z">
<meta property="article:modified_time" content="2023-04-16T12:27:42.234Z">
<meta property="article:author" content="vulkhe">
<meta property="article:tag" content="IOC容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/p2889295883.jpg"><link rel="shortcut icon" href="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg"><link rel="canonical" href="https://helingcode.github.io/posts/Annotation_Configuration"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: vulkhe","link":"链接: ","source":"来源: vulkhe's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解@Configuration注解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-16 20:27:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="vulkhe's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/p2889295883.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">vulkhe's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深入理解@Configuration注解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-16T06:58:57.000Z" title="发表于 2023-04-16 14:58:57">2023-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-16T12:27:42.234Z" title="更新于 2023-04-16 20:27:42">2023-04-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深入理解@Configuration注解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>@Configuration</code>注解可以标注到类上，当标注到类上时，启动Spring就会自动扫描<code>@Configuration</code>注解标注的类，将其注册到IOC容器中，并被实例化成Bean对象。如果被<code>@Configuration</code>注解标注的类中存在使用<code>@Bean</code>注解标注的创建某个类对象的方法，那么，Spring也会自动执行使用<code>@Bean</code>注解标注的方法，将对应的Bean定义信息注册到IOC容器，并进行实例化。</p>
<h2 id="注解详解"><a href="#注解详解" class="headerlink" title="注解详解"></a>注解详解</h2><p><code>@Configuration</code>注解是从Spring 3.0版本开始加入的一个使Spring能够支持注解驱动开发的标注型注解，主要用于标注在类上。当某个类标注了<code>@Configuration</code>注解时，表示这个类是Spring的一个配置类。<code>@Configuration</code>注解能够替代Spring的<code>applicationContext.xml</code>文件，并且被<code>@Configuration</code>注解标注的类，能够自动注册到IOC容器并进行实例化。</p>
<h3 id="注解源码"><a href="#注解源码" class="headerlink" title="注解源码"></a>注解源码</h3><p>源码详见：org.springframework.context.annotation.Configuration。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//Since: 5.2</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//Since: 6.0</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">enforceUniqueMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>@Configuration</code>注解中每个属性的含义如下所示。</p>
<ul>
<li>value：存入到Spring IOC容器中的Bean的id。</li>
<li>proxyBeanMethods：从Spring 5.2版本开始加入到<code>@Configuration</code>注解，表示被<code>@Configuration</code>注解标注的配置类是否会被代理，并且在配置类中使用<code>@Bean</code>注解生成的Bean对象在IOC容器中是否是单例对象，取值为true或者false。当取值为true时，表示full（全局）模式，此模式下被<code>@Configuration</code>注解标注的配置类会被代理，在配置类中使用<code>@Bean</code>注解注入到IOC容器中的Bean对象是单例模式，无论调用多少次被<code>@Bean</code>注解标注的方法，返回的都是同一个Bean对象。当取值为false时，表示lite（轻量级）模式，此模式下被<code>@Configuration</code>注解标注的配置类不会被代理，在配置类中使用<code>@Bean</code>注解注入到IOC容器中的Bean对象不是单例模式，每次调用被<code>@Bean</code>注解标注的方法时，都会返回一个新的Bean对象。默认的取值为true。</li>
<li>enforceUniqueMethods：从Spring 6.0开始加入到<code>@Configuration</code>注解，指定使用<code>@Bean</code>注解标注的方法是否需要具有唯一的方法名称，取值为true或者false。当取值为true时，表示使用<code>@Bean</code>注解标注的方法具有唯一的方法名称，并且这些方法名称不会重叠。当取值为false时，表示使用<code>@Bean</code>注解标注的方法名称不唯一，存在被重叠的风险。默认取值为true。</li>
</ul>
<p>从<code>@Configuration</code>注解的源码也可以看出，<code>@Configuration</code>注解本质上是一个<code>@Component</code>注解，所以，被@Configuration注解标注的配置类本身也会被注册到IOC容器中。同时，<code>@Configuration</code>注解也会被<code>@ComponentScan</code>注解扫描到。</p>
<h3 id="注解使用场景"><a href="#注解使用场景" class="headerlink" title="注解使用场景"></a>注解使用场景</h3><p>基于Spring的注解开发应用程序时，可以将<code>@Configuration</code>注解标注到某个类上。当某个类被<code>@Configuration</code>注解标注时，说明这个类是配置类，可以在这个类中使用<code>@Bean</code>注解向IOC容器中注入Bean对象，也可以使用<code>@Autowired</code>、<code>@Inject</code>和<code>@Resource</code>等注解来注入所需的Bean对象。</p>
<p>注意：基于Spring的注解模式开发应用程序时，在使用<code>AnnotationConfigApplicationContext</code>类创建IOC容器时，需要注意如下事项：</p>
<p>（1）如果调用的是<code>AnnotationConfigApplicationContext</code>类中传入Class类型可变参数的构造方法来创建IOC容器，表示传入使用<code>@Configuration</code>注解标注的配置类的Class对象来创建IOC容器，则标注到配置类上的@Configuration注解可以省略。</p>
<p>AnnotationConfigApplicationContext类中传入Class类型可变参数的构造方法源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）如果调用的是AnnotationConfigApplicationContext类中传入String类型可变参数的构造方法来创建IOC容器，表示传入应用程序的包名来创建IOC容器，则标注到配置类上的@Configuration注解不能省略。</p>
<p>AnnotationConfigApplicationContext类中传入String类型可变参数的构造方法源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    scan(basePackages);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>另外，当调用的是AnnotationConfigApplicationContext类中传入Class类型可变参数的构造方法来创建IOC容器时，如果传入的配置类上省略了<code>@Configuration</code>注解，则每次调用配置类中被<code>@Bean</code>注解标注的方法时，都会返回不同的Bean实例对象。</p>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>简单介绍使用@Configuration注解的几个案例程序。</p>
<h3 id="验证proxyBeanMethods属性的作用"><a href="#验证proxyBeanMethods属性的作用" class="headerlink" title="验证proxyBeanMethods属性的作用"></a>验证proxyBeanMethods属性的作用</h3><p>在1.1节已经详细介绍过<code>@Configuration</code>注解中proxyBeanMethods属性的作用，proxyBeanMethods属性可取值为true或者false。取值为true时，无论调用多少次在被<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法，返回的都是同一个Bean对象。取值为false时，每次调用在被<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法，都回返回不同的Bean对象。</p>
<h4 id="验证proxyBeanMethods取值为true的情况"><a href="#验证proxyBeanMethods取值为true的情况" class="headerlink" title="验证proxyBeanMethods取值为true的情况"></a>验证proxyBeanMethods取值为true的情况</h4><p>具体的案例实现步骤如下所示。</p>
<p>（1）创建Person类</p>
<p>Person类主要是用来注册到IOC容器中，并实例化对象，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）创建ConfigurationAnnotationConfig类</p>
<p>ConfigurationAnnotationConfig类的作用就是充当程序启动的配置类，会在ConfigurationAnnotationConfig类上标注<code>@Configuration</code>注解，说明ConfigurationAnnotationConfig类是Spring启动时的配置类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在ConfigurationAnnotationConfig类上标注了<code>@Configuration</code>注解，由于<code>@Configuration</code>注解中的proxyBeanMethods属性默认为true，所以在ConfigurationAnnotationConfig类上的<code>@Configuration</code>注解省略了proxyBeanMethods属性。</p>
<p>（3）创建ConfigurationAnnotationTest类</p>
<p>ConfigurationAnnotationTest类的作用就是整个案例程序的启动类，对整个案例程序进行测试，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(ConfigurationAnnotationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigurationAnnotationConfig.class);</span><br><span class="line">        <span class="type">ConfigurationAnnotationConfig</span> <span class="variable">config</span> <span class="operator">=</span> context.getBean(ConfigurationAnnotationConfig.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> config.person();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> config.person();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;person1 是否等于 person2 ===&gt;&gt; &#123;&#125;&quot;</span>, (person1 == person2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在ConfigurationAnnotationTest类的main()方法中，首先基于AnnotationConfigApplicationContext创建了IOC容器context，从context中获取了ConfigurationAnnotationConfig类的Bean实例对象config，接下来，调用两次config的person()方法分别赋值给Person类型的局部变量person1和person2，最后打印person1是否等于person2的日志。</p>
<p>（4）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>通过输出的结果信息可以看出，person1是否等于person2输出的结果为true。说明当<code>@Configuration</code>注解中的proxyBeanMethods属性为true时，每次调用使用<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法时，都会返回同一个Bean实例对象。</p>
<h4 id="验证proxyBeanMethods取值为false的情况"><a href="#验证proxyBeanMethods取值为false的情况" class="headerlink" title="验证proxyBeanMethods取值为false的情况"></a>验证proxyBeanMethods取值为false的情况</h4><p>验证<code>@Configuration</code>注解中的proxyBeanMethods属性为false的情况，与验证proxyBeanMethods属性为true的情况的案例程序基本一致，只是将ConfigurationAnnotationConfig类上标注的<code>@Configuration</code>注解的proxyBeanMethods属性设置为false，案例实现的具体步骤如下所示。</p>
<p>（1）修改proxyBeanMethods属性的值</p>
<p>修改后的ConfigurationAnnotationConfig类的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此时在ConfigurationAnnotationConfig类上标注的<code>@Configuration</code>注解的proxyBeanMethods属性为false。</p>
<p>（2）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看出，person1是否等于person2输出的结果为false。说明当<code>@Configuration</code>注解中的proxyBeanMethods属性为false时，每次调用使用<code>@Configuration</code>注解标注的类中被<code>@Bean</code>注解标注的方法时，都会返回不同的Bean实例对象。</p>
<h3 id="传入配置类创建IOC容器"><a href="#传入配置类创建IOC容器" class="headerlink" title="传入配置类创建IOC容器"></a>传入配置类创建IOC容器</h3><p>调用AnnotationConfigApplicationContext类的构造方法传入配置类的Class对象创建IOC容器时，可以省略配置类上的<code>@Configuration</code>注解，案例的具体实现步骤如下所示。</p>
<p>（1）删除<code>@Configuration</code>注解</p>
<p>删除ConfigurationAnnotationConfig类上的@Configuration注解，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看到，输出了person1是否等于person2的结果为false。说明调用AnnotationConfigApplicationContext类的构造方法传入配置类的Class对象创建IOC容器时，可以省略配置类上的<code>@Configuration</code>注解，此时每次调用配置类中被<code>@Bean</code>注解标注的方法时，都会返回不同的Bean实例对象。</p>
<h3 id="传入包名创建IOC容器"><a href="#传入包名创建IOC容器" class="headerlink" title="传入包名创建IOC容器"></a>传入包名创建IOC容器</h3><p>调用AnnotationConfigApplicationContext类的构造方法传入包名创建IOC容器时，不能省略配置类上的<code>@Configuration</code>注解，案例的具体实现步骤如下所示。</p>
<p>（1）修改测试类</p>
<p>修改ConfigurationAnnotationTest类的main()方法中，创建AnnotationConfigApplicationContext对象的代码，将调用传入Class对象的构造方法修改为调用传入String对象的方法，修改后的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(ConfigurationAnnotationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;io.binghe.spring.annotation.chapter01.configuration&quot;</span>);</span><br><span class="line">        <span class="type">ConfigurationAnnotationConfig</span> <span class="variable">config</span> <span class="operator">=</span> context.getBean(ConfigurationAnnotationConfig.class);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> config.person();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> config.person();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;person1 是否等于 person2 ===&gt;&gt; &#123;&#125;&quot;</span>, (person1 == person2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）删除<code>@Configuration</code>注解</p>
<p>删除ConfigurationAnnotationConfig类上的<code>@Configuration</code>注解，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）测试案例</p>
<p>运行ConfigurationAnnotationTest类的main()方法，可以看到程序抛出了异常信息，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of <span class="built_in">type</span> <span class="string">&#x27;io.binghe.spring.annotation.chapter01.configuration.config.ConfigurationAnnotationConfig&#x27;</span> available</span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看出，调用AnnotationConfigApplicationContext类的构造方法传入包名创建IOC容器时，不能省略配置类上的<code>@Configuration</code>注解，否则会抛出NoSuchBeanDefinitionException。</p>
<p>（4）添加<code>@Configuration</code>注解</p>
<p>在ConfigurationAnnotationConfig类上添加<code>@Configuration</code>注解，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationAnnotationConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）再次测试案例</p>
<p>再次运行ConfigurationAnnotationTest类的main()方法，输出的结果信息如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1 是否等于 person2 ===&gt;&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>从输出的结果信息可以看到，输出了person1是否等于person2的结果为true，再次说明调用AnnotationConfigApplicationContext类的构造方法传入包名创建IOC容器时，不能省略配置类上的<code>@Configuration</code>注解。</p>
<h2 id="源码时序图"><a href="#源码时序图" class="headerlink" title="源码时序图"></a>源码时序图</h2><p>就<code>@Configuration</code>注解本身而言，在源码层面的执行流程涉及到注册与实例化两种执行流程，就注册流程而言，会涉及到Spring内部的ConfigurationClassPostProcessor类的Bean定义信息的注册流程，以及案例中标注了<code>@Configuration</code>注解的ConfigurationAnnotationConfig配置类的Bean定义信息注册流程。</p>
<p>本节，就简单介绍下<code>@Configuration</code>注解在源码层面的注册与实例化两种执行时序图。</p>
<p><strong>注意：源码时序图和源码解析均以案例程序作为入口进行分析，并且会在ConfigurationAnnotationConfig类上标注@Configuration注解，同时在ConfigurationAnnotationTest测试类中，调用AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法来创建IOC容器。</strong></p>
<h3 id="注册ConfigurationClassPostProcessor流程源码时序图"><a href="#注册ConfigurationClassPostProcessor流程源码时序图" class="headerlink" title="注册ConfigurationClassPostProcessor流程源码时序图"></a>注册ConfigurationClassPostProcessor流程源码时序图</h3><p>ConfigurationClassPostProcessor后置处理器是解析<code>@Configuration</code>注解的核心类，也是Spring中的一个非常重要的后置处理器类，Spring IOC容器启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息。向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息的时序图如下图1-1所示。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/spring-core-2022-12-05-001.png" alt="图1-1"></p>
<p>由图可以看出，Spring IOC容器启动时，向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息时，会涉及到AnnotationConfigApplicationContext类、AnnotatedBeanDefinitionReader类和AnnotationConfigUtils类中方法的调用。具体源码的调用细节见源码解析部分。</p>
<h3 id="注册ConfigurationAnnotationConfig流程源码时序图"><a href="#注册ConfigurationAnnotationConfig流程源码时序图" class="headerlink" title="注册ConfigurationAnnotationConfig流程源码时序图"></a>注册ConfigurationAnnotationConfig流程源码时序图</h3><p>ConfigurationAnnotationConfig类是案例程序的配置类，在ConfigurationAnnotationConfig类上标注了<code>@Configuration</code>注解，当Spring IOC容器启动时，也会将ConfigurationAnnotationConfig类的Bean定义信息注册到Spring IOC容器中，向Spring IOC容器中注册ConfigurationAnnotationConfig类的Bean定义信息的时序图如下图1-2所示。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/spring-core-2022-12-05-002.png" alt="图1-2"></p>
<p>由图可以看出，Spring IOC容器启动时，向IOC容器中注册ConfigurationAnnotationConfig类的Bean定义信息时，会涉及到AnnotationConfigApplicationContext类、AnnotatedBeanDefinitionReader类、BeanDefinitionReaderUtils类和DefaultListableBeanFactory类的方法调用，具体的源码调用细节见源码解析部分。</p>
<p><strong>注意：Spring IOC容器在启动时，会向IOC容器中注册ConfigurationClassPostProcessor类的bean定义信息和使用@Configuration注解标注的ConfigurationAnnotationConfig配置类的Bean定义信息。当Spring IOC容器在刷新时，会递归处理所有使用@Configuration注解标注的类，解析@Bean等注解标注的方法，解析成一个个ConfigurationClassBeanDefinition类型的BeanDefinition对象，注册到IOC容器中。</strong></p>
<h3 id="实例化流程源码时序图"><a href="#实例化流程源码时序图" class="headerlink" title="实例化流程源码时序图"></a>实例化流程源码时序图</h3><p>Spring IOC容器在启动过程中，最终会调用AnnotationConfigApplicationContext类的refresh()方法刷新IOC容器，刷新IOC容器的过程中就会对标注了<code>@Configuration</code>注解的配置类进行实例化。本节，就结合案例程序简单分析下刷新IOC容器时，对标注了<code>@Configuration</code>注解的配置类进行实例化的源码时序图，源码时序图如下图1-3-1，1-3-2所示。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/spring-core-2022-12-05-003.png" alt="图1-3-1"></p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/spring-core-2022-12-05-004.png" alt="图1-3-2"></p>
<p>由图可以看出，刷新IOC容器时，对标注了<code>@Configuration</code>注解的配置类进行实例化时，会涉及到AnnotationConfigApplicationContext类、AbstractApplicationContext类、PostProcessorRegistrationDelegate类、ConfigurationClassPostProcessor类和ConfigurationClassEnhancer类方法的调用，具体方法调用的细节见源码解析部分。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>本节，同样按照注册流程和实例化流程来深入分析<code>@Configuration</code>注解在Spring源码层面的执行流程。</p>
<h3 id="注册ConfigurationClassPostProcessor流程源码解析"><a href="#注册ConfigurationClassPostProcessor流程源码解析" class="headerlink" title="注册ConfigurationClassPostProcessor流程源码解析"></a>注册ConfigurationClassPostProcessor流程源码解析</h3><p><code>@Configuration</code>注解涉及到ConfigurationClassPostProcessor类的Bean定义信息的注册流程的源码执行过程可结合图1-1进行分析。启动Spring IOC容器时，<code>@Configuration</code>注解涉及到的ConfigurationClassPostProcessor核心类的注册流程的源码执行过程如下所示。</p>
<p>（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigurationAnnotationConfig.class);</span><br><span class="line">	<span class="comment">//#############省略其他代码##################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在main()方法中会调用AnnotationConfigApplicationContext类的构造方法传入配置类ConfigurationAnnotationConfig的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。</p>
<p>（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述构造方法中，会通过this()调用AnnotationConfigApplicationContext类的无参构造方法。</p>
<p>（3）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext()无参构造方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StartupStep</span> <span class="variable">createAnnotatedBeanDefReader</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    createAnnotatedBeanDefReader.end();</span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigApplicationContext类的无参构造方法中，主要的逻辑就是实例化了AnnotatedBeanDefinitionReader类型的reader成员变量和ClassPathBeanDefinitionScanner类型的scanner成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">AnnotationConfigRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">createAnnotatedBeanDefReader</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">        createAnnotatedBeanDefReader.end();</span><br><span class="line">        <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>reader：表示注解类型的Bean定义信息读取器，主要就是读取通过注解方式进行实例化的Bean的定义信息。</li>
<li>scanner：表示类路径下的Bean定义扫描器，主要就是扫描类路径下的Bean定义信息。</li>
</ul>
<p><code>@Configuration</code>注解涉及到的注册流程源码的执行过程，会执行实例化reader成员变量的代码，也就是下面的代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，会调用AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法。</p>
<p>（4）解析AnnotatedBeanDefinitionReader类中的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry)构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述构造方法中，通过this调用了AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20230416183717528.png" alt="image-20230416183717528"></p>
<p>（5）解析AnnotatedBeanDefinitionReader类的AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment)构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在上述构造方法中，最核心的逻辑就是调用了AnnotationConfigUtils工具类的registerAnnotationConfigProcessors()方法，将BeanDefinitionRegistry类型的registry对象传入方法中。其中，registry对象本质上就是一个AnnotationConfigApplicationContext类对象的实例，这是因为AnnotationConfigApplicationContext类继承了GenericApplicationContext类，而GenericApplicationContext类实现了BeanDefinitionRegistry接口。</p>
<p>（6）解析AnnotationConfigUtils类的<code>registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry)方法中调用了AnnotationConfigUtils类中的另外一个registerAnnotationConfigProcessors()方法。</p>
<p>（7）解析AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法</p>
<p>这里，只给出在AnnotationConfigUtils类的registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法中，将@Configuration注解涉及到的ConfigurationClassPostProcessor类的Bean定义信息注册到IOC容器中的核心代码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">			BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="comment">//################省略其他代码########################</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//################省略其他代码########################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，会调用registerPostProcessor()方法注册后置处理器。</p>
<p>（8）解析registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title function_">registerPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> &#123;</span><br><span class="line">    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上述代码中，调用了registry参数的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息，definition参数本质上就是一个AnnotationConfigApplicationContext类的实例对象。最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法来注册ConfigurationClassPostProcessor类的Bean定义信息。</p>
<p>（9）解析DefaultListableBeanFactory类的registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法</p>
<p>源码详见：org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition(String beanName, BeanDefinition beanDefinition)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">//##################省略其他代码###############</span></span><br><span class="line">	<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="comment">//##################省略其他代码###############</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可知，向Spring的IOC容器中注册类的Bean定义信息，其实就是向beanDefinitionMap对象中添加元素，beanDefinitionMap对象本质上是一个ConcurrentHashMap对象。向beanDefinitionMap对象中添加的元素的Key为Bean的名称，Value为Bean的定义信息。</p>
<p>beanDefinitionMap源码详见：org.springframework.beans.factory.support.DefaultListableBeanFactory#beanDefinitionMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
<p>至此，<code>@Configuration</code>注解涉及到的ConfigurationClassPostProcessor类的注册过程分析完毕。</p>
<h3 id="注册ConfigurationAnnotationConfig流程源码解析"><a href="#注册ConfigurationAnnotationConfig流程源码解析" class="headerlink" title="注册ConfigurationAnnotationConfig流程源码解析"></a>注册ConfigurationAnnotationConfig流程源码解析</h3><p>使用<code>@Configuration</code>注解标注的ConfigurationAnnotationConfig类的Bean定义信息的注册流程的源码执行过程可结合图1-2进行分析，启动Spring IOC容器时，向IOC容器中注册ConfigurationAnnotationConfig类的Bean定义信息的源码执行过程如下所示。</p>
<p>（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法，并进入AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法。</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)方法中调用了register()方法，传入componentClasses参数进行注册。</p>
<p>（2）解析AnnotationConfigApplicationContext类的register(Class&lt;?&gt;… componentClasses)方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#register(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">	<span class="comment">//###########省略其他代码##############</span></span><br><span class="line">    <span class="built_in">this</span>.reader.register(componentClasses);</span><br><span class="line">    <span class="comment">//###########省略其他代码##############</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在register(Class&lt;?&gt;… componentClasses)方法中调用了reader的register()方法。</p>
<p>（3）解析AnnotatedBeanDefinitionReader类的register(Class&lt;?&gt;… componentClasses)方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotatedBeanDefinitionReader#register(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在register(Class&lt;?&gt;… componentClasses)方法中，会循环遍历传入的可变参数componentClasses，每次循环时，都会调用registerBean()方法。</p>
<p>（4）解析AnnotatedBeanDefinitionReader类的registerBean(Class&lt;?&gt; beanClass)方法</p>
<p>源码详见：org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(Class&lt;?&gt; beanClass)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在registerBean(Class&lt;?&gt; beanClass)方法中调用了doRegisterBean()方法。</p>
<p>5）解析AnnotatedBeanDefinitionReader类的doRegisterBean(Class beanClass, String name, Class&lt;? extends Annotation&gt;[] qualifiers, Supplier supplier, BeanDefinitionCustomizer[] customizers)方法。</p>
<p>源码详见：org.springframework.context.annotation.AnnotatedBeanDefinitionReader#doRegisterBean(Class beanClass, String name, Class&lt;? extends Annotation&gt;[] qualifiers, Supplier supplier, BeanDefinitionCustomizer[] customizers)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier, <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(beanClass);</span><br><span class="line">    <span class="comment">//###########################省略其他代码#############################</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line">    <span class="comment">//###########################省略其他代码#############################</span></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在doRegisterBean(Class beanClass, String name, Class&lt;? extends Annotation&gt;[] qualifiers, Supplier supplier, BeanDefinitionCustomizer[] customizers)方法中调用了BeanDefinitionReaderUtils类的registerBeanDefinition()方法。</p>
<p>（6）解析BeanDefinitionReaderUtils类的registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法</p>
<p>源码详见：org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">//###########################省略其他代码#############################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)方法中通过调用registry的registerBeanDefinition()方法来向IOC容器中注册Bean定义信息。</p>
<p><strong>注意：到目前为止，后续向IOC容器注册Bean定义信息的源码执行流程与向IOC容器中注册ConfigurationClassPostProcessor类的Bean定义信息的源码执行流程基本相同，这里不再赘述。</strong></p>
<h3 id="实例化流程源码解析"><a href="#实例化流程源码解析" class="headerlink" title="实例化流程源码解析"></a>实例化流程源码解析</h3><p>Spring IOC容器在刷新时，会实例化使用<code>@Configuration</code>注解标注的类，可结合图1-3-1和图1-3-2理解，具体的源码执行流程如下所示。</p>
<p>（1）运行案例程序启动类ConfigurationAnnotationTest的main()方法，并进入AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法。</p>
<p>源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在AnnotationConfigApplicationContext(Class&lt;?&gt;… componentClasses)构造方法中会调用refresh()方法刷新IOC容器。</p>
<p>（2）解析AbstractApplicationContext类的refresh()方法</p>
<p>源码详见：org.springframework.context.support.AbstractApplicationContext#refresh()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">			<span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">           <span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//#############省略其他代码#####################</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在refresh()方法中调用了invokeBeanFactoryPostProcessors()方法。</p>
<p>（3）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">	<span class="comment">//################省略其他代码####################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法中调用了PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors()方法。</p>
<p>（4）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List beanFactoryPostProcessors)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List beanFactoryPostProcessors)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line">	<span class="comment">//#################省略其他代码##################</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">//#################省略其他代码##################</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在invokeBeanFactoryPostProcessors()方法中会解析标注了<code>@Configuration</code>注解的类中标注了<code>@Bean</code>等注解的方法，生成相应的Bean定义信息注册到IOC容器中。这里，主要关注的是标注了<code>@Configuration</code>注解的类的实例化过程，所以，只需要关注invokeBeanFactoryPostProcessors()方法中的上述代码片段即可。</p>
<p>可以看到，在invokeBeanFactoryPostProcessors()方法中又调用了PostProcessorRegistrationDelegate类中的另一个invokeBeanFactoryPostProcessors()方法。</p>
<p>（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">postProcessBeanFactory</span> <span class="operator">=</span> beanFactory.getApplicationStartup().start(<span class="string">&quot;spring.context.bean-factory.post-process&quot;</span>)</span><br><span class="line">            .tag(<span class="string">&quot;postProcessor&quot;</span>, postProcessor::toString);</span><br><span class="line">        postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">        postProcessBeanFactory.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>可以看到，在invokeBeanFactoryPostProcessors()方法中，会循环遍历传递进来的所有postProcessors集合，每次循环时，都会使用一个postProcessor对象来接收postProcessors集合中的每一个元素，调用postProcessor对象的postProcessBeanFactory()方法，并传入beanFactory来实例化对象。</p>
<p>（6）解析ConfigurationClassPostProcessor类中的postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ImportAwareBeanPostProcessor</span>(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)方法中调用了enhanceConfigurationClasses()方法。</p>
<p>（7）解析ConfigurationClassPostProcessor类的enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">//################省略其他代码########################</span></span><br><span class="line">    <span class="type">ConfigurationClassEnhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassEnhancer</span>();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.getBeanClass();</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">            <span class="comment">//################省略其他代码###################</span></span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhanceConfigClasses.tag(<span class="string">&quot;classCount&quot;</span>, () -&gt; String.valueOf(configBeanDefs.keySet().size())).end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory)方法中，主要是使用ConfigurationClassEnhancer对象的enhance()方法生成代理类，也就是使用CGLib生成代理类。</p>
<p>（8）解析ConfigurationClassEnhancer类的enhance(Class&lt;?&gt; configClass, ClassLoader classLoader)方法</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="comment">//###################省略其他代码###############</span></span><br><span class="line">    Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line">    <span class="comment">//###################省略其他代码###############</span></span><br><span class="line">    <span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在enhance(Class&lt;?&gt; configClass, ClassLoader classLoader)方法中调用了createClass()方法创建代理类，在这之前先调用newEnhancer()方法实例化Enhancer对象。</p>
<p>（9）解析ConfigurationClassEnhancer类的newEnhancer(Class&lt;?&gt; configSuperClass, ClassLoader classLoader)方法</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Enhancer <span class="title function_">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    enhancer.setSuperclass(configSuperClass);</span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="literal">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setAttemptLoad(<span class="literal">true</span>);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">BeanFactoryAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，newEnhancer()方法中主要是生成CGLib动态代理的Enhancer对象，后续会使用Enhancer对象生成代理类。</p>
<p>在newEnhancer()方法中为要生成的代理类设置了父类和接口，由于为要生成的代理类设置的接口为EnhancedConfiguration，同时，EnhancedConfiguration接口继承了BeanFactoryAware接口，所以，在后续生成的代理类中可以调用BeanFactoryAware接口的setBeanFactory(BeanFactory beanFactory)方法获取到beanFactory对象。</p>
<p>（10）解析ConfigurationClassEnhancer类的createClass(Enhancer enhancer)方法</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#createClass(Enhancer enhancer)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createClass(Enhancer enhancer) &#123;</span><br><span class="line">    Class&lt;?&gt; subclass = enhancer.createClass();</span><br><span class="line">    Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在createClass(Enhancer enhancer)方法中，主要调用了enhancer对象的createClass()方法来创建代理类，因为使用CGLib创建出来的代理类是目标类的子类，所以，这里创建出来的代理类就是目标类的子类。</p>
<p>最后，再来关注下Enhancer类中传入的CALLBACKS参数。</p>
<p>（11）解析CALLBACKS</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer#CALLBACKS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> <span class="title class_">Callback</span>[] &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BeanMethodInterceptor</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BeanFactoryAwareMethodInterceptor</span>(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，CALLBACKS是一个Callback类型的数组，数组中的每个元素都是一个Callback类型的对象。其中，BeanMethodInterceptor类和BeanFactoryAwareMethodInterceptor类也是拦截器类型。接下来，以BeanMethodInterceptor类为例进行介绍。</p>
<p>（12）解析BeanMethodInterceptor类</p>
<p>源码详见：org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor。</p>
<p>BeanMethodInterceptor实现了MethodInterceptor接口和ConditionalCallback接口，主要的作用就是对标注了@Bean的注解的方法进行拦截，执行intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy)方法，生成Bean的实例对象。在方法中有如下一段代码逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span></span><br><span class="line"><span class="params">					MethodProxy cglibMethodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//如果已经创建了Bean的代理实例对象，则调用父类的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">        <span class="comment">//#################省略其他代码###############</span></span><br><span class="line">        <span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码能够保证在类上添加@Configuration注解后，只会为类生成一个代理对象。也就是说，上述代码的逻辑能够保证标注了@Configuration注解的类生成的代理类是单例模式的。</p>
<p>因为使用CGLib创建出来的代理类是目标类的子类，所以第一次执行上述代码片段时，会调用cglibMethodProxy的invokeSuper()方法执行父类的方法，也就是执行目标类的方法。第二次执行上述代码片段时，会调用resolveBeanReference()方法。</p>
<p>（13）解析BeanMethodInterceptor类的resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName)方法</p>
<p>源码详见：</p>
<p>org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor#resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveBeanReference</span><span class="params">(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyInCreation</span> <span class="operator">=</span> beanFactory.isCurrentlyInCreation(beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :</span><br><span class="line">                               beanFactory.getBean(beanName));</span><br><span class="line">       <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//##############省略其他代码###############</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，从resolveBeanReference()方法中，会通过beanFactory获取已经初始化好的Bean对象，并将这个已经初始化好的bean对象返回。并不会再进行第二次初始化的操作。</p>
<p>所以，在类上添加<code>@Configuration</code>注解后，Spring能够保证为类生成的代理类是单例的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章，主要对<code>@Configuration</code>注解进行了系统性的介绍。首先，对<code>@Configuration</code>注解进行了简单的说明，包括<code>@Configuration</code>注解的源码和使用场景以及注意事项。随后，给出了<code>@Configuration</code>注解的使用案例，本章的案例主要是针对使用<code>@Configuration</code>注解的一些注意事项给出的案例。接下来，详细介绍了<code>@Configuration</code>注解在Spring源码层面执行的时序图和对应的源码流程。其中，对于注册流程，主要介绍了注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息和ConfigurationAnnotationConfig配置类Bean定义信息的注册时序图和源码执行流程。对于实例化流程，主要介绍了在Spring IOC容器刷新时，实例化ConfigurationAnnotationConfig配置类的代理对象的流程。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>Spring为何在创建IOC容器时先注册ConfigurationClassPostProcessor类后置处理器的Bean定义信息，随后才是注册标注了@Configuration注解的ConfigurationAnnotationConfig配置类的Bean定义信息？</li>
</ul>
<blockquote>
<p>在 Spring 中，创建 IOC 容器时需要注册一些后置处理器，以便在 Bean 实例化之前或之后执行一些额外的逻辑。其中一个后置处理器是 ConfigurationClassPostProcessor，它用于处理带有 @Configuration 注解的配置类。</p>
<p>Spring 在创建 IOC 容器时首先注册 ConfigurationClassPostProcessor 后置处理器的 Bean 定义信息，这是因为该后置处理器需要在容器中注册所有使用了 @Configuration 注解的配置类，并且在这些配置类中查找其他 Bean 的定义信息。</p>
<p>只有在 ConfigurationClassPostProcessor 后置处理器被注册之后，Spring 才会开始扫描标注了 @Configuration 注解的配置类并将其注册为 Bean 定义信息。这样确保了所有使用了 @Configuration 注解的配置类都被正确地处理，并在容器中注册为 Bean 定义信息，以供其他 Bean 进行依赖注入。</p>
</blockquote>
<ul>
<li>Spring为何先将类的Bean定义信息注册到IOC容器？为何不是直接注册实例化后的对象？</li>
</ul>
<blockquote>
<p>Spring 将类的 Bean 定义信息注册到 IOC 容器中，而不是直接注册实例化后的对象，这是因为 Spring 的核心思想是控制反转（IoC）和依赖注入（DI），即将对象之间的依赖关系交由容器管理。</p>
<p>在 Spring 中，所有的 Bean 都必须先定义，然后才能被实例化。这些 Bean 的定义信息包含了如何创建该 Bean 实例的指令，包括构造函数参数、属性值、初始化方法等等。因此，首先需要将类的 Bean 定义信息注册到容器中，以便在需要时可以使用这些信息来实例化对象。</p>
<p>如果直接注册实例化后的对象，则可能会导致一些问题。例如，在进行依赖注入时，可能无法确定对象的依赖关系。另外，如果在实例化对象时出现错误，可能会导致整个系统无法正常工作。因此，将类的 Bean 定义信息注册到 IOC 容器中，可以更好地控制对象的创建和依赖关系。</p>
</blockquote>
<ul>
<li>Spring为何是在刷新IOC容器时，实例化标注了@Configuration注解的配置类的代理对象？为何不是在创建IOC容器时就进行实例化？</li>
</ul>
<blockquote>
<p>在 AnnotationConfigApplicationContext 构造函数中，会先调用父类 AbstractApplicationContext 的构造函数创建一个空的 ApplicationContext 实例，然后调用 register() 方法注册配置类（componentClasses），最后再调用 refresh() 方法刷新容器。</p>
<p>在实际应用中，往往存在多个 @Configuration 注解的配置类，并且这些配置类之间可能存在依赖关系。如果在创建 IOC 容器时就立即实例化这些配置类，那么可能会出现依赖关系无法正确处理的情况。比如，如果 A 配置类依赖于 B 配置类的某个 Bean，而 B 配置类又依赖于 A 配置类的 Bean，那么在创建 IOC 容器时，就无法确定哪个 Bean 应该先被实例化，从而导致出现循环依赖问题。</p>
<p>因此，在 AnnotationConfigApplicationContext 中，Spring 采用了延迟实例化的方式来处理 @Configuration 注解的配置类。在 register() 方法中，会将配置类注册到容器中，并在 refresh() 方法中进行实例化和代理增强，以确保所有的配置类都能够正确地被处理，并且在需要时可以进行代理增强等操作，从而实现 AOP 功能。</p>
</blockquote>
<ul>
<li>Spring IOC容器的这种设计能给你带来哪些启示？</li>
</ul>
<blockquote>
<ol>
<li>控制反转（IoC）和依赖注入（DI）是实现松耦合、提高代码可测试性和可维护性的关键技术。将对象之间的依赖关系转移到容器中进行管理，可以更好地解耦组件之间的关系，提高系统的灵活性和可扩展性。</li>
<li>延迟实例化可以提高应用程序的启动速度和内存占用，避免在容器创建时就进行大量的对象实例化和初始化操作，从而减少启动时间和内存开销。</li>
<li>使用代理模式可以更好地实现面向切面编程（AOP）的功能，通过拦截方法调用，动态地对方法进行增强，从而实现事务管理、安全控制、缓存处理等功能。</li>
<li>面向接口编程可以提高代码的可扩展性和可维护性，利用接口隔离原则可以降低组件之间的耦合度，从而更容易进行模块化和单元测试。</li>
<li>设计模式、面向对象编程思想和一些基本的编码规范能够帮助我们写出可读性高、易于维护和扩展的代码。Spring 框架本身也是一个非常好的代码实践和学习的示例，可以借鉴其中的设计思想和实现方式。</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://helingcode.github.io">vulkhe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://helingcode.github.io/posts/Annotation_Configuration.html">https://helingcode.github.io/posts/Annotation_Configuration.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://helingcode.github.io" target="_blank">vulkhe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IOC%E5%AE%B9%E5%99%A8/">IOC容器</a></div><div class="post_share"><div class="social-share" data-image="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/p2889295883.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/RPC_Core.html"><img class="prev-cover" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/abc8dba3c04446318f318323dbf5f568.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RPC框架核心技术</div></div></a></div><div class="next-post pull-right"><a href="/posts/Annotation.html"><img class="next-cover" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/%E5%A3%81%E7%BA%B8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入理解Java注解</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">vulkhe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HelingCode"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HelingCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:linghezhu.if@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">注解详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">注解源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">注解使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81proxyBeanMethods%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">验证proxyBeanMethods属性的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81proxyBeanMethods%E5%8F%96%E5%80%BC%E4%B8%BAtrue%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">验证proxyBeanMethods取值为true的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81proxyBeanMethods%E5%8F%96%E5%80%BC%E4%B8%BAfalse%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">验证proxyBeanMethods取值为false的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%88%9B%E5%BB%BAIOC%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">传入配置类创建IOC容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E5%8C%85%E5%90%8D%E5%88%9B%E5%BB%BAIOC%E5%AE%B9%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">传入包名创建IOC容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">源码时序图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CConfigurationClassPostProcessor%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">注册ConfigurationClassPostProcessor流程源码时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CConfigurationAnnotationConfig%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">注册ConfigurationAnnotationConfig流程源码时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">实例化流程源码时序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CConfigurationClassPostProcessor%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">注册ConfigurationClassPostProcessor流程源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8CConfigurationAnnotationConfig%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">注册ConfigurationAnnotationConfig流程源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">实例化流程源码解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">思考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/RPC_Core.html" title="Docker的安装及常用命令"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/20220820192714_c20e6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker的安装及常用命令"/></a><div class="content"><a class="title" href="/posts/RPC_Core.html" title="Docker的安装及常用命令">Docker的安装及常用命令</a><time datetime="2023-05-03T07:15:24.000Z" title="发表于 2023-05-03 15:15:24">2023-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/RPC_Core.html" title="RPC框架核心技术"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/abc8dba3c04446318f318323dbf5f568.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RPC框架核心技术"/></a><div class="content"><a class="title" href="/posts/RPC_Core.html" title="RPC框架核心技术">RPC框架核心技术</a><time datetime="2023-04-18T14:30:03.000Z" title="发表于 2023-04-18 22:30:03">2023-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation_Configuration.html" title="深入理解@Configuration注解"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/p2889295883.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解@Configuration注解"/></a><div class="content"><a class="title" href="/posts/Annotation_Configuration.html" title="深入理解@Configuration注解">深入理解@Configuration注解</a><time datetime="2023-04-16T06:58:57.000Z" title="发表于 2023-04-16 14:58:57">2023-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation.html" title="深入理解Java注解"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/%E5%A3%81%E7%BA%B8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java注解"/></a><div class="content"><a class="title" href="/posts/Annotation.html" title="深入理解Java注解">深入理解Java注解</a><time datetime="2023-04-16T04:15:51.000Z" title="发表于 2023-04-16 12:15:51">2023-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/spring_aop.html" title="JDK动态代理和Cglib动态代理"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/francesco-ungaro-V6TWE6h8gyg-unsplash.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK动态代理和Cglib动态代理"/></a><div class="content"><a class="title" href="/posts/spring_aop.html" title="JDK动态代理和Cglib动态代理">JDK动态代理和Cglib动态代理</a><time datetime="2022-11-27T02:15:32.000Z" title="发表于 2022-11-27 10:15:32">2022-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By vulkhe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"><img class="icp-icon" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/beian_logo.png"><span>苏ICP备2021044866号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://helingcode.github.io/posts/Annotation_Configuration.html'
    this.page.identifier = '/posts/Annotation_Configuration.html'
    this.page.title = '深入理解@Configuration注解'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://cstube.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>