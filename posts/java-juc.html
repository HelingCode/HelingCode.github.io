<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java多线程面试题 | vulkhe's blog</title><meta name="keywords" content="八股文"><meta name="author" content="vulkhe"><meta name="copyright" content="vulkhe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程面试题">
<meta property="og:url" content="http://example.com/posts/java-juc.html">
<meta property="og:site_name" content="vulkhe&#39;s blog">
<meta property="og:description" content="1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png">
<meta property="article:published_time" content="2022-07-01T05:49:34.000Z">
<meta property="article:modified_time" content="2022-07-01T06:50:40.570Z">
<meta property="article:author" content="vulkhe">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png"><link rel="shortcut icon" href="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg"><link rel="canonical" href="http://example.com/posts/java-juc"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: vulkhe","link":"链接: ","source":"来源: vulkhe's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java多线程面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-01 14:50:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="vulkhe's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">vulkhe's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java多线程面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-01T05:49:34.000Z" title="发表于 2022-07-01 13:49:34">2022-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-01T06:50:40.570Z" title="更新于 2022-07-01 14:50:40">2022-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java多线程面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？"><a href="#1-Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？" class="headerlink" title="1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？"></a><a href="">1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</a></h3><p>有两种实现方法，分别是继承Thread类与实现Runnable接口，用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<h3 id="2-sleep-和-wait-有什么区别"><a href="#2-sleep-和-wait-有什么区别" class="headerlink" title="2.sleep() 和 wait() 有什么区别?"></a><a href="">2.sleep() 和 wait() 有什么区别?</a></h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放）,该线程才能回到可运行状态等待获取锁。</p>
<h3 id="3-同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#3-同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="3.同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a><a href="">3.同步和异步有何异同，在什么情况下分别使用他们？举例说明。</a></h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="4-多线程有几种实现方法-同步有几种实现方法"><a href="#4-多线程有几种实现方法-同步有几种实现方法" class="headerlink" title="4.多线程有几种实现方法?同步有几种实现方法?"></a><a href="">4.多线程有几种实现方法?同步有几种实现方法?</a></h3><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。</p>
<p>同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</p>
<p>notityAll():唤醒所有处于等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h3 id="5-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#5-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="5.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a><a href="">5.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></h3><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h3 id="6-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#6-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="6.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a><a href="">6.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</a></h3><p>分几种情况：</p>
<p>1）其他方法前是否加了synchronized关键字，如果没加，则能。</p>
<p>2）如果这个方法内部调用了wait，则可以进入其他synchronized方法。</p>
<p>3）如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</p>
<p>4）如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</p>
<h3 id="7-线程的基本概念、线程的基本状态以及状态之间的关系。"><a href="#7-线程的基本概念、线程的基本状态以及状态之间的关系。" class="headerlink" title="7.线程的基本概念、线程的基本状态以及状态之间的关系。"></a><a href="">7.线程的基本概念、线程的基本状态以及状态之间的关系。</a></h3><p>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，从宏观上来看，cpu一会执行a线程，一会执行b线程，切换时间很快，给人的感觉是a,b在同时执行。</p>
<p>状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。</p>
<p>调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。</p>
<h3 id="8-简述synchronized和java-util-concurrent-locks-Lock的异同-？"><a href="#8-简述synchronized和java-util-concurrent-locks-Lock的异同-？" class="headerlink" title="8.简述synchronized和java.util.concurrent.locks.Lock的异同 ？"></a><a href="">8.简述synchronized和java.util.concurrent.locks.Lock的异同 ？</a></h3><p>主要相同点：Lock能完成synchronized所实现的所有功能。</p>
<p>主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手动释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去获得锁。</p>
<h3 id="9-Java多线程编程时有哪几种线程间通信方式？（跟谁学）"><a href="#9-Java多线程编程时有哪几种线程间通信方式？（跟谁学）" class="headerlink" title="9.Java多线程编程时有哪几种线程间通信方式？（跟谁学）"></a><a href="">9.Java多线程编程时有哪几种线程间通信方式？（跟谁学）</a></h3><ol>
<li><p><strong>共享内存法</strong></p>
<p>volatile，synchronized</p>
</li>
<li><p><strong>wait/notify机制</strong></p>
<p>来自Object类的方法。当满足某种情况时A线程调用wait()方法放弃CPU时间片，并进入阻塞状态。当满足某种条件时，B线程调用notify()方法通知A线程。唤醒A线程，并让它进入可运行状态。</p>
</li>
<li><p><strong>Lock/Condition机制</strong></p>
<p>Condition是Java提供来实现<strong>等待/通知</strong>的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p>
</li>
</ol>
<h3 id="10-volatile如何实现内存可见性？（美团）（字节跳动）"><a href="#10-volatile如何实现内存可见性？（美团）（字节跳动）" class="headerlink" title="10.volatile如何实现内存可见性？（美团）（字节跳动）"></a><a href="">10.volatile如何实现内存可见性？（美团）（字节跳动）</a></h3><p><strong>volatile为什么会出现：</strong>（字节跳动）</p>
<p>首先先分析一下没有volatile的情况下线程在自己的私有内存中对共享变量做出了改变之后无法及时告知其他线程，这就是volatile的作用，解决内存可见性问题。这种问题用synchronized关键字可以解决。但是一个问题是synchronized是重量级锁，同一时间内只允许一个线程去操作共享变量。操作完成之后再将改变后的变量值刷新回共享内存空间中。这样一来的话并发性就没有了。而且<strong>synchronized关键词的使用基于操作系统实现</strong>，会使得线程从用户态陷入内核态。这一步是很耗时间的。于使volatile应运而生。它是一个轻量级的synchronized。只是用来解决内存可见性问题的。</p>
<p><strong>1、volatile可见性实现原理：</strong>（字节跳动）</p>
<p>变量被volatile关键字修饰后，底层<strong>汇编指令</strong>中会出现一个<strong>lock前缀指令</strong>。会导致以下两种事情的发生：</p>
<ol>
<li>修改volatile变量时会<strong>强制</strong>将修改后的值刷新到主内存中。</li>
<li>修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新读取主内存中的值。</li>
</ol>
<p><strong>2、volatile有序性实现原理：</strong>（字节跳动）</p>
<p><strong>指令重排序：</strong>编译器在不改变单线程程序语义的前提下，会重新安排语句的执行顺序，指令重排序在单线程下不会有问题，但是在多线程下，可能会出现问题。</p>
<p>volatile有序性的保证就是通过<strong>禁止指令重排序</strong>来实现的。指令重排序包括编译器和处理器重排序，JMM会分别限制这两种指令重排序。禁止指令重排序又是通过加<strong>内存屏障</strong>实现的。</p>
<blockquote>
<p>内存屏障（memory barriers）：一组处理器指令，用于实现对内存操作的顺序限制。</p>
</blockquote>
<p>添加了volatile关键字可以避免半初始化的指令重排。</p>
<h3 id="11-volatile为什么不保证原子性？"><a href="#11-volatile为什么不保证原子性？" class="headerlink" title="11.volatile为什么不保证原子性？"></a><a href="">11.volatile为什么不保证原子性？</a></h3><p>Java中只有对变量的赋值和读取是原子性的，其他的操作都不是原子性的。所以即使volatile即使能保证被修饰的变量具有可见性，但是不能保证原子性。</p>
<h3 id="12-了解CountDownLatch吗？"><a href="#12-了解CountDownLatch吗？" class="headerlink" title="12.了解CountDownLatch吗？"></a><a href="">12.了解CountDownLatch吗？</a></h3><p><strong>闭锁</strong>可以用来确保某些活动直到其他活动全部结束之后才进行；</p>
<p>主要包含两个方法，一个是<code>countDown()</code>，一个是<code>await()</code>;以及一个计数器变量<code>cnt</code>。<code>countDown()</code> 方法用来给计数器<code>cnt</code>减一； <code>await()</code> 方法是用来阻塞当前线程，直到计数器为0的时候再唤醒线程继续执行；</p>
<h3 id="13-了解Semaphore吗"><a href="#13-了解Semaphore吗" class="headerlink" title="13.了解Semaphore吗?"></a><a href="">13.了解Semaphore吗?</a></h3><p>信号量，用于多个共享资源的互斥使用，也可以<strong>用来控制线程的并发量</strong>，类似于线程池的作用。</p>
<p>可以用于限制线程的并发数。</p>
<h3 id="14-Thread-Local-作用、原理、内存泄漏问题？（字节跳动）（滴滴）"><a href="#14-Thread-Local-作用、原理、内存泄漏问题？（字节跳动）（滴滴）" class="headerlink" title="14.Thread Local 作用、原理、内存泄漏问题？（字节跳动）（滴滴）"></a><a href="">14.Thread Local 作用、原理、内存泄漏问题？（字节跳动）（滴滴）</a></h3><p><strong>作用：</strong></p>
<p><code>ThreadLocal</code>为解决多线程下的线程安全问题提供了一个新思路，它通过为每一个线程提供一个独立的变量副本解决了线程并发访问共享变量出现的安全问题。在很多情况下<code>ThreadLocal</code>比直接使用synchronized同步机制解决线程安全问题更加方便、简洁。且拥有更加高的并发性。</p>
<p><strong>原理：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在每个线程Thread内部有一个<code>ThreadLocal.ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，这个<code>threadLocals</code>就是用来<strong>存储实际的变量副本</strong>的，键值为当前<code>ThreadLocal</code>的引用，value为变量副本（即T类型的变量）。</li>
<li>初始时，在Thread里面，<code>threadLocals</code>为空，当通过<code>ThreadLocal</code>变量调用get()方法或者set()方法，就会对Thread类中的<code>threadLocals</code>进行初始化，并且以当前<code>ThreadLocal</code>对象引用为键值，以<code>ThreadLocal</code>要保存的副本变量为value，存到<code>threadLocals</code>。</li>
<li>然后在当前线程里面，如果要使用副本变量，就可以通过get()方法在<code>threadLocals</code>里面查找。</li>
</ol>
<p><strong><code>ThreadLocal</code>内存泄漏</strong></p>
<p>由于<code>ThreadLocalMap</code>的key是弱引用，而<code>Value</code>是强引用。这就导致了一个问题，<code>ThreadLocal</code>在没有外部对象强引用时，发生GC时（无论是否OOM）弱引用Key会被回收。这个时候就会出现Entry中Key已经被回收，出现一个<code>null Key</code>的情况，外部读取<code>ThreadLocalMap</code>中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的<code>ThreadLocalMap</code>对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：<code>Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value</code>，这条强引用链会导致<code>Entry</code>不会回收， <code>Value</code>也不会回收，但Entry中的Key却已经被回收的情况，造成<strong>内存泄漏</strong>。</p>
<p><strong>解决办法：</strong>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</p>
<p><strong><code>ThreadLocal</code>应用场景</strong></p>
<p>最常见的<code>ThreadLocal</code>使用场景为 用来解决 数据库连接、Session管理等。</p>
<h3 id="15-AQS内部如何控制并发？（字节跳动）"><a href="#15-AQS内部如何控制并发？（字节跳动）" class="headerlink" title="15.AQS内部如何控制并发？（字节跳动）"></a><a href="">15.AQS内部如何控制并发？（字节跳动）</a></h3><p><code>AQS（AbstractQueuedSynchronizer）</code>是<code>J.U.C</code>包下<strong>lock</strong>实现的核心。主要是其提供的一个FIFO的队列来维护获取锁失败而进入阻塞的线程，以及一个volatile关键字修饰的state变量表示当前同步状态。当一个线程获取到同步状态（修改state=1），那么其他线程便无法获取，转而被构造成节点并加入同步队列中。<strong>加入队列的过程基于CAS算法。即比较当前线程认为的尾节点与当前节点，比较成功后才能正式加入队列尾部。</strong>队列头节点表示的为当前正在运行的线程，该线程执行结束后会激活它下面的一个线程进入执行状态。</p>
<p>FIFO同步队列控制并发。</p>
<h3 id="16-DCL单例为什么需要加volatile-（半初始化的指令重排）？（滴滴）（字节跳动）"><a href="#16-DCL单例为什么需要加volatile-（半初始化的指令重排）？（滴滴）（字节跳动）" class="headerlink" title="16.DCL单例为什么需要加volatile （半初始化的指令重排）？（滴滴）（字节跳动）"></a><a href="">16.DCL单例为什么需要加volatile （半初始化的指令重排）？（滴滴）（字节跳动）</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。 使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<p>volatile两个作用：保持线程可见性；<strong>禁止指令重排序</strong>。</p>
<p><strong>DCL单例需要加volatile，来禁止指令重排。</strong></p>
<p>由于java编译器允许处理器乱序执行（以获得最优的性能），new对象的操作不是原子性的。这句代码最终会被编译成多条汇编指令。所以需要volatile关键字来禁止指令重排。</p>
<p><strong>创建一个对象的过程中一旦出现了指令重排，可能就会获得半初始化的对象，</strong>即还没来得及赋值就先建立了引用关系。要避免这种情况的发生就要使用volatile关键字修饰实列变量。</p>
<p><strong>第一次判断singleton是否为null</strong><br>  第一次判断是在Synchronized同步代码块外进行判断，由于单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以，第一次判断，是为了在singleton对象已经创建的情况下，避免进入同步代码块，提升效率。</p>
<p><strong>第二次判断singleton是否为null</strong><br>  第二次判断是为了避免以下情况的发生。<br>  (1)假设：线程A已经经过第一次判断，判断singleton=null，准备进入同步代码块.<br>  (2)此时线程B获得时间片，由于线程A并没有创建实例，所以，判断singleton仍然=null，所以线程B创建了实例singleton。<br>  (3)此时，线程A再次获得时间片，由于刚刚经过第一次判断singleton=null(不会重复判断)，进入同步代码块，这个时候，我们如果不加入第二次判断的话，那么线程A又会创造一个实例singleton，就不满足我们的单例模式的要求，所以第二次判断是很有必要的。</p>
<h3 id="17-Java的线程模型"><a href="#17-Java的线程模型" class="headerlink" title="17.Java的线程模型"></a><a href="">17.Java的线程模型</a></h3><p>1.用户线程与内核级线程</p>
<p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。</p>
<p>2.并发与并行</p>
<p><strong>并发：</strong>一个时间段内有很多的线程或进程在执行，但任何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。<br><strong>并行：</strong>一个时间段和时间点上都有多个线程或进程在执行。</p>
<p>3.多线程模型</p>
<p>多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。</p>
<h3 id="18-线程与进程区别？"><a href="#18-线程与进程区别？" class="headerlink" title="18.线程与进程区别？"></a><a href="">18.<strong>线程与进程区别？</strong></a></h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<h3 id="19-谈一下AQS，为什么底层使用CAS和volatile？-字节跳动"><a href="#19-谈一下AQS，为什么底层使用CAS和volatile？-字节跳动" class="headerlink" title="19.谈一下AQS，为什么底层使用CAS和volatile？(字节跳动)"></a><a href="">19.谈一下AQS，为什么底层使用CAS和volatile？(字节跳动)</a></h3><ol>
<li>AQS源码中<code>state</code>状态值使用<code>volatile</code>修饰保证内存的可见性。因为涉及到多线程对state的修改，必须保证其对所有线程的可见性。</li>
<li>CAS操作主要用于对state值的修改。</li>
</ol>
<h3 id="20-Synchronized与ReentrantLock的区别？（太多了）（美团）"><a href="#20-Synchronized与ReentrantLock的区别？（太多了）（美团）" class="headerlink" title="20.Synchronized与ReentrantLock的区别？（太多了）（美团）"></a><a href="">20.Synchronized与ReentrantLock的区别？（太多了）（美团）</a></h3><p><strong>实现原理上:</strong></p>
<p><code>synchronized</code>是依靠<code>jvm</code>以及配合操作系统来实现，是一个<strong>关键字</strong>。<code>reentrantLock</code>是<code>jdk1.5</code>之后提供的<strong>API层面</strong>的互斥锁。</p>
<p><strong>使用便利性上：</strong></p>
<p><code>synchronized</code>只需要添加上相关关键字即可，加锁与释放过程由操作系统完成。<code>reentrantLock</code>则需要手动加锁与释放锁。</p>
<p><strong>锁粒度与灵活度：</strong></p>
<p>reentrantLock<code>要强于</code>synchronized</p>
<p><code>reentrantLock</code>提供了<strong>三个高级功能</strong>:</p>
<ol>
<li><strong>等待可中断</strong>，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相对于Synchronized来说可以避免出现死锁的情况。通过<code>lock.lockInterruptibly()</code>来实现这个机制。</li>
<li>多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁是非公平锁，<code>ReentrantLock</code>默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
<li>一个<code>ReentrantLock</code>对象可以同时绑定多个对象。<code>ReenTrantLock</code>提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
</ol>
<p><strong>性能区别：</strong></p>
<p><code>synchronized</code>优化之后性能与<code>reentrantLock</code>已经不相上下了，官方甚至更建议使用<code>synchronized</code>关键字。</p>
<h3 id="21-Synchronized实现原理？（美团）（字节）（滴滴）-待完善"><a href="#21-Synchronized实现原理？（美团）（字节）（滴滴）-待完善" class="headerlink" title="21.Synchronized实现原理？（美团）（字节）（滴滴）(待完善)"></a><a href="">21.Synchronized实现原理？（美团）（字节）（滴滴）<code>(待完善)</code></a></h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>每个对象（在对象头中）有一个<strong>监视器锁</strong><code>（monitor）</code>，当monitor被占用时就处于锁定状态。线程执行<code>monitorenter</code>（汇编指令）尝试获取monitor的所有权。</p>
<ol>
<li>如果monitor计数器当前值为0，那么该线程进入monitor并将计数器加1，</li>
<li>如果当前monitor计数器值不为0，那么该线程阻塞并进入（OS维护的）队列等待，等到OS的调度。</li>
</ol>
<p>底层字节码被编译成<code>monitorenter</code>和<code>monitorexit</code>两个指令。线程执行<code>monitorexit</code>指令，monitor计数器减1，如果减到0了，表示当前线程不再拥有该监视器锁。等待队列中的线程有机会获得锁资源。</p>
<p>在synchronized大（优化）升级之前，是重量级锁，锁操作都要经过OS。向OS内核去申请。（<code>jdk1.5之后</code>）到现在的synchronized是有一个复杂的锁升级过程。</p>
<p><strong>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁） -&gt; （重量级锁）悲观锁。</strong></p>
<p>以上的升级状态都记录在对象头中。</p>
<p><strong>偏向锁：</strong>hotspot虚拟机认为大多数时间是不存在锁竞争的，所以每次都会把锁分配给上一次获得锁的线程，直到出现了锁竞争。</p>
<p><strong>自旋锁：</strong>线程之间以CAS的方式进行锁资源的争抢。当一个线程自旋超过了10次或者当前自旋等待的线程超过了CPU核数的1/2（升级后优化为自适应自旋），会进行锁升级。</p>
<p><strong>synchronized：</strong> 向OS申请资源，从用户态切换到内核态。线程挂起进入<strong>等待队列</strong>，等待OS的调度。然后再映射回用户空间。</p>
<h3 id="22-追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）"><a href="#22-追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）" class="headerlink" title="22.追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）"></a><a href="">22.追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）</a></h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor 实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h3 id="23-追问，什么是可重入性，为什么说-Synchronized-是可重入锁？（字节）"><a href="#23-追问，什么是可重入性，为什么说-Synchronized-是可重入锁？（字节）" class="headerlink" title="23.追问，什么是可重入性，为什么说 Synchronized 是可重入锁？（字节）"></a><a href="">23.追问，什么是可重入性，为什么说 Synchronized 是可重入锁？（字节）</a></h3><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/image-20220309201446490.png" alt="image-20220309201446490"></p>
<h3 id="24-synchronized可重入锁的实现？"><a href="#24-synchronized可重入锁的实现？" class="headerlink" title="24.synchronized可重入锁的实现？"></a><a href="">24.synchronized可重入锁的实现？</a></h3><p>重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p>
<h3 id="25-追问，为什么说-Synchronized-是非公平锁"><a href="#25-追问，为什么说-Synchronized-是非公平锁" class="headerlink" title="25.追问，为什么说 Synchronized 是非公平锁?"></a><a href="">25.追问，为什么说 Synchronized 是非公平锁?</a></h3><p>Synchronized底层是调用mutex锁的，内核提供的这个锁并不保证公平。而Java所提供的公平锁Lock实际上是由Java的API支持的（即对AQS的实现）</p>
<p>非公平是指在获取锁的行为上，并不是按照线程申请顺序进行分配的，当锁被释放后，所有线程都有机会获取到锁，这样提高了性能，但是可能会出现某些线程饥饿的情况。</p>
<h3 id="26-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#26-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="26.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a><a href="">26.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</a></h3><p>当 Synchronized升级为重量级锁时，他是一个悲观锁。<strong>获取不到锁资源的线程由OS统一管理</strong>，涉及到用户态到内核态的切换。</p>
<p>乐观锁就是，当一个线程想要对变量进行操作时，先读取变量值，然后真正更改时会再次对比当前值与自己之前读取的值是否相同，相同才会进行更改，不相同的话就会再次读取，然后在进行对比更改。主要是基于CAS实现。</p>
<p>CAS(compare and swap) ：它涉及到3个操作数:1.内存值,预期值, 新值,只有当内存值和预期值相等的时候(证明没有其他线程在使用),才会将内存值设置为新值。</p>
<p>CAS具有原子性,他的原子性由CPU保证,由JNI调用c++硬件代码实现,<code>jdk</code>中提供了unsafe来进行这些操作。</p>
<h3 id="27-什么是锁消除和锁粗化？"><a href="#27-什么是锁消除和锁粗化？" class="headerlink" title="27.什么是锁消除和锁粗化？"></a><a href="">27.什么是锁消除和锁粗化？</a></h3><p>锁消除即删除不必要的加锁操作。JVM在运行时，对一些“在代码上要求同步，但是<strong>被检测到不可能存在共享数据竞争情况”的锁进行消除</strong>。根据代码逃逸技术，如果判断到一段代码中，<strong>堆上的数据不会逃逸出当前线程</strong>，那么就可以认为这段代码是线程安全的，无需加锁。</p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockClearTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearTest</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            test.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer的append代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码看出来，StringBuffer的append是个同步方法，但是LockClearTest中的 StringBuffer 属于一个局部变量，不可能从该方法中逃逸出去（即stringBuffer的引用没有传递到该方法外，不会被其他线程引用），因此其实这过程是线程安全的，可以将锁消除。</p>
<p>假设一系列的连续操作都会<strong>对同一个对象反复加锁及解锁</strong>，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会<strong>扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</strong></p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码每次调用 stringBuffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h3 id="28-乐观锁一定就是好的吗？"><a href="#28-乐观锁一定就是好的吗？" class="headerlink" title="28.乐观锁一定就是好的吗？"></a><a href="">28.乐观锁一定就是好的吗？</a></h3><p>不一定</p>
<ol>
<li>乐观锁的情况下，如果线程并发度确实很高，那么大多数的线程都会处于自旋等待以获取锁对象的状态。这样会导致CPU占用过高。</li>
<li>CAS另一个缺点就是ABA问题。一个值从A改为B又改为A,则CAS认为没有发生变化,解决的方式是使用<strong>版本号</strong>来记录操作次数。</li>
</ol>
<h3 id="29-ReentrantLock实现原理？"><a href="#29-ReentrantLock实现原理？" class="headerlink" title="29.ReentrantLock实现原理？"></a><a href="">29.ReentrantLock实现原理？</a></h3><h3 id="30-AQS原理？"><a href="#30-AQS原理？" class="headerlink" title="30.AQS原理？"></a><a href="">30.AQS原理？</a></h3><p>AQS框架是用来构建锁的同步器框架,包括了常用的<code>ReentrantLock</code>,<code>ReadWriteLock</code>,<code>CountDownLatch</code>等都是基于AQS框架来实现的。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS 使用一个 int 成员变量state来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态state进行原子操作实现对其值的修改。</p>
<h3 id="31-程序计数器为什么线程是私有的"><a href="#31-程序计数器为什么线程是私有的" class="headerlink" title="31.程序计数器为什么线程是私有的?"></a><a href="">31.程序计数器为什么线程是私有的?</a></h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="32-虚拟机栈和本地方法栈为什么线程是私有的"><a href="#32-虚拟机栈和本地方法栈为什么线程是私有的" class="headerlink" title="32.虚拟机栈和本地方法栈为什么线程是私有的?"></a><a href="">32.虚拟机栈和本地方法栈为什么线程是私有的?</a></h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="33-什么是上下文切换"><a href="#33-什么是上下文切换" class="headerlink" title="33.什么是上下文切换?"></a><a href="">33.什么是上下文切换?</a></h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="34-产生死锁必须具备以下四个条件：（美团）"><a href="#34-产生死锁必须具备以下四个条件：（美团）" class="headerlink" title="34.产生死锁必须具备以下四个条件：（美团）"></a><a href="">34.产生死锁必须具备以下四个条件：（美团）</a></h3><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="35-如何预防和避免线程死锁"><a href="#35-如何预防和避免线程死锁" class="headerlink" title="35.如何预防和避免线程死锁?"></a><a href="">35.如何预防和避免线程死锁?</a></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<p>​    1.<strong>破坏互斥条件</strong>:使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p> <strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。</p>
<h3 id="36-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#36-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="36.说说 synchronized 关键字和 volatile 关键字的区别"></a><a href="">36.说说 synchronized 关键字和 volatile 关键字的区别</a></h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h3 id="37-线程池以及使用线程池的好处"><a href="#37-线程池以及使用线程池的好处" class="headerlink" title="37.线程池以及使用线程池的好处"></a><a href="">37.线程池以及使用线程池的好处</a></h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p>
<h3 id="38-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#38-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="38.执行 execute()方法和 submit()方法的区别是什么呢？"></a><a href="">38.执行 execute()方法和 submit()方法的区别是什么呢？</a></h3><p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="39-ThreadPoolExecutor构造函数重要参数分析"><a href="#39-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="39.ThreadPoolExecutor构造函数重要参数分析"></a><a href="">39.<code>ThreadPoolExecutor</code>构造函数重要参数分析</a></h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :线程工厂。</li>
<li><strong><code>handler</code></strong> :拒绝策略。</li>
</ol>
<p>​         <strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求，将工作队列中等待在最前面的任务丢弃，然后将新来的任务放进等待队列中。</li>
</ul>
<h3 id="40-线程池的参数怎么设置？"><a href="#40-线程池的参数怎么设置？" class="headerlink" title="40.线程池的参数怎么设置？"></a><a href="">40.线程池的参数怎么设置？</a></h3><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="41-悲观锁和乐观锁的区别"><a href="#41-悲观锁和乐观锁的区别" class="headerlink" title="41.悲观锁和乐观锁的区别"></a><a href="">41.悲观锁和乐观锁的区别</a></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82">https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82</a></p>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>
<ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>
</ul>
<h3 id="42-MySQL如何实现乐观锁？"><a href="#42-MySQL如何实现乐观锁？" class="headerlink" title="42.MySQL如何实现乐观锁？"></a><a href="">42.MySQL如何实现乐观锁？</a></h3><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p>
<p>乐观锁的实现原理：</p>
<ol>
<li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。</li>
<li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。</li>
<li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li>
</ol>
<p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h3 id="43-多线程操作-static-变量会有影响吗？"><a href="#43-多线程操作-static-变量会有影响吗？" class="headerlink" title="43.多线程操作 static 变量会有影响吗？"></a><a href="">43.多线程操作 static 变量会有影响吗？</a></h3><p>当多个线程执行同一个方法的时候，并且方法中使用了静态变量的时候，就会出现安全问题， 因为静态成员（static member）作为公共变量，是放在共享内存区域的。 多个线程共享一块内存区域，在不加任何保护情况下对其操作就会出现异常结果。</p>
<p><strong>解决方法：</strong></p>
<p>不使用共享内存，每个线程内存空间相互独立；<br>多线程共享一块内存区域，但是对这块共享区域加锁访问。对调用static变量的方法使用lock或synchronized</p>
<h3 id="44-为什么要使用多线程"><a href="#44-为什么要使用多线程" class="headerlink" title="44.为什么要使用多线程?"></a><a href="">44.为什么要使用多线程?</a></h3><p>从系统应用上来思考：</p>
<ul>
<li>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间切换和调度的成本远远小于进程。另外，多核 CPU 时代，意味着多个线程可以同时运行，这减少了线程上下文切换的开销；</li>
<li>如今的系统，动不动就要求百万级甚至亿万级的并发量，而多线程并发编程，正是开发高并发系统的基础，利用好多线程机制，可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>从计算机背后来探讨：</p>
<p><strong>单核时代：</strong> 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程工作的时候，会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。可以简单地理解成，这两者的利用率最高都是 50%左右。但是当有两个线程的时候就不一样了，一个线程执行 CPU 计算时，另外一个线程就可以进行 IO 操作，这样 CPU 和 IO 设备两个的利用率就可以在理想情况下达到 100%；</p>
<p><strong>多核时代：</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只有一个 CPU 核心被利用到，而创建多个线程，就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p>
<p><strong>多线程相比单线程的优势，存在什么问题？</strong></p>
<p>多线程适用场景</p>
<p>   1）存在需要等待IO、网络或其他外部资源的任务。当前等待其他资源却依旧占用CPU的线程可让出CPU，让其他线程执行，大大提高了程序效率，充分利用了CPU资源。</p>
<p>   2）存在长时间占用CPU的任务。CPU以时间片为单位分配给各个线程，一个周期内各个线程都可以得到执行，而非卡在一个线程。而且多线程意味着分配到的CPU时间片也更多。</p>
<p>多线程弊端</p>
<p>   1）访问共享资源时要小心，需要更多的锁资源，同步更加复杂。</p>
<p>   2）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>占用更多，资源开销更大。</p>
<p>   3）需要额外的线程调度和管理。如需要CPU时间来跟踪线程。</p>
<h3 id="45-synchronized修饰的对象"><a href="#45-synchronized修饰的对象" class="headerlink" title="45.synchronized修饰的对象"></a><a href="">45.synchronized修饰的对象</a></h3><ul>
<li>修饰一个类：其作用的范围是synchronized后面括号括起来的部分，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个方法：被修饰的方法称为同步方法，其作用的范围是整个方法，<strong>作用的对象是调用这个方法的对象</strong>；</li>
<li>修饰一个静态的方法：其作用的范围是整个方法，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个代码块：被修饰的代码块称为同步语句块，其作用范围是大括号{}括起来的代码块，<strong>作用的对象是调用这个代码块的对象</strong>；</li>
</ul>
<h3 id="46-BIO-NIO-AIO"><a href="#46-BIO-NIO-AIO" class="headerlink" title="46.BIO/NIO/AIO"></a><a href="">46.BIO/NIO/AIO</a></h3><h4 id="Java中的IO原理"><a href="#Java中的IO原理" class="headerlink" title="Java中的IO原理"></a>Java中的IO原理</h4><p>首先Java中的IO都是依赖操作系统内核进行的，我们程序中的IO读写其实调用的是操作系统内核中的read&amp;write两大系统调用。</p>
<p>那内核是如何进行IO交互的呢？</p>
<ol>
<li>网卡收到经过网线传来的网络数据，并将网络数据写到内存中。</li>
<li>当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</li>
<li>将内存中的网络数据写入到对应socket的接收缓冲区中。</li>
<li>当接收缓冲区的数据写好之后，应用程序开始进行数据处理。</li>
</ol>
<p>对应抽象到java的socket代码简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//获取数据进行处理</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// socket、server，流关闭操作，省略不表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个过程和底层内核的网络IO很类似，主要体现在accept()等待从网络中的请求到来然后bytes[]数组作为缓冲区等待数据填满后进行处理。而BIO、NIO、AIO之间的区别就在于这些操作是同步还是异步，阻塞还是非阻塞。</p>
<p>所以我们引出同步异步，阻塞与非阻塞的概念。</p>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们的执行流程中：依次是方法一和方法二。</p>
<p>同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。</p>
<p>异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。</p>
<p>同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。</p>
<p>同步与异步是从多个线程之间的协调来实现效率差异。</p>
<blockquote>
<p>为什么需要异步呢？笔者认为异步的本质就是为了解决主线程的阻塞，所以网上很多讨论把同步异步、阻塞非阻塞进行了四种组合，其中一种就有异步阻塞这一情形，如果异步也是阻塞的？那为什么要特地进行异步操作呢？</p>
</blockquote>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p>
<p>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</p>
<p>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。</p>
<p>阻塞与非阻塞关注的是线程是否在原地等待。</p>
<blockquote>
<p>笔者认为阻塞和非阻塞仅能与同步进行组合。而异步天然就是非阻塞的，而这个非阻塞是对主线程而言。（可能有人认为异步方法里面放入阻塞操作的话就是异步阻塞，但是思考一下，正是因为是阻塞操作所以才会将它放入异步方法中，不要阻塞主线程）</p>
</blockquote>
<h4 id="例子讲解"><a href="#例子讲解" class="headerlink" title="例子讲解"></a>例子讲解</h4><blockquote>
<p>海底捞很好吃，但是经常要排队。我们就以生活中的这个例子进行讲解。</p>
</blockquote>
<ul>
<li>A顾客去吃海底捞，就这样干坐着等了一小时，然后才开始吃火锅。(BIO)</li>
<li>B顾客去吃海底捞，他一看要等挺久，于是去逛商场，每次逛一会就跑回来看有没有排到他。于是他最后既购了物，又吃上海底捞了。（NIO）</li>
<li>C顾客去吃海底捞，由于他是高级会员，所以店长说，你去商场随便玩吧，等下有位置，我立马打电话给你。于是C顾客不用干坐着等，也不用每过一会儿就跑回来看有没有等到，最后也吃上了海底捞（AIO）</li>
</ul>
<blockquote>
<p>哪种方式更有效率呢？是不是一目了然呢？</p>
</blockquote>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。线程发起io请求后，立即返回（非阻塞io）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。</p>
<p>NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。服务端不断轮询channel来获取客户端的信息。channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO是真正意义上的异步非阻塞IO模型。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。</p>
<p>AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。</p>
<h3 id="47-死锁的产生、防止、避免、检测和解除"><a href="#47-死锁的产生、防止、避免、检测和解除" class="headerlink" title="47.死锁的产生、防止、避免、检测和解除"></a><a href="">47.死锁的产生、防止、避免、检测和解除</a></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<h3 id="48-线程安全有哪些实现思路"><a href="#48-线程安全有哪些实现思路" class="headerlink" title=" 48.  线程安全有哪些实现思路?"></a><a href=""> 48.  线程安全有哪些实现思路?</a></h3><ol>
<li><strong>互斥同步</strong></li>
</ol>
<p>synchronized 和 ReentrantLock。</p>
<ol>
<li><strong>非阻塞同步</strong></li>
</ol>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<ul>
<li><code>CAS</code></li>
</ul>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，<code>CAS</code>)。<code>CAS</code> 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<ul>
<li><code>AtomicInteger</code></li>
</ul>
<p><code>J.U.C</code> 包里面的整数原子类 <code>AtomicInteger</code>，其中的 <code>compareAndSet()</code> 和 <code>getAndIncrement()</code> 等方法都使用了 Unsafe 类的 <code>CAS</code> 操作。</p>
<ol>
<li><strong>无同步方案</strong></li>
</ol>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<ul>
<li>栈封闭</li>
</ul>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<ul>
<li>线程本地存储(Thread Local Storage)</li>
</ul>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">vulkhe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/java-juc.html">http://example.com/posts/java-juc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">vulkhe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></div><div class="post_share"><div class="social-share" data-image="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/commandsForRedis.html"><img class="prev-cover" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/martin-jernberg-TA05o8C77ok-unsplash.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis常用命令</div></div></a></div><div class="next-post pull-right"><a href="/posts/java-collection.html"><img class="next-cover" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/java-basic.html" title="Java基础"><img class="cover" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Java基础</div></div></a></div><div><a href="/posts/java-collection.html" title="Java集合面试题"><img class="cover" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Java集合面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">vulkhe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HelingCode"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HelingCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:linghezhu.if@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-stop-%E5%92%8Csuspend-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1.Java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">2.sleep() 和 wait() 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BB%96%E4%BB%AC%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">3.</span> <span class="toc-text">3.同步和异步有何异同，在什么情况下分别使用他们？举例说明。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4.多线程有几种实现方法?同步有几种实现方法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AAsynchronized%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">6.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">7.</span> <span class="toc-text">7.线程的基本概念、线程的基本状态以及状态之间的关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%AE%80%E8%BF%B0synchronized%E5%92%8Cjava-util-concurrent-locks-Lock%E7%9A%84%E5%BC%82%E5%90%8C-%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8.简述synchronized和java.util.concurrent.locks.Lock的异同 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%97%B6%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E8%B7%9F%E8%B0%81%E5%AD%A6%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">9.Java多线程编程时有哪几种线程间通信方式？（跟谁学）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-volatile%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F%EF%BC%88%E7%BE%8E%E5%9B%A2%EF%BC%89%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">10.volatile如何实现内存可见性？（美团）（字节跳动）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">11.volatile为什么不保证原子性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BA%86%E8%A7%A3CountDownLatch%E5%90%97%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">12.了解CountDownLatch吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%86%E8%A7%A3Semaphore%E5%90%97"><span class="toc-number">13.</span> <span class="toc-text">13.了解Semaphore吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Thread-Local-%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89%EF%BC%88%E6%BB%B4%E6%BB%B4%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">14.Thread Local 作用、原理、内存泄漏问题？（字节跳动）（滴滴）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-AQS%E5%86%85%E9%83%A8%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">15.AQS内部如何控制并发？（字节跳动）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-DCL%E5%8D%95%E4%BE%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A0volatile-%EF%BC%88%E5%8D%8A%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%89%EF%BC%9F%EF%BC%88%E6%BB%B4%E6%BB%B4%EF%BC%89%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">16.DCL单例为什么需要加volatile （半初始化的指令重排）？（滴滴）（字节跳动）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.</span> <span class="toc-text">17.Java的线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">18.线程与进程区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%B0%88%E4%B8%80%E4%B8%8BAQS%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8CAS%E5%92%8Cvolatile%EF%BC%9F-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8"><span class="toc-number">19.</span> <span class="toc-text">19.谈一下AQS，为什么底层使用CAS和volatile？(字节跳动)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%89%EF%BC%88%E7%BE%8E%E5%9B%A2%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">20.Synchronized与ReentrantLock的区别？（太多了）（美团）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E7%BE%8E%E5%9B%A2%EF%BC%89%EF%BC%88%E5%AD%97%E8%8A%82%EF%BC%89%EF%BC%88%E6%BB%B4%E6%BB%B4%EF%BC%89-%E5%BE%85%E5%AE%8C%E5%96%84"><span class="toc-number">21.</span> <span class="toc-text">21.Synchronized实现原理？（美团）（字节）（滴滴）(待完善)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%BF%BD%E9%97%AE%EF%BC%8C%E4%BD%A0%E5%88%9A%E6%89%8D%E6%8F%90%E5%88%B0%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%EF%BC%8C%E8%BF%99%E4%B8%AA%E2%80%9C%E9%94%81%E2%80%9D%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">22.追问，你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？（字节）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%BF%BD%E9%97%AE%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%EF%BC%89"><span class="toc-number">23.</span> <span class="toc-text">23.追问，什么是可重入性，为什么说 Synchronized 是可重入锁？（字节）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-synchronized%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">24.synchronized可重入锁的实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E8%BF%BD%E9%97%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">25.</span> <span class="toc-text">25.追问，为什么说 Synchronized 是非公平锁?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF-CAS%EF%BC%8C%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">26.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">27.什么是锁消除和锁粗化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%80%E5%AE%9A%E5%B0%B1%E6%98%AF%E5%A5%BD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">28.乐观锁一定就是好的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-ReentrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">29.ReentrantLock实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-AQS%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">30.AQS原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">31.</span> <span class="toc-text">31.程序计数器为什么线程是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">32.</span> <span class="toc-text">32.虚拟机栈和本地方法栈为什么线程是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">33.</span> <span class="toc-text">33.什么是上下文切换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E4%BB%A5%E4%B8%8B%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%9A%EF%BC%88%E7%BE%8E%E5%9B%A2%EF%BC%89"><span class="toc-number">34.</span> <span class="toc-text">34.产生死锁必须具备以下四个条件：（美团）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">35.</span> <span class="toc-text">35.如何预防和避免线程死锁?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">36.</span> <span class="toc-text">36.说说 synchronized 关键字和 volatile 关键字的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">37.</span> <span class="toc-text">37.线程池以及使用线程池的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E6%89%A7%E8%A1%8C-execute-%E6%96%B9%E6%B3%95%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">38.执行 execute()方法和 submit()方法的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-number">39.</span> <span class="toc-text">39.ThreadPoolExecutor构造函数重要参数分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">40.线程池的参数怎么设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">41.</span> <span class="toc-text">41.悲观锁和乐观锁的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-MySQL%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">42.MySQL如何实现乐观锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C-static-%E5%8F%98%E9%87%8F%E4%BC%9A%E6%9C%89%E5%BD%B1%E5%93%8D%E5%90%97%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">43.多线程操作 static 变量会有影响吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">44.</span> <span class="toc-text">44.为什么要使用多线程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-synchronized%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">45.</span> <span class="toc-text">45.synchronized修饰的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-BIO-NIO-AIO"><span class="toc-number">46.</span> <span class="toc-text">46.BIO&#x2F;NIO&#x2F;AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84IO%E5%8E%9F%E7%90%86"><span class="toc-number">46.1.</span> <span class="toc-text">Java中的IO原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">46.2.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">46.3.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3"><span class="toc-number">46.4.</span> <span class="toc-text">例子讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-number">46.5.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">46.6.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO"><span class="toc-number">46.7.</span> <span class="toc-text">AIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E3%80%81%E9%98%B2%E6%AD%A2%E3%80%81%E9%81%BF%E5%85%8D%E3%80%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">47.</span> <span class="toc-text">47.死锁的产生、防止、避免、检测和解除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">48.</span> <span class="toc-text"> 48.  线程安全有哪些实现思路?</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/spring_aop.html" title="JDK动态代理和Cglib动态代理"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/francesco-ungaro-V6TWE6h8gyg-unsplash.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK动态代理和Cglib动态代理"/></a><div class="content"><a class="title" href="/posts/spring_aop.html" title="JDK动态代理和Cglib动态代理">JDK动态代理和Cglib动态代理</a><time datetime="2022-11-27T02:15:32.000Z" title="发表于 2022-11-27 10:15:32">2022-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ds_btc.html" title="BTC中的数据结构"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/alessio-soggetti-PdGBci-4jR8-unsplash.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BTC中的数据结构"/></a><div class="content"><a class="title" href="/posts/ds_btc.html" title="BTC中的数据结构">BTC中的数据结构</a><time datetime="2022-11-25T06:41:49.000Z" title="发表于 2022-11-25 14:41:49">2022-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cachebreakdown.html" title="缓存击穿问题及解决方法"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/mario-hafliger-PaVzbUl40rc-unsplash.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存击穿问题及解决方法"/></a><div class="content"><a class="title" href="/posts/cachebreakdown.html" title="缓存击穿问题及解决方法">缓存击穿问题及解决方法</a><time datetime="2022-11-17T10:03:26.000Z" title="发表于 2022-11-17 18:03:26">2022-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/commandsForRedis.html" title="Redis常用命令"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/img/martin-jernberg-TA05o8C77ok-unsplash.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis常用命令"/></a><div class="content"><a class="title" href="/posts/commandsForRedis.html" title="Redis常用命令">Redis常用命令</a><time datetime="2022-11-14T01:45:24.000Z" title="发表于 2022-11-14 09:45:24">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/java-juc.html" title="Java多线程面试题"><img src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/animes-girl-1425819-wallhere.com.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程面试题"/></a><div class="content"><a class="title" href="/posts/java-juc.html" title="Java多线程面试题">Java多线程面试题</a><time datetime="2022-07-01T05:49:34.000Z" title="发表于 2022-07-01 13:49:34">2022-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By vulkhe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"><img class="icp-icon" src="https://heling-picture.oss-cn-hangzhou.aliyuncs.com/beian_logo.png"><span>苏ICP备2021044866号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/posts/java-juc.html'
    this.page.identifier = '/posts/java-juc.html'
    this.page.title = 'Java多线程面试题'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://cstube.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>