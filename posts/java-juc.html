<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java多线程面试题 | vulkhe's blog</title><meta name="keywords" content="八股文"><meta name="author" content="vulkhe"><meta name="copyright" content="vulkhe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程面试题">
<meta property="og:url" content="https://helingcode.github.io/posts/java-juc.html">
<meta property="og:site_name" content="vulkhe&#39;s blog">
<meta property="og:description" content="🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png">
<meta property="article:published_time" content="2022-07-01T05:49:34.000Z">
<meta property="article:modified_time" content="2023-12-17T08:09:45.572Z">
<meta property="article:author" content="vulkhe">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%A4%B4%E5%83%8F.jpg"><link rel="canonical" href="https://helingcode.github.io/posts/java-juc"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: vulkhe","link":"链接: ","source":"来源: vulkhe's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java多线程面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-17 16:09:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="vulkhe's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">vulkhe's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java多线程面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-01T05:49:34.000Z" title="发表于 2022-07-01 13:49:34">2022-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-17T08:09:45.572Z" title="更新于 2023-12-17 16:09:45">2023-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java多线程面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="🤣-用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？"><a href="#🤣-用什么关键字修饰同步方法-stop-和suspend-方法为何不推荐使用？" class="headerlink" title="🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？"></a>🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</h3><p>用synchronized关键字修饰同步方法。反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<h3 id="😂-sleep-和-wait-有什么区别"><a href="#😂-sleep-和-wait-有什么区别" class="headerlink" title="😂 sleep() 和 wait() 有什么区别?"></a>😂 sleep() 和 wait() 有什么区别?</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放）,该线程才能回到可运行状态等待获取锁。</p>
<h3 id="😄-同步和异步有何异同？"><a href="#😄-同步和异步有何异同？" class="headerlink" title="😄 同步和异步有何异同？"></a>😄 同步和异步有何异同？</h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="😅-多线程有几种实现方法-同步有几种实现方法"><a href="#😅-多线程有几种实现方法-同步有几种实现方法" class="headerlink" title="😅 多线程有几种实现方法?同步有几种实现方法?"></a>😅 多线程有几种实现方法?同步有几种实现方法?</h3><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。</p>
<p>同步的实现方面有两种，分别是synchronized,wait与notify。</p>
<p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。</p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 </p>
<p>notityAll():唤醒所有处于等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h3 id="😆-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#😆-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="😆 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>😆 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<h3 id="😶-多线程操作-static-变量会有影响吗？"><a href="#😶-多线程操作-static-变量会有影响吗？" class="headerlink" title="😶 多线程操作 static 变量会有影响吗？"></a>😶 多线程操作 static 变量会有影响吗？</h3><p>当多个线程执行同一个方法的时候，并且方法中使用了静态变量的时候，就会出现安全问题， 因为静态成员（static member）作为公共变量，是放在共享内存区域的。 多个线程共享一块内存区域，在不加任何保护情况下对其操作就会出现异常结果。</p>
<p><strong>解决方法：</strong></p>
<p>不使用共享内存，每个线程内存空间相互独立；<br>多线程共享一块内存区域，但是对这块共享区域加锁访问。对调用static变量的方法使用lock或synchronized</p>
<h3 id="🙄-为什么要使用多线程"><a href="#🙄-为什么要使用多线程" class="headerlink" title="🙄 为什么要使用多线程?"></a>🙄 为什么要使用多线程?</h3><p>从系统应用上来思考：</p>
<ul>
<li>线程可以比作是轻量级的进程，是程序执行的最小单位，线程间切换和调度的成本远远小于进程。另外，多核 CPU 时代，意味着多个线程可以同时运行，这减少了线程上下文切换的开销；</li>
<li>如今的系统，动不动就要求百万级甚至亿万级的并发量，而多线程并发编程，正是开发高并发系统的基础，利用好多线程机制，可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>从计算机背后来探讨：</p>
<p><strong>单核时代：</strong> 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程工作的时候，会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。可以简单地理解成，这两者的利用率最高都是 50%左右。但是当有两个线程的时候就不一样了，一个线程执行 CPU 计算时，另外一个线程就可以进行 IO 操作，这样 CPU 和 IO 设备两个的利用率就可以在理想情况下达到 100%；</p>
<p><strong>多核时代：</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只有一个 CPU 核心被利用到，而创建多个线程，就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p>
<p><strong>多线程相比单线程的优势，存在什么问题？</strong></p>
<p>多线程适用场景</p>
<p>   1）存在需要等待IO、网络或其他外部资源的任务。当前等待其他资源却依旧占用CPU的线程可让出CPU，让其他线程执行，大大提高了程序效率，充分利用了CPU资源。</p>
<p>   2）存在长时间占用CPU的任务。CPU以时间片为单位分配给各个线程，一个周期内各个线程都可以得到执行，而非卡在一个线程。而且多线程意味着分配到的CPU时间片也更多。</p>
<p>多线程弊端</p>
<p>   1）访问共享资源时要小心，需要更多的锁资源，同步更加复杂。</p>
<p>   2）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>占用更多，资源开销更大。</p>
<p>   3）需要额外的线程调度和管理。如需要CPU时间来跟踪线程。</p>
<h3 id="👽-线程的基本概念、线程的基本状态以及状态之间的关系。"><a href="#👽-线程的基本概念、线程的基本状态以及状态之间的关系。" class="headerlink" title="👽 线程的基本概念、线程的基本状态以及状态之间的关系。"></a>👽 线程的基本概念、线程的基本状态以及状态之间的关系。</h3><p>一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，从宏观上来看，cpu一会执行a线程，一会执行b线程，切换时间很快，给人的感觉是a,b在同时执行。</p>
<p>状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。</p>
<p>调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。</p>
<h3 id="👽-Java的线程模型"><a href="#👽-Java的线程模型" class="headerlink" title="👽 Java的线程模型"></a>👽 Java的线程模型</h3><p>1.用户线程与内核级线程</p>
<p>线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)。用户线程由用户代码支持，内核线程由操作系统内核支持。</p>
<p>2.并发与并行</p>
<p><strong>并发：</strong>一个时间段内有很多的线程或进程在执行，但任何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。<br><strong>并行：</strong>一个时间段和时间点上都有多个线程或进程在执行。</p>
<p>3.多线程模型</p>
<p>多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。</p>
<h3 id="👽-线程与进程区别？"><a href="#👽-线程与进程区别？" class="headerlink" title="👽 线程与进程区别？"></a>👽 线程与进程区别？</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<h3 id="👽-程序计数器为什么线程是私有的"><a href="#👽-程序计数器为什么线程是私有的" class="headerlink" title="👽 程序计数器为什么线程是私有的?"></a>👽 程序计数器为什么线程是私有的?</h3><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h3 id="👽-虚拟机栈和本地方法栈为什么线程是私有的"><a href="#👽-虚拟机栈和本地方法栈为什么线程是私有的" class="headerlink" title="👽 虚拟机栈和本地方法栈为什么线程是私有的?"></a>👽 虚拟机栈和本地方法栈为什么线程是私有的?</h3><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h3 id="👽-什么是线程上下文切换"><a href="#👽-什么是线程上下文切换" class="headerlink" title="👽 什么是线程上下文切换?"></a>👽 什么是线程上下文切换?</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的<strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="👽-Java多线程编程有几种线程间通信方式"><a href="#👽-Java多线程编程有几种线程间通信方式" class="headerlink" title="👽 Java多线程编程有几种线程间通信方式"></a>👽 Java多线程编程有几种线程间通信方式</h3><ol>
<li><p><strong>共享内存法</strong></p>
<p>volatile，synchronized</p>
</li>
<li><p><strong>wait/notify机制</strong></p>
<p>来自Object类的方法。当满足某种情况时A线程调用wait()方法放弃CPU时间片，并进入阻塞状态。当满足某种条件时，B线程调用notify()方法通知A线程。唤醒A线程，并让它进入可运行状态。</p>
</li>
<li><p><strong>Lock/Condition机制</strong></p>
<p>Condition是Java提供来实现<strong>等待/通知</strong>的类，Condition类还提供比wait/notify更丰富的功能，Condition对象是由lock对象所创建的。但是同一个锁可以创建多个Condition的对象，即创建多个对象监视器。这样的好处就是可以指定唤醒线程。notify唤醒的线程是随机唤醒一个。</p>
</li>
</ol>
<h3 id="😎-volatile如何实现内存可见性？"><a href="#😎-volatile如何实现内存可见性？" class="headerlink" title="😎 volatile如何实现内存可见性？"></a>😎 volatile如何实现内存可见性？</h3><p><strong>volatile为什么会出现：</strong></p>
<p>首先先分析一下没有volatile的情况下线程在自己的私有内存中对共享变量做出了改变之后无法及时告知其他线程，这就是volatile的作用，解决内存可见性问题。这种问题用synchronized关键字可以解决。但是一个问题是synchronized是重量级锁，同一时间内只允许一个线程去操作共享变量。操作完成之后再将改变后的变量值刷新回共享内存空间中。这样一来的话并发性就没有了。而且<strong>synchronized关键词的使用基于操作系统实现</strong>，会使得线程从用户态陷入内核态。这一步是很耗时间的。于是volatile应运而生。它是一个轻量级的synchronized。只是用来解决内存可见性问题的。</p>
<p><strong>1、volatile可见性实现原理：</strong></p>
<p>变量被volatile关键字修饰后，底层<strong>汇编指令</strong>中会出现一个<strong>lock前缀指令</strong>。会导致以下两种事情的发生：</p>
<ol>
<li>修改volatile变量时会<strong>强制</strong>将修改后的值刷新到主内存中。</li>
<li>修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新读取主内存中的值。</li>
</ol>
<p><strong>2、volatile有序性实现原理：</strong></p>
<p><strong>指令重排序：</strong>编译器在不改变单线程程序语义的前提下，会重新安排语句的执行顺序，指令重排序在单线程下不会有问题，但是在多线程下，可能会出现问题。</p>
<p>volatile有序性的保证就是通过<strong>禁止指令重排序</strong>来实现的。指令重排序包括编译器和处理器重排序，JMM会分别限制这两种指令重排序。禁止指令重排序又是通过加<strong>内存屏障</strong>实现的。</p>
<blockquote>
<p>内存屏障（memory barriers）：也叫内存栅栏，是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。</p>
<ul>
<li>LoadLoad 屏障:对于这样的语句 Load1; LoadLoad; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreStore 屏障: 对于这样的语句 Store1; StoreStore; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li>LoadStore 屏障:对于这样的语句 Load1; LoadStore; Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。</li>
<li>StoreLoad 屏障:对于这样的语句 Store1; StoreLoad; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的。 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
</blockquote>
<p>添加了volatile关键字可以避免半初始化的指令重排。</p>
<h3 id="😎-volatile为什么不保证原子性？"><a href="#😎-volatile为什么不保证原子性？" class="headerlink" title="😎 volatile为什么不保证原子性？"></a>😎 volatile为什么不保证原子性？</h3><p>Java中只有对变量的赋值和读取是原子性的，其他的操作都不是原子性的。所以即使volatile即使能保证被修饰的变量具有可见性，但是不能保证原子性。</p>
<h3 id="😎-DCL单例为什么需要加volatile-（半初始化的指令重排）？"><a href="#😎-DCL单例为什么需要加volatile-（半初始化的指令重排）？" class="headerlink" title="😎 DCL单例为什么需要加volatile （半初始化的指令重排）？"></a>😎 DCL单例为什么需要加volatile （半初始化的指令重排）？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。 使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<p>volatile两个作用：保持线程可见性；<strong>禁止指令重排序</strong>。</p>
<p><strong>DCL单例需要加volatile，来禁止指令重排。</strong></p>
<p>由于java编译器允许处理器乱序执行（以获得最优的性能），new对象的操作不是原子性的。这句代码最终会被编译成多条汇编指令。所以需要volatile关键字来禁止指令重排。</p>
<p><strong>创建一个对象的过程中一旦出现了指令重排，可能就会获得半初始化的对象，</strong>即还没来得及赋值就先建立了引用关系。要避免这种情况的发生就要使用volatile关键字修饰实列变量。</p>
<p><strong>第一次判断singleton是否为null</strong><br>  第一次判断是在Synchronized同步代码块外进行判断，由于单例模式只会创建一个实例，并通过getInstance方法返回singleton对象，所以，第一次判断，是为了在singleton对象已经创建的情况下，避免进入同步代码块，提升效率。</p>
<p><strong>第二次判断singleton是否为null</strong><br>  第二次判断是为了避免以下情况的发生。<br>  (1)假设：线程A已经经过第一次判断，判断singleton=null，准备进入同步代码块.<br>  (2)此时线程B获得时间片，由于线程A并没有创建实例，所以，判断singleton仍然=null，所以线程B创建了实例singleton。<br>  (3)此时，线程A再次获得时间片，由于刚刚经过第一次判断singleton=null(不会重复判断)，进入同步代码块，这个时候，我们如果不加入第二次判断的话，那么线程A又会创造一个实例singleton，就不满足我们的单例模式的要求，所以第二次判断是很有必要的。</p>
<h3 id="😎-happen-before原则"><a href="#😎-happen-before原则" class="headerlink" title="😎 happen-before原则"></a>😎 happen-before原则</h3><ul>
<li>单线程 happen-before 原则:在同一个线程中，书写在前面的操作 happen- before 后面的操作。 锁的 happen-before 原则:同一个锁的 unlock 操作 happen-before 此锁的 lock 操作。</li>
<li>volatile 的 happen-before 原则:对一个 volatile 变量的写操作 happen- before 对此变量的任意操作(当然也包括写操作了)。</li>
<li>happen-before 的传递性原则:如果 A 操作 happen-before B 操作，B 操作 happen-before C 操作，那么 A 操作 happen-before C 操作。</li>
<li>线程启动的 happen-before 原则:同一个线程的 start 方法 happen-before 此线程的其它方法。</li>
<li>线程中断的 happen-before 原则 :对线程 interrupt 方法的调用 happen- before 被中断线程的检测到中断发送的代码。</li>
<li>线程终结的 happen-before 原则: 线程中的所有操作都 happen-before 线程的终止检测。</li>
<li>对象创建的 happen-before 原则: 一个对象的初始化完成先于他的 finalize 方法调用。</li>
</ul>
<h3 id="👻-Thread-Local-作用、原理、内存泄漏问题？"><a href="#👻-Thread-Local-作用、原理、内存泄漏问题？" class="headerlink" title="👻 Thread Local 作用、原理、内存泄漏问题？"></a>👻 Thread Local 作用、原理、内存泄漏问题？</h3><p><strong>作用：</strong></p>
<p><code>ThreadLocal</code>为解决多线程下的线程安全问题提供了一个新思路，它通过为每一个线程提供一个独立的变量副本解决了线程并发访问共享变量出现的安全问题。在很多情况下<code>ThreadLocal</code>比直接使用synchronized同步机制解决线程安全问题更加方便、简洁。且拥有更加高的并发性。</p>
<p><strong>原理：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在每个线程Thread内部有一个<code>ThreadLocal.ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，这个<code>threadLocals</code>就是用来<strong>存储实际的变量副本</strong>的，键值为当前<code>ThreadLocal</code>的引用，value为变量副本（即T类型的变量）。</li>
<li>初始时，在Thread里面，<code>threadLocals</code>为空，当通过<code>ThreadLocal</code>变量调用get()方法或者set()方法，就会对Thread类中的<code>threadLocals</code>进行初始化，并且以当前<code>ThreadLocal</code>对象引用为键值，以<code>ThreadLocal</code>要保存的副本变量为value，存到<code>threadLocals</code>。</li>
<li>然后在当前线程里面，如果要使用副本变量，就可以通过get()方法在<code>threadLocals</code>里面查找。</li>
</ol>
<p><strong><code>ThreadLocal</code>内存泄漏</strong></p>
<p>由于<code>ThreadLocalMap</code>的key是弱引用，而<code>Value</code>是强引用。这就导致了一个问题，<code>ThreadLocal</code>在没有外部对象强引用时，发生GC时（无论是否OOM）弱引用Key会被回收。这个时候就会出现Entry中Key已经被回收，出现一个<code>null Key</code>的情况，外部读取<code>ThreadLocalMap</code>中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的<code>ThreadLocalMap</code>对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：<code>Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value</code>，这条强引用链会导致<code>Entry</code>不会回收， <code>Value</code>也不会回收，但Entry中的Key却已经被回收的情况，造成<strong>内存泄漏</strong>。</p>
<p><strong>解决办法：</strong>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。</p>
<p><strong><code>ThreadLocal</code>应用场景</strong></p>
<p>最常见的<code>ThreadLocal</code>使用场景为用来解决数据库连接、Session管理等。</p>
<h3 id="😎🤢-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#😎🤢-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="😎🤢 说说 synchronized 关键字和 volatile 关键字的区别"></a>😎🤢 说说 synchronized 关键字和 volatile 关键字的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h3 id="😀-自旋锁-VS-适应性自旋锁"><a href="#😀-自旋锁-VS-适应性自旋锁" class="headerlink" title="😀 自旋锁 VS 适应性自旋锁"></a>😀 自旋锁 VS 适应性自旋锁</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是<strong>自旋锁</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/452a3363-20231217152835634.png" alt="img"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/83b3f85e.png" alt="img"></p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p><strong>自适应</strong>意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h3 id="🤢-Synchronized与ReentrantLock的区别？"><a href="#🤢-Synchronized与ReentrantLock的区别？" class="headerlink" title="🤢 Synchronized与ReentrantLock的区别？"></a>🤢 Synchronized与ReentrantLock的区别？</h3><p><strong>实现原理上:</strong></p>
<p><code>synchronized</code>是依靠<code>jvm</code>以及配合操作系统来实现，是一个<strong>关键字</strong>。<code>reentrantLock</code>是<code>jdk1.5</code>之后提供的<strong>API层面</strong>的互斥锁，实现了Lock接口。</p>
<p><strong>使用便利性上：</strong></p>
<p><code>synchronized</code>只需要添加上相关关键字即可，加锁与释放过程由操作系统完成。<code>reentrantLock</code>则需要手动加锁与释放锁。</p>
<p><strong>锁粒度与灵活度：</strong></p>
<p>reentrantLock<code>要强于</code>synchronized</p>
<p><code>reentrantLock</code>提供了<strong>三个高级功能</strong>:</p>
<ol>
<li><strong>等待可中断</strong>，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相对于Synchronized来说可以避免出现死锁的情况。通过<code>lock.lockInterruptibly()</code>来实现这个机制。</li>
<li>Synchronized锁是非公平锁，<code>ReentrantLock</code>默认的构造函数是创建的非公平锁，但可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>
<li>一个<code>ReentrantLock</code>对象可以同时绑定多个对象。<code>ReenTrantLock</code>提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li>
</ol>
<p><strong>性能区别：</strong></p>
<p><code>synchronized</code>优化之后性能与<code>reentrantLock</code>已经不相上下了，官方甚至更建议使用<code>synchronized</code>关键字。</p>
<h3 id="🤢-synchronized修饰的对象"><a href="#🤢-synchronized修饰的对象" class="headerlink" title="🤢 synchronized修饰的对象"></a>🤢 synchronized修饰的对象</h3><ul>
<li>修饰一个类：其作用的范围是synchronized后面括号括起来的部分，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个方法：被修饰的方法称为同步方法，其作用的范围是整个方法，<strong>作用的对象是调用这个方法的对象</strong>；</li>
<li>修饰一个静态的方法：其作用的范围是整个方法，<strong>作用的对象是这个类的所有对象</strong>；</li>
<li>修饰一个代码块：被修饰的代码块称为同步语句块，其作用范围是大括号{}括起来的代码块，<strong>作用的对象是调用这个代码块的对象</strong>；</li>
</ul>
<h3 id="🤢-Synchronized实现原理？"><a href="#🤢-Synchronized实现原理？" class="headerlink" title="🤢 Synchronized实现原理？"></a>🤢 Synchronized实现原理？</h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>每个对象（在对象头中）有一个<strong>监视器锁</strong><code>（monitor）</code>，当monitor被占用时就处于锁定状态。线程执行<code>monitorenter</code>（汇编指令）尝试获取monitor的所有权。实现原子性操作和解决共享变量的内存可见性问题。</p>
<ol>
<li>如果monitor计数器当前值为0，那么该线程进入monitor并将计数器加1，</li>
<li>如果当前monitor计数器值不为0，那么该线程阻塞并进入（OS维护的）队列等待，等到OS的调度。</li>
</ol>
<p>底层字节码被编译成<code>monitorenter</code>和<code>monitorexit</code>两个指令。线程执行<code>monitorexit</code>指令，monitor计数器减1，如果减到0了，表示当前线程不再拥有该监视器锁。等待队列中的线程有机会获得锁资源。</p>
<p><strong>内部处理过程</strong>(内部有两个队列waitSet和entryList):</p>
<ul>
<li>1、当多个线程进入同步代码块时，首先进入entryList</li>
<li>2、有一个线程获取到monitor锁后，就将对象头的Mark Word中的线程ID设置为当前线程，并且计数器+1</li>
<li>3、如果线程调用wait方法，将释放锁，当前线程ID置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</li>
<li>4、如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220701233410657-20231217152836086.png" alt="image-20220701233410657"></p>
<p>在synchronized大（优化）升级之前，是重量级锁，锁操作都要经过OS。向OS内核去申请。（<code>jdk1.5之后</code>）到现在的synchronized是有一个复杂的锁升级过程。</p>
<p><strong>无锁 -&gt; 偏向锁 -&gt; 自旋锁（轻量级锁） -&gt; （重量级锁）悲观锁。</strong></p>
<p>以上的升级状态都记录在对象头中。</p>
<p><strong>偏向锁：</strong>hotspot虚拟机认为大多数时间是不存在锁竞争的，所以每次都会把锁分配给上一次获得锁的线程，直到出现了锁竞争。</p>
<p><strong>自旋锁：</strong>线程之间以CAS的方式进行锁资源的争抢。当一个线程自旋超过了10次或者当前自旋等待的线程超过了CPU核数的1/2（升级后优化为自适应自旋），会进行锁升级。</p>
<p><strong>synchronized：</strong> 向OS申请资源，从用户态切换到内核态。线程挂起进入<strong>等待队列</strong>，等待OS的调度。然后再映射回用户空间。</p>
<h3 id="🤢-获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？"><a href="#🤢-获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？" class="headerlink" title="🤢 获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？"></a>🤢 获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？</h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor 实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VUwexGERUjTeMnDEpRMB3g">一文全面梳理各种锁机制</a></p>
<h3 id="🤢-Synchronized的锁升级过程"><a href="#🤢-Synchronized的锁升级过程" class="headerlink" title="🤢 Synchronized的锁升级过程"></a>🤢 Synchronized的锁升级过程</h3><p>首先为什么Synchronized能实现线程同步？</p>
<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<p><strong>Java对象头</strong>:</p>
<p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>Monitor:</strong></p>
<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220707164758951.png" alt="image-20220707164758951"></p>
<p><strong>无锁</strong></p>
<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<p><strong>轻量级锁</strong></p>
<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/8afdf6f2-20231217152836445.png" alt="img"></p>
<p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h3 id="🤢-为什么说-Synchronized-是可重入锁？"><a href="#🤢-为什么说-Synchronized-是可重入锁？" class="headerlink" title="🤢 为什么说 Synchronized 是可重入锁？"></a>🤢 为什么说 Synchronized 是可重入锁？</h3><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220309201446490.png" alt="image-20220309201446490"></p>
<h3 id="🤢-synchronized可重入锁的实现？"><a href="#🤢-synchronized可重入锁的实现？" class="headerlink" title="🤢 synchronized可重入锁的实现？"></a>🤢 synchronized可重入锁的实现？</h3><p>重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p>
<h3 id="🤢-为什么说-Synchronized-是非公平锁"><a href="#🤢-为什么说-Synchronized-是非公平锁" class="headerlink" title="🤢 为什么说 Synchronized 是非公平锁?"></a>🤢 为什么说 Synchronized 是非公平锁?</h3><p>Synchronized底层是调用mutex锁的，内核提供的这个锁并不保证公平。而Java所提供的公平锁Lock实际上是由Java的API支持的（即对AQS的实现）</p>
<p>非公平是指在获取锁的行为上，并不是按照线程申请顺序进行分配的，当锁被释放后，所有线程都有机会获取到锁，这样提高了性能，但是可能会出现某些线程饥饿的情况。</p>
<h3 id="🤢-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#🤢-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="🤢 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>🤢 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h3><p>分几种情况：</p>
<p>1）其他方法前是否加了synchronized关键字，如果没加，则能。</p>
<p>2）如果这个方法内部调用了wait，则可以进入其他synchronized方法。</p>
<p>3）如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</p>
<p>4）如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</p>
<h3 id="🤢-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？"><a href="#🤢-为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？" class="headerlink" title="🤢 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？"></a>🤢 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？</h3><p>当 Synchronized升级为重量级锁时，他是一个悲观锁。<strong>获取不到锁资源的线程由OS统一管理</strong>，涉及到用户态到内核态的切换。</p>
<p>乐观锁就是，当一个线程想要对变量进行操作时，先读取变量值，然后真正更改时会再次对比当前值与自己之前读取的值是否相同，相同才会进行更改，不相同的话就会再次读取，然后在进行对比更改。主要是基于CAS实现。</p>
<h3 id="😡-悲观锁和乐观锁的区别"><a href="#😡-悲观锁和乐观锁的区别" class="headerlink" title="😡 悲观锁和乐观锁的区别"></a>😡 悲观锁和乐观锁的区别</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82">https://www.cnblogs.com/kismetv/p/10787228.html#:~:text=%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%9C%A8,%E5%88%AB%E4%BA%BA%E4%BC%9A%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E3%80%82</a></p>
<p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>
<ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>
</ul>
<h3 id="😡-MySQL如何实现乐观锁？"><a href="#😡-MySQL如何实现乐观锁？" class="headerlink" title="😡 MySQL如何实现乐观锁？"></a>😡 MySQL如何实现乐观锁？</h3><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p>
<p>乐观锁的实现原理：</p>
<ol>
<li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。</li>
<li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。</li>
<li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li>
</ol>
<p>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h3 id="🧑-CAS原理"><a href="#🧑-CAS原理" class="headerlink" title="🧑 CAS原理"></a>🧑 CAS原理</h3><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V。</li>
<li>进行比较的值 A。</li>
<li>要写入的新值 B。</li>
</ul>
<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>
<p>CAS具有原子性,他的原子性由CPU保证,由JNI调用c++硬件代码实现,<code>jdk</code>中提供了unsafe来进行这些操作。</p>
<h3 id="🧑-CAS乐观锁有什么缺点？"><a href="#🧑-CAS乐观锁有什么缺点？" class="headerlink" title="🧑 CAS乐观锁有什么缺点？"></a>🧑 CAS乐观锁有什么缺点？</h3><ol>
<li>乐观锁的情况下，如果线程并发度确实很高，那么大多数的线程都会处于自旋等待以获取锁对象的状态。这样会导致CPU占用过高。</li>
<li>CAS另一个缺点就是ABA问题。一个值从A改为B又改为A,则CAS认为没有发生变化,解决的方式是使用<strong>版本号</strong>来记录操作次数。或者使用Java中提供的AtomicStampedReference，增加了标志字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部满足条件才会更新</li>
<li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ID6_DQAuv6ire3u58XpSrg">CAS原理分析，解决银行转账ABA难题</a></p>
<h3 id="🐱-什么是锁消除和锁粗化？"><a href="#🐱-什么是锁消除和锁粗化？" class="headerlink" title="🐱 什么是锁消除和锁粗化？"></a>🐱 什么是锁消除和锁粗化？</h3><p>锁消除即删除不必要的加锁操作。JVM在运行时，对一些“在代码上要求同步，但是<strong>被检测到不可能存在共享数据竞争情况”的锁进行消除</strong>。根据代码逃逸技术，如果判断到一段代码中，<strong>堆上的数据不会逃逸出当前线程</strong>，那么就可以认为这段代码是线程安全的，无需加锁。</p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockClearTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearTest</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            test.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer的append代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码看出来，StringBuffer的append是个同步方法，但是LockClearTest中的 StringBuffer 属于一个局部变量，不可能从该方法中逃逸出去（即stringBuffer的引用没有传递到该方法外，不会被其他线程引用），因此其实这过程是线程安全的，可以将锁消除。</p>
<p>假设一系列的连续操作都会<strong>对同一个对象反复加锁及解锁</strong>，甚至加锁操作是出现在循环体中的，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会<strong>扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</strong></p>
<p>下面代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码每次调用 stringBuffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h3 id="🐱-AtomicInteger原子类源码解析"><a href="#🐱-AtomicInteger原子类源码解析" class="headerlink" title="🐱 AtomicInteger原子类源码解析"></a>🐱 AtomicInteger原子类源码解析</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/feda866e.png" alt="img"></p>
<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li>unsafe： 获取并操作内存的数据。</li>
<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>
<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>
</ul>
<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">  <span class="type">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>
<h3 id="🤢-ReentrantLock实现原理？"><a href="#🤢-ReentrantLock实现原理？" class="headerlink" title="🤢 ReentrantLock实现原理？"></a>🤢 ReentrantLock实现原理？</h3><p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/7aadb272069d871bdee8bf3a218eed8136919-20231217152837112.png" alt="img"></p>
<p>加锁：</p>
<ul>
<li>通过 ReentrantLock 的加锁方法 Lock 进行加锁操作。</li>
<li>会调用到内部类 Sync 的 Lock 方法，由于 Sync#lock 是抽象方法，根据 ReentrantLock 初始化选择的公平锁和非公平锁，执行相关内部类的 Lock 方法，本质上都会执行 AQS 的 Acquire 方法。</li>
<li>AQS 的 Acquire 方法会执行 tryAcquire 方法，但是由于 tryAcquire 需要自定义同步器实现，因此执行了 ReentrantLock 中的 tryAcquire 方法，由于 ReentrantLock 是通过公平锁和非公平锁内部类实现的 tryAcquire 方法，因此会根据锁类型不同，执行不同的 tryAcquire。</li>
<li>tryAcquire 是获取锁逻辑，获取失败后，会执行框架 AQS 的后续逻辑，跟 ReentrantLock 自定义同步器无关。</li>
</ul>
<p>解锁：</p>
<ul>
<li>通过 ReentrantLock 的解锁方法 Unlock 进行解锁。</li>
<li>Unlock 会调用内部类 Sync 的 Release 方法，该方法继承于 AQS。</li>
<li>Release 中会调用 tryRelease 方法，tryRelease 需要自定义同步器实现，tryRelease 只在 ReentrantLock 中的 Sync 实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li>
<li>释放成功后，所有处理由 AQS 框架完成，与自定义同步器无关。</li>
</ul>
<p>通过上面的描述，大概可以总结出 ReentrantLock 加锁解锁时 API 层核心方法的映射关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt="img"></p>
<h3 id="🤢-AQS原理？"><a href="#🤢-AQS原理？" class="headerlink" title="🤢 AQS原理？"></a>🤢 AQS原理？</h3><p>AQS框架是用来构建锁的同步器框架,包括了常用的<code>ReentrantLock</code>,<code>ReadWriteLock</code>,<code>CountDownLatch</code>等都是基于AQS框架来实现的。</p>
<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS 使用一个 int 成员变量state来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态state进行原子操作实现对其值的修改。一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把 state 重新置为0，同时 当前线程ID 置为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🤢-AQS中的公平锁和非公平锁"><a href="#🤢-AQS中的公平锁和非公平锁" class="headerlink" title="🤢 AQS中的公平锁和非公平锁"></a>🤢 AQS中的公平锁和非公平锁</h3><ul>
<li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<p><code>ReentrantLock</code> 默认采用非公平锁，因为考虑获得更好的性能，通过 <code>boolean</code> 来决定是否用公平锁（传入 true 用公平锁）。</p>
<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h3 id="🤢-AQS内部如何控制并发？"><a href="#🤢-AQS内部如何控制并发？" class="headerlink" title="🤢 AQS内部如何控制并发？"></a>🤢 AQS内部如何控制并发？</h3><p><code>AQS（AbstractQueuedSynchronizer）</code>是<code>J.U.C</code>包下<strong>lock</strong>实现的核心。主要是其提供的一个FIFO的队列来维护获取锁失败而进入阻塞的线程，以及一个volatile关键字修饰的state变量表示当前同步状态。当一个线程获取到同步状态（修改state=1），那么其他线程便无法获取，转而被构造成节点并加入同步队列中。<strong>加入队列的过程基于CAS算法。即比较当前线程认为的尾节点与当前节点，比较成功后才能正式加入队列尾部。</strong>队列头节点表示的为当前正在运行的线程，该线程执行结束后会激活它下面的一个线程进入执行状态。</p>
<p>FIFO同步队列控制并发。</p>
<h3 id="🤢-AQS为什么底层使用CAS和volatile？"><a href="#🤢-AQS为什么底层使用CAS和volatile？" class="headerlink" title="🤢 AQS为什么底层使用CAS和volatile？"></a>🤢 AQS为什么底层使用CAS和volatile？</h3><ol>
<li>AQS源码中<code>state</code>状态值使用<code>volatile</code>修饰保证内存的可见性。因为涉及到多线程对state的修改，必须保证其对所有线程的可见性。</li>
<li>CAS操作主要用于对state值的修改。</li>
</ol>
<h3 id="😡-了解CountDownLatch吗？"><a href="#😡-了解CountDownLatch吗？" class="headerlink" title="😡 了解CountDownLatch吗？"></a>😡 了解CountDownLatch吗？</h3><p>一个或者多个线程，等待其他多个线程完成某件事情之后才能执行;</p>
<p>主要包含两个方法，一个是<code>countDown()</code>，一个是<code>await()</code>;以及一个计数器变量<code>cnt</code>。<code>countDown()</code> 方法用来给计数器<code>cnt</code>减一； <code>await()</code> 方法是用来阻塞当前线程，直到计数器为0的时候再唤醒线程继续执行；</p>
<h3 id="😡-了解CyclicBarrier吗？"><a href="#😡-了解CyclicBarrier吗？" class="headerlink" title="😡 了解CyclicBarrier吗？"></a>😡 了解CyclicBarrier吗？</h3><p>多个线程互相等待，直到到达同一个同步点，再继续一起执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/image-20220909195445283-20231217152837474.png" alt="image-20220909195445283"  /></p>
<h3 id="😡-了解Semaphore吗"><a href="#😡-了解Semaphore吗" class="headerlink" title="😡 了解Semaphore吗?"></a>😡 了解Semaphore吗?</h3><p>信号量，用于多个共享资源的互斥使用，也可以<strong>用来控制线程的并发量</strong>，类似于线程池的作用。</p>
<p>可以用于限制线程的并发数。                                                                                                                                        </p>
<h3 id="😓-产生死锁必须具备以下四个条件"><a href="#😓-产生死锁必须具备以下四个条件" class="headerlink" title="😓 产生死锁必须具备以下四个条件"></a>😓 产生死锁必须具备以下四个条件</h3><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="😓-如何预防和避免线程死锁"><a href="#😓-如何预防和避免线程死锁" class="headerlink" title="😓 如何预防和避免线程死锁?"></a>😓 如何预防和避免线程死锁?</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<p>​    1.<strong>破坏互斥条件</strong>:使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<p> <strong>安全状态</strong> 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。</p>
<h3 id="😓-死锁的产生、防止、避免、检测和解除"><a href="#😓-死锁的产生、防止、避免、检测和解除" class="headerlink" title="😓 死锁的产生、防止、避免、检测和解除"></a>😓 死锁的产生、防止、避免、检测和解除</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p>
<h3 id="😭-线程池以及使用线程池的好处"><a href="#😭-线程池以及使用线程池的好处" class="headerlink" title="😭 线程池以及使用线程池的好处"></a>😭 线程池以及使用线程池的好处</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>
<p><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p>
<h3 id="😭-线程池的创建方式（7种）"><a href="#😭-线程池的创建方式（7种）" class="headerlink" title="😭 线程池的创建方式（7种）"></a>😭 线程池的创建方式（7种）</h3><p>线程池的创建方法总共有 7 种，但总体来说可分为 2 类：</p>
<ul>
<li>一类是通过 <code>ThreadPoolExecutor</code> 创建的线程池；</li>
<li>另一个类是通过 <code>Executors</code> 创建的线程池。</li>
</ul>
<p>线程池的创建方式总共包含以下 7 种（其中 6 种是通过 <code>Executors</code> 创建的，1 种是通过 <code>ThreadPoolExecutor</code> 创建的）：</p>
<ol>
<li><strong>Executors.newFixedThreadPool（nThreads）</strong>：该方法创建一个固定数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行，若没有，则新的任务会被 暂存在一个任务<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=队列&amp;spm=1001.2101.3001.7020">队列</a>中，待有空闲线程时，便处理在任务队列中的任务。</li>
<li><strong>Executors.newCachedThreadPool</strong>：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先 使用可复用的线程。 若所有线程均工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前安任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>Executors.newSingleThreadExecutor</strong>：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。虽然是单线程池，但提供了工作队列，生命周期管理，工作线程维护等功能。</li>
<li><strong>Executors.newScheduledThreadPool</strong>：创建一个可以执行延迟任务的线程池；</li>
<li><strong>Executors.newSingleThreadScheduledExecutor</strong>：创建一个单线程的可以执行延迟任务的线程池；虽然是单线程池，但提供了工作队列，生命周期管理，工作线程维护等功能。</li>
<li><strong>Executors.newWorkStealingPool</strong>：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li>
<li><strong>ThreadPoolExecutor</strong>：最原始的创建线程池的方式，它包含了 7 个参数可供设置</li>
</ol>
<h3 id="😭-线程池中的工作队列"><a href="#😭-线程池中的工作队列" class="headerlink" title="😭 线程池中的工作队列"></a>😭 线程池中的工作队列</h3><p>参数workQueue 指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象。 根据队列功能分类，在ThreadPoolExecutor的构造函数中可使用一下几种BlockingQueue。</p>
<p><strong>直接提交的队列</strong>： 该功能由 <strong>SynchronousQueue</strong>对象提供。SynchronousQueue 是一个特殊的BlocingQueue。 它没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如皋市使用SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的进程，则尝试创建新的进程，如果进程的数量已达到最大值，则执行拒绝策略。</p>
<p><strong>有界的任务队列</strong><br>有界的任务队列可以使用<strong>ArrayBlockingQueue</strong>实现。当使用有界队列时，若有新的任务需要执行，如果线程池的实际线程数小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务假如等待队列。若等待队列已满，无法加入，在总线程数，不大于maximumPoolSize的前提下，创建新的进程执行任务。若大于maximumPoolSize，则执行拒绝策略。</p>
<p><strong>无界的任务队列</strong><br>无界的任务队列可以通过<strong>LinkedBlockingQueue</strong>类实现。与有界队列相反，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，线程池会产生新的线程执行任务，但当系统的线程数达到corePoolSize后，就会继续增加。若后续仍有新的任务假如，而又没有空闲的线程资源，则任务直接进入对列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，知道耗尽系统内存。</p>
<p><strong>任务优先队列</strong><br>优先任务队列是带有执行优先级的队列，它通过<strong>PriorityBlockingQueue</strong>实现，可以控制任务的只想你个先后顺序。它是一个特殊的无界队列。</p>
<h3 id="😭-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#😭-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="😭 执行 execute()方法和 submit()方法的区别是什么呢？"></a>😭 执行 execute()方法和 submit()方法的区别是什么呢？</h3><p><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="😭-Thread和Runnable的关系"><a href="#😭-Thread和Runnable的关系" class="headerlink" title="😭 Thread和Runnable的关系"></a>😭 Thread和Runnable的关系</h3><p>对于Thread，我们是定义一个类继承Thread，实现Thread中的run方法，然后new一个这个类的对象，调用类的start方法。当执行 start() 后，线程进入就绪状态，当对应的线程抢占到 cpu 调度资源之后，进入运行状态，此时调用的是 run 方法，执行完毕之后就结束了。</p>
<p>对于Runnable，一般是定义一个类MyTask实现Runnable接口，重写其中的run方法，这里 MyTask 就是一个 Runnable，实现了 run() 方法，作为 Thread() 的入参。</p>
<p>在Runnable的接口定义中的run方法中，<strong>当一个对象继承并实现了 run() 方法，当线程 start() 后，会在该线程中单独执行该对象的 run() 方法。</strong>所以Runnable和T患儿add的关系如下：</p>
<ol>
<li>MyTask 继承 Runnable，并实现了 run() 方法；</li>
<li>Thread 初始化，将 MyTask 作为自己的成员变量；</li>
<li>Thread 执行 run() 方法，线程处于“就绪”状态；</li>
<li>等待 CPU 调度，执行 Thread 的 run() 方法，但是 run() 的内部实现，其实是执行的 MyTask.run() 方法，线程处于“运行”状态。</li>
</ol>
<p>在Thread的源码中，在 Thread 初始化时，<strong>MyTask 作为入参 target，最后赋值给 Thread.target</strong>。当执行 Thread.run() 时，<strong>其实是执行的 target.run()，即 MyTask.run()，这个是典型的策略模式</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/640-20231217134127534-20231217152837660.png" alt="图片"></p>
<p>其实对于 Thread 和 Runable，其 run() 都是无返回值的，并且无法抛出异常，<strong>所以当你需要返回多线程的数据，就需要借助 Callable 和 Future。</strong></p>
<h3 id="😭-Callable和FutureTask的关系"><a href="#😭-Callable和FutureTask的关系" class="headerlink" title="😭 Callable和FutureTask的关系"></a>😭 Callable和FutureTask的关系</h3><p>Callable 是一个接口，里面有个 V call() 方法，这个 V 就是我们的返回值类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般会用匿名类的方式使用 Callable，call() 中是具体的业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is Callable is running&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过关系图谱，FutureTask 继承了 RunnableFuture，RunnableFuture 继承了 Runnable 和 Future.<strong>所以，FutureTask 也是个 Runnable ！</strong>既然 FutureTask 是个 Runnable，肯定就需要实现.run() 方法，那么 FutureTask 也可以作为 Thread 的初始化入参，使用姿势如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(FutureTask对象).start();</span><br></pre></td></tr></table></figure>
<p><strong>所以当执行 Thread.run() 时，其实是执行的 FutureTask.run()</strong></p>
<p><strong>Callable 和 FutureTask 的关系</strong>:</p>
<p>FutureTask 初始化时，Callable 必须作为 FutureTask 的初始化入参：</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/640-20220815133621982.png" alt="图片"></p>
<p>当执行 FutureTask.run() 时，其实执行的是 Callable.call(),<strong>所以，这里又是一个典型的策略模式 ！</strong></p>
<p>现在我们应该可以很清楚知道 Thread 、Runnable、FutureTask 和 Callable 的关系：</p>
<ul>
<li>Thread.run() 执行的是 Runnable.run()；</li>
<li>FutureTask 继承了 Runnable，并实现了 FutureTask.run()；</li>
<li>FutureTask.run() 执行的是 Callable.run()；</li>
<li>依次传递，最后 Thread.run()，其实是执行的 Callable.run()。</li>
</ul>
<p>所以整个设计方法，其实就是 2 个策略模式，<strong>Thread 和 Runnable 是一个策略模式，FutureTask 和 Callable 又是一个策略模式，最后通过 Runnable 和 FutureTask 的继承关系，将这 2 个策略模式组合在一起。</strong></p>
<h3 id="😭-Future是什么？怎么使用？"><a href="#😭-Future是什么？怎么使用？" class="headerlink" title="😭 Future是什么？怎么使用？"></a>😭 Future是什么？怎么使用？</h3><p>Future可以当成是我们收货的凭证，当某些任务非常耗时的时候，我们可以先另起一个线程异步执行这个耗时的任务，同时拿到这个Future凭证。当我们这个线程结束相关的任务，想要获得结果的时候，就调用其中的<code>get()</code>方法获得结果。</p>
<ol>
<li>新建一个<code>Callable</code>匿名函数实现类对象，将业务逻辑放在<code>call()</code>之中，同时将<code>`Callable</code>的泛型设置成我们想要的返回结果类型</li>
<li>将<code>Callable</code>匿名函数对象作为<code>FutureTask</code>的构造参数传入，创建一个<code>futureTask</code>对象</li>
<li>再将<code>futureTask</code>作为<code>Thread</code>的构造参数传入，开启另一线程执行逻辑</li>
<li>在需要得到结果时候调用<code>futureTask</code>的<code>get()</code>方法。</li>
</ol>
<p>我们看一下 Future 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务，如果任务正在运行的，mayInterruptIfRunning为true时，表明这个任务会被打断的，并返回true；</span></span><br><span class="line">    <span class="comment">// 为false时，会等待这个任务执行完，返回true；若任务还没执行，取消任务后返回true，如任务执行完，返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消了,正常执行完不算被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成，任务取消或发生异常也算是完成，返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务返回结果，如果任务没有执行完成则等待完成将结果返回，如果获取的过程中发生异常就抛出异常，</span></span><br><span class="line">    <span class="comment">// 比如中断就会抛出InterruptedException异常等异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 在规定的时间如果没有返回结果就会抛出TimeoutException异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 FutureTask，Callable 就是他的任务，而 FutureTask 内部维护了一个任务状态，所有的状态都是围绕这个任务来进行的，随着任务的进行，状态也在不断的更新。</p>
<p>FutureTask 继承了 Future，实现对任务的取消、数据获取、任务状态判断等功能。</p>
<p>比如我们经常会调用 get() 方法获取数据，如果任务没有执行完成，会将当前线程放入阻塞队列等待，当任务执行完后，会唤醒阻塞队列中的线程。</p>
<h3 id="😭-FutureTask用来解决什么问题？"><a href="#😭-FutureTask用来解决什么问题？" class="headerlink" title="😭 FutureTask用来解决什么问题？"></a>😭 FutureTask用来解决什么问题？</h3><p>FutureTask可看作对异步任务的封装，异步任务在它的封装下，可灵活进行阻塞获取结果或者中断。它继承了Runable以及Future接口，所以它可以灵活的作为Runnable给thread执行，也可作为Future得到callable的计算结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/d0c8df53db8f45bf9295b1806d2db804~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片.png"></p>
<h3 id="😭-ThreadPoolExecutor构造函数重要参数分析"><a href="#😭-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="😭 ThreadPoolExecutor构造函数重要参数分析"></a>😭 <code>ThreadPoolExecutor</code>构造函数重要参数分析</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :线程工厂。</li>
<li><strong><code>handler</code></strong> :拒绝策略。</li>
</ol>
<p>​         <strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求，将工作队列中等待在最前面的任务丢弃，然后将新来的任务放进等待队列中。</li>
</ul>
<p>更多内容，参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SsbQc6WhFJxCarpRLGqzSA">史上最全ThreadPoolExecutor梳理(上篇)</a>，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZuD0amF-A4X7VeMuc_LJkg">史上最全ThreadPoolExecutor梳理(下篇)</a></p>
<h3 id="😭-提交一个任务到线程池的执行流程"><a href="#😭-提交一个任务到线程池的执行流程" class="headerlink" title="😭 提交一个任务到线程池的执行流程"></a>😭 提交一个任务到线程池的执行流程</h3><p>1.当线程池新加入一个线程时，首先判断当前线程数，是否小于coreSize，如果小于，则执行步骤2，否则执行3<br>2.创建新线程添加到线程池中，跳转结束<br>3.判断当前线程池等待队列是否已满，若已满，则跳转至步骤5<br>4.加入等待队列，等待线程池空闲，跳转结束<br>5.判断当前线程数是否已达到maximumPoolSize，若未达到，则跳转至步骤7<br>6.执行线程池拒绝策略，跳转结束<br>7.创建一个新线程，执行任务<br>8.跳转结束</p>
<h3 id="😭-线程池的参数怎么设置？"><a href="#😭-线程池的参数怎么设置？" class="headerlink" title="😭 线程池的参数怎么设置？"></a>😭 线程池的参数怎么设置？</h3><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="🤣-BIO-NIO-AIO"><a href="#🤣-BIO-NIO-AIO" class="headerlink" title="🤣 BIO/NIO/AIO"></a>🤣 BIO/NIO/AIO</h3><h4 id="Java中的IO原理"><a href="#Java中的IO原理" class="headerlink" title="Java中的IO原理"></a>Java中的IO原理</h4><p>首先Java中的IO都是依赖操作系统内核进行的，我们程序中的IO读写其实调用的是操作系统内核中的read&amp;write两大系统调用。</p>
<p>那内核是如何进行IO交互的呢？</p>
<ol>
<li>网卡收到经过网线传来的网络数据，并将网络数据写到内存中。</li>
<li>当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</li>
<li>将内存中的网络数据写入到对应socket的接收缓冲区中。</li>
<li>当接收缓冲区的数据写好之后，应用程序开始进行数据处理。</li>
</ol>
<p>对应抽象到java的socket代码简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//获取数据进行处理</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// socket、server，流关闭操作，省略不表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个过程和底层内核的网络IO很类似，主要体现在accept()等待从网络中的请求到来然后bytes[]数组作为缓冲区等待数据填满后进行处理。而BIO、NIO、AIO之间的区别就在于这些操作是同步还是异步，阻塞还是非阻塞。</p>
<p>所以我们引出同步异步，阻塞与非阻塞的概念。</p>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们的执行流程中：依次是方法一和方法二。</p>
<p>同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。</p>
<p>异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。</p>
<p>同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。</p>
<p>同步与异步是从多个线程之间的协调来实现效率差异。</p>
<blockquote>
<p>为什么需要异步呢？笔者认为异步的本质就是为了解决主线程的阻塞，所以网上很多讨论把同步异步、阻塞非阻塞进行了四种组合，其中一种就有异步阻塞这一情形，如果异步也是阻塞的？那为什么要特地进行异步操作呢？</p>
</blockquote>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p>
<p>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</p>
<p>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。</p>
<p>阻塞与非阻塞关注的是线程是否在原地等待。</p>
<blockquote>
<p>笔者认为阻塞和非阻塞仅能与同步进行组合。而异步天然就是非阻塞的，而这个非阻塞是对主线程而言。（可能有人认为异步方法里面放入阻塞操作的话就是异步阻塞，但是思考一下，正是因为是阻塞操作所以才会将它放入异步方法中，不要阻塞主线程）</p>
</blockquote>
<h4 id="例子讲解"><a href="#例子讲解" class="headerlink" title="例子讲解"></a>例子讲解</h4><blockquote>
<p>海底捞很好吃，但是经常要排队。我们就以生活中的这个例子进行讲解。</p>
</blockquote>
<ul>
<li>A顾客去吃海底捞，就这样干坐着等了一小时，然后才开始吃火锅。(BIO)</li>
<li>B顾客去吃海底捞，他一看要等挺久，于是去逛商场，每次逛一会就跑回来看有没有排到他。于是他最后既购了物，又吃上海底捞了。（NIO）</li>
<li>C顾客去吃海底捞，由于他是高级会员，所以店长说，你去商场随便玩吧，等下有位置，我立马打电话给你。于是C顾客不用干坐着等，也不用每过一会儿就跑回来看有没有等到，最后也吃上了海底捞（AIO）</li>
</ul>
<blockquote>
<p>哪种方式更有效率呢？是不是一目了然呢？</p>
</blockquote>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。服务器实现模式为一个连接一个线程，即客户端有连接请 求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，当然可以通过线程池机制改善。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。服务器实现模式为一个请求一个线程，即客户端发送的连 接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动 一个线程进行处理。线程发起io请求后，立即返回（非阻塞io）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。</p>
<p>NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。服务端不断轮询channel来获取客户端的信息。channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO是真正意义上的异步非阻塞IO模型。服务器实现模式为一个有效请求一个线程，客户端的 IO 请 求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。</p>
<p>AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。</p>
<h3 id="😇-线程安全有哪些实现思路"><a href="#😇-线程安全有哪些实现思路" class="headerlink" title="😇 线程安全有哪些实现思路?"></a>😇 线程安全有哪些实现思路?</h3><ol>
<li><strong>互斥同步</strong></li>
</ol>
<p>synchronized 和 ReentrantLock。</p>
<ol>
<li><strong>非阻塞同步</strong></li>
</ol>
<p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>
<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<ul>
<li><code>CAS</code></li>
</ul>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，<code>CAS</code>)。<code>CAS</code> 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<ul>
<li><code>AtomicInteger</code></li>
</ul>
<p><code>J.U.C</code> 包里面的整数原子类 <code>AtomicInteger</code>，其中的 <code>compareAndSet()</code> 和 <code>getAndIncrement()</code> 等方法都使用了 Unsafe 类的 <code>CAS</code> 操作。</p>
<ol>
<li><strong>无同步方案</strong></li>
</ol>
<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<ul>
<li>栈封闭</li>
</ul>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>
<ul>
<li>线程本地存储(Thread Local Storage)</li>
</ul>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://helingcode.github.io">vulkhe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://helingcode.github.io/posts/java-juc.html">https://helingcode.github.io/posts/java-juc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://helingcode.github.io" target="_blank">vulkhe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/commandsForRedis.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/martin-jernberg-TA05o8C77ok-unsplash.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis常用命令</div></div></a></div><div class="next-post pull-right"><a href="/posts/java-collection.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/java-collection.html" title="Java集合面试题"><img class="cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Java集合面试题</div></div></a></div><div><a href="/posts/java-basic.html" title="Java基础"><img class="cover" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/animes-girl-1425819-wallhere.com-20231217160931131.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Java基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">vulkhe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HelingCode"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HelingCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:linghezhu.if@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A3-%E7%94%A8%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95-stop-%E5%92%8Csuspend-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BD%95%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">🤣 用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%82-sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">😂 sleep() 和 wait() 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%84-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">😄 同步和异步有何异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%85-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-%E5%90%8C%E6%AD%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">😅 多线程有几种实现方法?同步有几种实现方法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%86-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">😆 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%B6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C-static-%E5%8F%98%E9%87%8F%E4%BC%9A%E6%9C%89%E5%BD%B1%E5%93%8D%E5%90%97%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">😶 多线程操作 static 变量会有影响吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%99%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">🙄 为什么要使用多线程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">👽 线程的基本概念、线程的基本状态以及状态之间的关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">👽 Java的线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">👽 线程与进程区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">11.</span> <span class="toc-text">👽 程序计数器为什么线程是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-number">12.</span> <span class="toc-text">👽 虚拟机栈和本地方法栈为什么线程是私有的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">13.</span> <span class="toc-text">👽 什么是线程上下文切换?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BD-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">👽 Java多线程编程有几种线程间通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%8E-volatile%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">😎 volatile如何实现内存可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%8E-volatile%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">😎 volatile为什么不保证原子性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%8E-DCL%E5%8D%95%E4%BE%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A0volatile-%EF%BC%88%E5%8D%8A%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%89%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">😎 DCL单例为什么需要加volatile （半初始化的指令重排）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%8E-happen-before%E5%8E%9F%E5%88%99"><span class="toc-number">18.</span> <span class="toc-text">😎 happen-before原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%BB-Thread-Local-%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">👻 Thread Local 作用、原理、内存泄漏问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%8E%F0%9F%A4%A2-%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">😎🤢 说说 synchronized 关键字和 volatile 关键字的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%80-%E8%87%AA%E6%97%8B%E9%94%81-VS-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">21.</span> <span class="toc-text">😀 自旋锁 VS 适应性自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-Synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">🤢 Synchronized与ReentrantLock的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-synchronized%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">23.</span> <span class="toc-text">🤢 synchronized修饰的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">🤢 Synchronized实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%EF%BC%8C%E8%BF%99%E4%B8%AA%E2%80%9C%E9%94%81%E2%80%9D%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">🤢 获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-Synchronized%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">🤢 Synchronized的锁升级过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">🤢 为什么说 Synchronized 是可重入锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-synchronized%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">🤢 synchronized可重入锁的实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">29.</span> <span class="toc-text">🤢 为什么说 Synchronized 是非公平锁?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AAsynchronized%E6%96%B9%E6%B3%95%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="toc-number">30.</span> <span class="toc-text">🤢 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Synchronized-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">🤢 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%A1-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">😡 悲观锁和乐观锁的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%A1-MySQL%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">😡 MySQL如何实现乐观锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%91-CAS%E5%8E%9F%E7%90%86"><span class="toc-number">34.</span> <span class="toc-text">🧑 CAS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%91-CAS%E4%B9%90%E8%A7%82%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">🧑 CAS乐观锁有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%90%B1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E6%B6%88%E9%99%A4%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">🐱 什么是锁消除和锁粗化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%90%B1-AtomicInteger%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">37.</span> <span class="toc-text">🐱 AtomicInteger原子类源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-ReentrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">🤢 ReentrantLock实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-AQS%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">🤢 AQS原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-AQS%E4%B8%AD%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">40.</span> <span class="toc-text">🤢 AQS中的公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-AQS%E5%86%85%E9%83%A8%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">🤢 AQS内部如何控制并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A2-AQS%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8CAS%E5%92%8Cvolatile%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">🤢 AQS为什么底层使用CAS和volatile？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%A1-%E4%BA%86%E8%A7%A3CountDownLatch%E5%90%97%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">😡 了解CountDownLatch吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%A1-%E4%BA%86%E8%A7%A3CyclicBarrier%E5%90%97%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">😡 了解CyclicBarrier吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%A1-%E4%BA%86%E8%A7%A3Semaphore%E5%90%97"><span class="toc-number">45.</span> <span class="toc-text">😡 了解Semaphore吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%93-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E4%BB%A5%E4%B8%8B%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">46.</span> <span class="toc-text">😓 产生死锁必须具备以下四个条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%93-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">47.</span> <span class="toc-text">😓 如何预防和避免线程死锁?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%93-%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E3%80%81%E9%98%B2%E6%AD%A2%E3%80%81%E9%81%BF%E5%85%8D%E3%80%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">48.</span> <span class="toc-text">😓 死锁的产生、防止、避免、检测和解除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">49.</span> <span class="toc-text">😭 线程池以及使用线程池的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%887%E7%A7%8D%EF%BC%89"><span class="toc-number">50.</span> <span class="toc-text">😭 线程池的创建方式（7种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">51.</span> <span class="toc-text">😭 线程池中的工作队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-%E6%89%A7%E8%A1%8C-execute-%E6%96%B9%E6%B3%95%E5%92%8C-submit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">😭 执行 execute()方法和 submit()方法的区别是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-Thread%E5%92%8CRunnable%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">53.</span> <span class="toc-text">😭 Thread和Runnable的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-Callable%E5%92%8CFutureTask%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">54.</span> <span class="toc-text">😭 Callable和FutureTask的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-Future%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">😭 Future是什么？怎么使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-FutureTask%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">😭 FutureTask用来解决什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-number">57.</span> <span class="toc-text">😭 ThreadPoolExecutor构造函数重要参数分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">58.</span> <span class="toc-text">😭 提交一个任务到线程池的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%AD-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">😭 线程池的参数怎么设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%A3-BIO-NIO-AIO"><span class="toc-number">60.</span> <span class="toc-text">🤣 BIO&#x2F;NIO&#x2F;AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84IO%E5%8E%9F%E7%90%86"><span class="toc-number">60.1.</span> <span class="toc-text">Java中的IO原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">60.2.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">60.3.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3"><span class="toc-number">60.4.</span> <span class="toc-text">例子讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-number">60.5.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">60.6.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO"><span class="toc-number">60.7.</span> <span class="toc-text">AIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%98%87-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">61.</span> <span class="toc-text">😇 线程安全有哪些实现思路?</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e2442faf.html" title="List集合中的过滤方法"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/a467aebd801525568936c94d00561e433d9ad503-20231217161140266.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List集合中的过滤方法"/></a><div class="content"><a class="title" href="/posts/e2442faf.html" title="List集合中的过滤方法">List集合中的过滤方法</a><time datetime="2023-06-01T09:01:12.000Z" title="发表于 2023-06-01 17:01:12">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51bbb0f6.html" title="List集合中排序的几种方法"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/71e52c67f5094e44b92ccaed93db15c5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="List集合中排序的几种方法"/></a><div class="content"><a class="title" href="/posts/51bbb0f6.html" title="List集合中排序的几种方法">List集合中排序的几种方法</a><time datetime="2023-05-31T14:57:48.000Z" title="发表于 2023-05-31 22:57:48">2023-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bank2.html" title="银行会计学笔记"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/ddb5718952d4064e25629c7d1dc4dee50b53f456.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行会计学笔记"/></a><div class="content"><a class="title" href="/posts/bank2.html" title="银行会计学笔记">银行会计学笔记</a><time datetime="2023-05-25T07:15:24.000Z" title="发表于 2023-05-25 15:15:24">2023-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bank.html" title="银行的主营业务和运营模式"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/%E5%86%B0%E5%86%B0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="银行的主营业务和运营模式"/></a><div class="content"><a class="title" href="/posts/bank.html" title="银行的主营业务和运营模式">银行的主营业务和运营模式</a><time datetime="2023-05-25T07:15:24.000Z" title="发表于 2023-05-25 15:15:24">2023-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/docker.html" title="Docker的安装及常用命令"><img src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/20220820192714_c20e6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker的安装及常用命令"/></a><div class="content"><a class="title" href="/posts/docker.html" title="Docker的安装及常用命令">Docker的安装及常用命令</a><time datetime="2023-05-03T07:15:24.000Z" title="发表于 2023-05-03 15:15:24">2023-05-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By vulkhe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"><img class="icp-icon" src="https://cdn.jsdelivr.net/gh/HelingCode/CDN-vulkhe-Pic@master/uPic/2023/12/17/beian_logo-20231217160134340.png"><span>苏ICP备2021044866号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://helingcode.github.io/posts/java-juc.html'
    this.page.identifier = '/posts/java-juc.html'
    this.page.title = 'Java多线程面试题'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://cstube.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>